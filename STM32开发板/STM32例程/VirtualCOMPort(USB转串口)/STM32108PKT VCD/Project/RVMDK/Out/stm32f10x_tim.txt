; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Out\stm32f10x_tim.o --depend=.\Out\stm32f10x_tim.d --device=DARMSTM --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Core\CM3 -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I"D:\Program Files\KeilARM350\ARM\INC\ST\STM32F10x" ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;2696     */
;;;2697   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2698                          uint16_t TIM_ICFilter)
;;;2699   {
;;;2700     uint16_t tmpccmr1 = 0, tmpccer = 0;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
;;;2701     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2702     TIMx->CCER &= CCER_CC1E_Reset;
000006  8c06              LDRH     r6,[r0,#0x20]
000008  f64f77fe          MOV      r7,#0xfffe
00000c  403e              ANDS     r6,r6,r7
00000e  8406              STRH     r6,[r0,#0x20]
;;;2703     tmpccmr1 = TIMx->CCMR1;
000010  8b04              LDRH     r4,[r0,#0x18]
;;;2704     tmpccer = TIMx->CCER;
000012  8c05              LDRH     r5,[r0,#0x20]
;;;2705     /* Select the Input and set the filter */
;;;2706     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000014  f64f760c          MOV      r6,#0xff0c
000018  4034              ANDS     r4,r4,r6
;;;2707     tmpccmr1 |= TIM_ICSelection | (uint16_t)(TIM_ICFilter << 4);
00001a  051e              LSLS     r6,r3,#20
00001c  ea424616          ORR      r6,r2,r6,LSR #16
000020  4334              ORRS     r4,r4,r6
;;;2708     /* Select the Polarity and set the CC1E Bit */
;;;2709     tmpccer &= CCER_CC1P_Reset;
000022  1e7e              SUBS     r6,r7,#1
000024  4035              ANDS     r5,r5,r6
;;;2710     tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
000026  f0410601          ORR      r6,r1,#1
00002a  4335              ORRS     r5,r5,r6
;;;2711     /* Write to TIMx CCMR1 and CCER registers */
;;;2712     TIMx->CCMR1 = tmpccmr1;
00002c  8304              STRH     r4,[r0,#0x18]
;;;2713     TIMx->CCER = tmpccer;
00002e  8405              STRH     r5,[r0,#0x20]
;;;2714   }
000030  bdf0              POP      {r4-r7,pc}
;;;2715   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;2735     */
;;;2736   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2737                          uint16_t TIM_ICFilter)
;;;2738   {
;;;2739     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;2740     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2741     TIMx->CCER &= CCER_CC2E_Reset;
000008  8c07              LDRH     r7,[r0,#0x20]
00000a  f64f7cef          MOV      r12,#0xffef
00000e  ea07070c          AND      r7,r7,r12
000012  8407              STRH     r7,[r0,#0x20]
;;;2742     tmpccmr1 = TIMx->CCMR1;
000014  8b04              LDRH     r4,[r0,#0x18]
;;;2743     tmpccer = TIMx->CCER;
000016  8c05              LDRH     r5,[r0,#0x20]
;;;2744     tmp = (uint16_t)(TIM_ICPolarity << 4);
000018  050f              LSLS     r7,r1,#20
00001a  0c3e              LSRS     r6,r7,#16
;;;2745     /* Select the Input and set the filter */
;;;2746     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
00001c  f64047ff          MOV      r7,#0xcff
000020  403c              ANDS     r4,r4,r7
;;;2747     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
000022  071f              LSLS     r7,r3,#28
000024  ea444417          ORR      r4,r4,r7,LSR #16
;;;2748     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000028  0617              LSLS     r7,r2,#24
00002a  ea444417          ORR      r4,r4,r7,LSR #16
;;;2749     /* Select the Polarity and set the CC2E Bit */
;;;2750     tmpccer &= CCER_CC2P_Reset;
00002e  f64f77df          MOV      r7,#0xffdf
000032  403d              ANDS     r5,r5,r7
;;;2751     tmpccer |=  tmp | CCER_CC2E_Set;
000034  f0460710          ORR      r7,r6,#0x10
000038  433d              ORRS     r5,r5,r7
;;;2752     /* Write to TIMx CCMR1 and CCER registers */
;;;2753     TIMx->CCMR1 = tmpccmr1 ;
00003a  8304              STRH     r4,[r0,#0x18]
;;;2754     TIMx->CCER = tmpccer;
00003c  8405              STRH     r5,[r0,#0x20]
;;;2755   }
00003e  bdf0              POP      {r4-r7,pc}
;;;2756   
                          ENDP


                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=1

                  TI3_Config PROC
;;;2776     */
;;;2777   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2778                          uint16_t TIM_ICFilter)
;;;2779   {
;;;2780     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;2781     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2782     TIMx->CCER &= CCER_CC3E_Reset;
000008  8c07              LDRH     r7,[r0,#0x20]
00000a  f64f6cff          MOV      r12,#0xfeff
00000e  ea07070c          AND      r7,r7,r12
000012  8407              STRH     r7,[r0,#0x20]
;;;2783     tmpccmr2 = TIMx->CCMR2;
000014  8b84              LDRH     r4,[r0,#0x1c]
;;;2784     tmpccer = TIMx->CCER;
000016  8c05              LDRH     r5,[r0,#0x20]
;;;2785     tmp = (uint16_t)(TIM_ICPolarity << 8);
000018  060f              LSLS     r7,r1,#24
00001a  0c3e              LSRS     r6,r7,#16
;;;2786     /* Select the Input and set the filter */
;;;2787     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
00001c  f64f770c          MOV      r7,#0xff0c
000020  403c              ANDS     r4,r4,r7
;;;2788     tmpccmr2 |= TIM_ICSelection | (uint16_t)(TIM_ICFilter << 4);
000022  051f              LSLS     r7,r3,#20
000024  ea424717          ORR      r7,r2,r7,LSR #16
000028  433c              ORRS     r4,r4,r7
;;;2789     /* Select the Polarity and set the CC3E Bit */
;;;2790     tmpccer &= CCER_CC3P_Reset;
00002a  f64f57ff          MOV      r7,#0xfdff
00002e  403d              ANDS     r5,r5,r7
;;;2791     tmpccer |= tmp | CCER_CC3E_Set;
000030  f4467780          ORR      r7,r6,#0x100
000034  433d              ORRS     r5,r5,r7
;;;2792     /* Write to TIMx CCMR2 and CCER registers */
;;;2793     TIMx->CCMR2 = tmpccmr2;
000036  8384              STRH     r4,[r0,#0x1c]
;;;2794     TIMx->CCER = tmpccer;
000038  8405              STRH     r5,[r0,#0x20]
;;;2795   }
00003a  bdf0              POP      {r4-r7,pc}
;;;2796   
                          ENDP


                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=1

                  TI4_Config PROC
;;;2816     */
;;;2817   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2818                          uint16_t TIM_ICFilter)
;;;2819   {
;;;2820     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;2821     /* Disable the Channel 4: Reset the CC4E Bit */
;;;2822     TIMx->CCER &= CCER_CC4E_Reset;
000008  8c07              LDRH     r7,[r0,#0x20]
00000a  f64e7cff          MOV      r12,#0xefff
00000e  ea07070c          AND      r7,r7,r12
000012  8407              STRH     r7,[r0,#0x20]
;;;2823     tmpccmr2 = TIMx->CCMR2;
000014  8b84              LDRH     r4,[r0,#0x1c]
;;;2824     tmpccer = TIMx->CCER;
000016  8c05              LDRH     r5,[r0,#0x20]
;;;2825     tmp = (uint16_t)(TIM_ICPolarity << 12);
000018  070f              LSLS     r7,r1,#28
00001a  0c3e              LSRS     r6,r7,#16
;;;2826     /* Select the Input and set the filter */
;;;2827     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
00001c  f64047ff          MOV      r7,#0xcff
000020  403c              ANDS     r4,r4,r7
;;;2828     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8) | (uint16_t)(TIM_ICFilter << 12);
000022  0617              LSLS     r7,r2,#24
000024  0c3f              LSRS     r7,r7,#16
000026  ea4f7c03          LSL      r12,r3,#28
00002a  ea47471c          ORR      r7,r7,r12,LSR #16
00002e  433c              ORRS     r4,r4,r7
;;;2829     /* Select the Polarity and set the CC4E Bit */
;;;2830     tmpccer &= CCER_CC4P_Reset;
000030  f64d77ff          MOV      r7,#0xdfff
000034  403d              ANDS     r5,r5,r7
;;;2831     tmpccer |= tmp | CCER_CC4E_Set;
000036  f4465780          ORR      r7,r6,#0x1000
00003a  433d              ORRS     r5,r5,r7
;;;2832     /* Write to TIMx CCMR2 and CCER registers */
;;;2833     TIMx->CCMR2 = tmpccmr2;
00003c  8384              STRH     r4,[r0,#0x1c]
;;;2834     TIMx->CCER = tmpccer ;
00003e  8405              STRH     r5,[r0,#0x20]
;;;2835   }
000040  bdf0              POP      {r4-r7,pc}
;;;2836   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1418     */
;;;1419   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;1420   {
;;;1421     /* Check the parameters */
;;;1422     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1423     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1424     if (NewState != DISABLE)
;;;1425     {
;;;1426       /* Set the ARR Preload Bit */
;;;1427       TIMx->CR1 |= CR1_ARPE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;1428     }
;;;1429     else
;;;1430     {
;;;1431       /* Reset the ARR Preload Bit */
;;;1432       TIMx->CR1 &= CR1_ARPE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f240337f          MOV      r3,#0x37f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;1433     }
;;;1434   }
000016  4770              BX       lr
;;;1435   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;713      */
;;;714    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;718      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;719      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;720      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;721      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;722      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;723      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;724      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;725         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;726      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  f8a02044          STRH     r2,[r0,#0x44]
;;;727                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;728                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;729                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;730    }
00001e  4770              BX       lr
;;;731    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;788      */
;;;789    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;790    {
;;;791      /* Set the default configuration */
;;;792      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;793      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;794      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;795      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;796      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;797      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;798      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;799    }
000010  4770              BX       lr
;;;800    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1492     */
;;;1493   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;1494   { 
;;;1495     /* Check the parameters */
;;;1496     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1497     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1498     if (NewState != DISABLE)
;;;1499     {
;;;1500       /* Set the CCPC Bit */
;;;1501       TIMx->CR2 |= CR2_CCPC_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;1502     }
;;;1503     else
;;;1504     {
;;;1505       /* Reset the CCPC Bit */
;;;1506       TIMx->CR2 &= CR2_CCPC_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;1507     }
;;;1508   }
000016  4770              BX       lr
;;;1509   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;2000     */
;;;2001   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;2002   {
;;;2003     /* Check the parameters */
;;;2004     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2005     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2006     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2007     /* Reset the CCxE Bit */
;;;2008     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43e4              MVNS     r4,r4
00000a  b2a4              UXTH     r4,r4
00000c  4023              ANDS     r3,r3,r4
00000e  8403              STRH     r3,[r0,#0x20]
;;;2009     /* Set or reset the CCxE Bit */ 
;;;2010     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000010  8c03              LDRH     r3,[r0,#0x20]
000012  fa02f401          LSL      r4,r2,r1
000016  b2a4              UXTH     r4,r4
000018  4323              ORRS     r3,r3,r4
00001a  8403              STRH     r3,[r0,#0x20]
;;;2011   }
00001c  bd10              POP      {r4,pc}
;;;2012   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;2024     */
;;;2025   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;2026   {
;;;2027     /* Check the parameters */
;;;2028     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2029     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2030     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2031     /* Reset the CCxNE Bit */
;;;2032     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCNE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  43e4              MVNS     r4,r4
00000a  b2a4              UXTH     r4,r4
00000c  4023              ANDS     r3,r3,r4
00000e  8403              STRH     r3,[r0,#0x20]
;;;2033     /* Set or reset the CCxNE Bit */ 
;;;2034     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000010  8c03              LDRH     r3,[r0,#0x20]
000012  fa02f401          LSL      r4,r2,r1
000016  b2a4              UXTH     r4,r4
000018  4323              ORRS     r3,r3,r4
00001a  8403              STRH     r3,[r0,#0x20]
;;;2035   }
00001c  bd10              POP      {r4,pc}
;;;2036   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2602     */
;;;2603   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2604   {  
;;;2605     /* Check the parameters */
;;;2606     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2607     assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
;;;2608      
;;;2609     /* Clear the flags */
;;;2610     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;2611   }
000004  4770              BX       lr
;;;2612   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2667     */
;;;2668   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43ca              MVNS     r2,r1
;;;2669   {
;;;2670     /* Check the parameters */
;;;2671     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2672     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2673     /* Clear the IT pending Bit */
;;;2674     TIMx->SR = (uint16_t)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;2675   }
000004  4770              BX       lr
;;;2676   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1727     */
;;;1728   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  2200              MOVS     r2,#0
;;;1729   {
;;;1730     uint16_t tmpccmr1 = 0;
;;;1731     /* Check the parameters */
;;;1732     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1733     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1734     tmpccmr1 = TIMx->CCMR1;
000002  8b02              LDRH     r2,[r0,#0x18]
;;;1735     /* Reset the OC1CE Bit */
;;;1736     tmpccmr1 &= CCMR_OC13CE_Reset;
000004  f64f737f          MOV      r3,#0xff7f
000008  401a              ANDS     r2,r2,r3
;;;1737     /* Enable or Disable the Output Compare Clear Bit */
;;;1738     tmpccmr1 |= TIM_OCClear;
00000a  430a              ORRS     r2,r2,r1
;;;1739     /* Write to TIMx CCMR1 register */
;;;1740     TIMx->CCMR1 = tmpccmr1;
00000c  8302              STRH     r2,[r0,#0x18]
;;;1741   }
00000e  4770              BX       lr
;;;1742   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1752     */
;;;1753   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  2200              MOVS     r2,#0
;;;1754   {
;;;1755     uint16_t tmpccmr1 = 0;
;;;1756     /* Check the parameters */
;;;1757     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1758     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1759     tmpccmr1 = TIMx->CCMR1;
000002  8b02              LDRH     r2,[r0,#0x18]
;;;1760     /* Reset the OC2CE Bit */
;;;1761     tmpccmr1 &= CCMR_OC24CE_Reset;
000004  f3c2020e          UBFX     r2,r2,#0,#15
;;;1762     /* Enable or Disable the Output Compare Clear Bit */
;;;1763     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000008  060b              LSLS     r3,r1,#24
00000a  ea424213          ORR      r2,r2,r3,LSR #16
;;;1764     /* Write to TIMx CCMR1 register */
;;;1765     TIMx->CCMR1 = tmpccmr1;
00000e  8302              STRH     r2,[r0,#0x18]
;;;1766   }
000010  4770              BX       lr
;;;1767   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1777     */
;;;1778   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  2200              MOVS     r2,#0
;;;1779   {
;;;1780     uint16_t tmpccmr2 = 0;
;;;1781     /* Check the parameters */
;;;1782     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1783     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1784     tmpccmr2 = TIMx->CCMR2;
000002  8b82              LDRH     r2,[r0,#0x1c]
;;;1785     /* Reset the OC3CE Bit */
;;;1786     tmpccmr2 &= CCMR_OC13CE_Reset;
000004  f64f737f          MOV      r3,#0xff7f
000008  401a              ANDS     r2,r2,r3
;;;1787     /* Enable or Disable the Output Compare Clear Bit */
;;;1788     tmpccmr2 |= TIM_OCClear;
00000a  430a              ORRS     r2,r2,r1
;;;1789     /* Write to TIMx CCMR2 register */
;;;1790     TIMx->CCMR2 = tmpccmr2;
00000c  8382              STRH     r2,[r0,#0x1c]
;;;1791   }
00000e  4770              BX       lr
;;;1792   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1802     */
;;;1803   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  2200              MOVS     r2,#0
;;;1804   {
;;;1805     uint16_t tmpccmr2 = 0;
;;;1806     /* Check the parameters */
;;;1807     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1808     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1809     tmpccmr2 = TIMx->CCMR2;
000002  8b82              LDRH     r2,[r0,#0x1c]
;;;1810     /* Reset the OC4CE Bit */
;;;1811     tmpccmr2 &= CCMR_OC24CE_Reset;
000004  f3c2020e          UBFX     r2,r2,#0,#15
;;;1812     /* Enable or Disable the Output Compare Clear Bit */
;;;1813     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000008  060b              LSLS     r3,r1,#24
00000a  ea424213          ORR      r2,r2,r3,LSR #16
;;;1814     /* Write to TIMx CCMR2 register */
;;;1815     TIMx->CCMR2 = tmpccmr2;
00000e  8382              STRH     r2,[r0,#0x1c]
;;;1816   }
000010  4770              BX       lr
;;;1817   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;807      */
;;;808    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;809    {
;;;810      /* Check the parameters */
;;;811      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;812      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;813      
;;;814      if (NewState != DISABLE)
;;;815      {
;;;816        /* Enable the TIM Counter */
;;;817        TIMx->CR1 |= CR1_CEN_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;818      }
;;;819      else
;;;820      {
;;;821        /* Disable the TIM Counter */
;;;822        TIMx->CR1 &= CR1_CEN_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fe          MOV      r3,#0x3fe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;823      }
;;;824    }
000016  4770              BX       lr
;;;825    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1198     */
;;;1199   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  2200              MOVS     r2,#0
;;;1200   {
;;;1201     uint16_t tmpcr1 = 0;
;;;1202     /* Check the parameters */
;;;1203     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1204     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1205     tmpcr1 = TIMx->CR1;
000002  8802              LDRH     r2,[r0,#0]
;;;1206     /* Reset the CMS and DIR Bits */
;;;1207     tmpcr1 &= CR1_CounterMode_Mask;
000004  f240338f          MOV      r3,#0x38f
000008  401a              ANDS     r2,r2,r3
;;;1208     /* Set the Counter Mode */
;;;1209     tmpcr1 |= TIM_CounterMode;
00000a  430a              ORRS     r2,r2,r1
;;;1210     /* Write to TIMx CR1 register */
;;;1211     TIMx->CR1 = tmpcr1;
00000c  8002              STRH     r2,[r0,#0]
;;;1212   }
00000e  4770              BX       lr
;;;1213   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;832      */
;;;833    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b131              CBZ      r1,|L19.16|
;;;834    {
;;;835      /* Check the parameters */
;;;836      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;837      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;838      if (NewState != DISABLE)
;;;839      {
;;;840        /* Enable the TIM Main Output */
;;;841        TIMx->BDTR |= BDTR_MOE_Set;
000002  f8b02044          LDRH     r2,[r0,#0x44]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  f8a02044          STRH     r2,[r0,#0x44]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;842      }
;;;843      else
;;;844      {
;;;845        /* Disable the TIM Main Output */
;;;846        TIMx->BDTR &= BDTR_MOE_Reset;
000010  f8b02044          LDRH     r2,[r0,#0x44]
000014  f3c2020e          UBFX     r2,r2,#0,#15
000018  f8a02044          STRH     r2,[r0,#0x44]
                  |L19.28|
;;;847      }  
;;;848    }
00001c  4770              BX       lr
;;;849    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;954      */
;;;955    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;956    { 
;;;957      /* Check the parameters */
;;;958      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;959      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;960      assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
;;;961      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;962      
;;;963      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L20.12|
;;;964      {
;;;965        /* Enable the DMA sources */
;;;966        TIMx->DIER |= TIM_DMASource; 
000004  8983              LDRH     r3,[r0,#0xc]
000006  430b              ORRS     r3,r3,r1
000008  8183              STRH     r3,[r0,#0xc]
00000a  e004              B        |L20.22|
                  |L20.12|
;;;967      }
;;;968      else
;;;969      {
;;;970        /* Disable the DMA sources */
;;;971        TIMx->DIER &= (uint16_t)~TIM_DMASource;
00000c  8983              LDRH     r3,[r0,#0xc]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  8183              STRH     r3,[r0,#0xc]
                  |L20.22|
;;;972      }
;;;973    }
000016  bd10              POP      {r4,pc}
;;;974    
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;928      */
;;;929    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;930    {
;;;931      /* Check the parameters */
;;;932      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;933      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;934      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;935      /* Set the DMA Base and the DMA Burst Length */
;;;936      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  f8a03048          STRH     r3,[r0,#0x48]
;;;937    }
000008  4770              BX       lr
;;;938    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;188      */
;;;189    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;190    {
000002  4604              MOV      r4,r0
;;;191      /* Check the parameters */
;;;192      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;193     
;;;194      switch (*(uint32_t*)&TIMx)
000004  4934              LDR      r1,|L22.216|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d045              BEQ      |L22.152|
00000c  dc0c              BGT      |L22.40|
00000e  f1b44f80          CMP      r4,#0x40000000
000012  d01d              BEQ      |L22.80|
000014  4831              LDR      r0,|L22.220|
000016  1820              ADDS     r0,r4,r0
000018  d023              BEQ      |L22.98|
00001a  f5b06f80          CMP      r0,#0x400
00001e  d029              BEQ      |L22.116|
000020  f5b06f00          CMP      r0,#0x800
000024  d154              BNE      |L22.208|
000026  e02e              B        |L22.134|
                  |L22.40|
000028  f5b06f80          CMP      r0,#0x400
00002c  d03d              BEQ      |L22.170|
00002e  f5b03f8e          CMP      r0,#0x11c00
000032  d003              BEQ      |L22.60|
000034  f5b03f92          CMP      r0,#0x12400
000038  d14a              BNE      |L22.208|
00003a  e03f              B        |L22.188|
                  |L22.60|
;;;195      {
;;;196        case TIM1_BASE:
;;;197          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  02c8              LSLS     r0,r1,#11
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;198          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000044  2100              MOVS     r1,#0
000046  f44f6000          MOV      r0,#0x800
00004a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;199          break; 
00004e  e040              B        |L22.210|
                  |L22.80|
;;;200          
;;;201        case TIM2_BASE:
;;;202          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000050  2101              MOVS     r1,#1
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;203          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
000058  2100              MOVS     r1,#0
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;204          break;
000060  e037              B        |L22.210|
                  |L22.98|
;;;205     
;;;206        case TIM3_BASE:
;;;207          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000062  2101              MOVS     r1,#1
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;208          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00006a  2100              MOVS     r1,#0
00006c  2002              MOVS     r0,#2
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;209          break;
000072  e02e              B        |L22.210|
                  |L22.116|
;;;210     
;;;211        case TIM4_BASE:
;;;212          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000074  2101              MOVS     r1,#1
000076  2004              MOVS     r0,#4
000078  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;213          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00007c  2100              MOVS     r1,#0
00007e  2004              MOVS     r0,#4
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;214          break;
000084  e025              B        |L22.210|
                  |L22.134|
;;;215          
;;;216        case TIM5_BASE:
;;;217          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000086  2101              MOVS     r1,#1
000088  2008              MOVS     r0,#8
00008a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;218          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00008e  2100              MOVS     r1,#0
000090  2008              MOVS     r0,#8
000092  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;219          break;
000096  e01c              B        |L22.210|
                  |L22.152|
;;;220          
;;;221        case TIM6_BASE:
;;;222          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000098  2101              MOVS     r1,#1
00009a  2010              MOVS     r0,#0x10
00009c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;223          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
0000a0  2100              MOVS     r1,#0
0000a2  2010              MOVS     r0,#0x10
0000a4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;224          break;
0000a8  e013              B        |L22.210|
                  |L22.170|
;;;225          
;;;226        case TIM7_BASE:
;;;227          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  2020              MOVS     r0,#0x20
0000ae  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;228          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000b2  2100              MOVS     r1,#0
0000b4  2020              MOVS     r0,#0x20
0000b6  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;229          break;
0000ba  e00a              B        |L22.210|
                  |L22.188|
;;;230          
;;;231        case TIM8_BASE:
;;;232          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  0348              LSLS     r0,r1,#13
0000c0  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;233          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000c4  2100              MOVS     r1,#0
0000c6  f44f5000          MOV      r0,#0x2000
0000ca  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;234          break; 
0000ce  e000              B        |L22.210|
                  |L22.208|
;;;235          
;;;236        default:
;;;237          break;
0000d0  bf00              NOP      
                  |L22.210|
0000d2  bf00              NOP                            ;199
;;;238      }
;;;239    }
0000d4  bd10              POP      {r4,pc}
;;;240    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L22.216|
                          DCD      0x40001000
                  |L22.220|
                          DCD      0xbffffc00

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1069     */
;;;1070   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1071                                uint16_t ExtTRGFilter)
;;;1072   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;1073     uint16_t tmpsmcr = 0;
00000c  2700              MOVS     r7,#0
;;;1074     /* Check the parameters */
;;;1075     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1076     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1077     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1078     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1079     /* Configure the ETR Clock source */
;;;1080     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  4632              MOV      r2,r6
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       TIM_ETRConfig
;;;1081     
;;;1082     /* Get the TIMx SMCR register value */
;;;1083     tmpsmcr = TIMx->SMCR;
00001a  8927              LDRH     r7,[r4,#8]
;;;1084     /* Reset the SMS Bits */
;;;1085     tmpsmcr &= SMCR_SMS_Mask;
00001c  f64f70f8          MOV      r0,#0xfff8
000020  4007              ANDS     r7,r7,r0
;;;1086     /* Select the External clock mode1 */
;;;1087     tmpsmcr |= TIM_SlaveMode_External1;
000022  f0470707          ORR      r7,r7,#7
;;;1088     /* Select the Trigger selection : ETRF */
;;;1089     tmpsmcr &= SMCR_TS_Mask;
000026  f64f708f          MOV      r0,#0xff8f
00002a  4007              ANDS     r7,r7,r0
;;;1090     tmpsmcr |= TIM_TS_ETRF;
00002c  f0470770          ORR      r7,r7,#0x70
;;;1091     /* Write to TIMx SMCR */
;;;1092     TIMx->SMCR = tmpsmcr;
000030  8127              STRH     r7,[r4,#8]
;;;1093   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;1094   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1112     */
;;;1113   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;1114                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1115   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;1116     /* Check the parameters */
;;;1117     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1118     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1119     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1120     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1121     /* Configure the ETR Clock source */
;;;1122     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;1123     /* Enable the External clock mode2 */
;;;1124     TIMx->SMCR |= SMCR_ECE_Set;
000016  8920              LDRH     r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  8120              STRH     r0,[r4,#8]
;;;1125   }
00001e  bdf0              POP      {r4-r7,pc}
;;;1126   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1144     */
;;;1145   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b570              PUSH     {r4-r6,lr}
;;;1146                      uint16_t ExtTRGFilter)
;;;1147   {
;;;1148     uint16_t tmpsmcr = 0;
000002  2400              MOVS     r4,#0
;;;1149     /* Check the parameters */
;;;1150     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1151     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1152     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1153     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1154     tmpsmcr = TIMx->SMCR;
000004  8904              LDRH     r4,[r0,#8]
;;;1155     /* Reset the ETR Bits */
;;;1156     tmpsmcr &= SMCR_ETR_Mask;
000006  b2e4              UXTB     r4,r4
;;;1157     /* Set the Prescaler, the Filter value and the Polarity */
;;;1158     tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << 8);
000008  ea410502          ORR      r5,r1,r2
00000c  061e              LSLS     r6,r3,#24
00000e  ea454516          ORR      r5,r5,r6,LSR #16
000012  432c              ORRS     r4,r4,r5
;;;1159     /* Write to TIMx SMCR */
;;;1160     TIMx->SMCR = tmpsmcr;
000014  8104              STRH     r4,[r0,#8]
;;;1161   }
000016  bd70              POP      {r4-r6,pc}
;;;1162   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1267     */
;;;1268   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1269                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1270   {
;;;1271     uint16_t tmpsmcr = 0;
000002  2400              MOVS     r4,#0
;;;1272     uint16_t tmpccmr1 = 0;
000004  2500              MOVS     r5,#0
;;;1273     uint16_t tmpccer = 0;
000006  2600              MOVS     r6,#0
;;;1274       
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1277     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1278     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1279     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1280     /* Get the TIMx SMCR register value */
;;;1281     tmpsmcr = TIMx->SMCR;
000008  8904              LDRH     r4,[r0,#8]
;;;1282     /* Get the TIMx CCMR1 register value */
;;;1283     tmpccmr1 = TIMx->CCMR1;
00000a  8b05              LDRH     r5,[r0,#0x18]
;;;1284     /* Get the TIMx CCER register value */
;;;1285     tmpccer = TIMx->CCER;
00000c  8c06              LDRH     r6,[r0,#0x20]
;;;1286     /* Set the encoder Mode */
;;;1287     tmpsmcr &= SMCR_SMS_Mask;
00000e  f64f77f8          MOV      r7,#0xfff8
000012  403c              ANDS     r4,r4,r7
;;;1288     tmpsmcr |= TIM_EncoderMode;
000014  430c              ORRS     r4,r4,r1
;;;1289     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1290     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
000016  f64f47fc          MOV      r7,#0xfcfc
00001a  403d              ANDS     r5,r5,r7
;;;1291     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
00001c  f2401701          MOV      r7,#0x101
000020  433d              ORRS     r5,r5,r7
;;;1292     /* Set the TI1 and the TI2 Polarities */
;;;1293     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
000022  f64f77dd          MOV      r7,#0xffdd
000026  403e              ANDS     r6,r6,r7
;;;1294     tmpccer |= (TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << 4));
000028  051f              LSLS     r7,r3,#20
00002a  ea424717          ORR      r7,r2,r7,LSR #16
00002e  433e              ORRS     r6,r6,r7
;;;1295     /* Write to TIMx SMCR */
;;;1296     TIMx->SMCR = tmpsmcr;
000030  8104              STRH     r4,[r0,#8]
;;;1297     /* Write to TIMx CCMR1 */
;;;1298     TIMx->CCMR1 = tmpccmr1;
000032  8305              STRH     r5,[r0,#0x18]
;;;1299     /* Write to TIMx CCER */
;;;1300     TIMx->CCER = tmpccer;
000034  8406              STRH     r6,[r0,#0x20]
;;;1301   }
000036  bdf0              POP      {r4-r7,pc}
;;;1302   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1314     */
;;;1315   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  2200              MOVS     r2,#0
;;;1316   {
;;;1317     uint16_t tmpccmr1 = 0;
;;;1318     /* Check the parameters */
;;;1319     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1320     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1321     tmpccmr1 = TIMx->CCMR1;
000002  8b02              LDRH     r2,[r0,#0x18]
;;;1322     /* Reset the OC1M Bits */
;;;1323     tmpccmr1 &= CCMR_OC13M_Mask;
000004  f64f738f          MOV      r3,#0xff8f
000008  401a              ANDS     r2,r2,r3
;;;1324     /* Configure The Forced output Mode */
;;;1325     tmpccmr1 |= TIM_ForcedAction;
00000a  430a              ORRS     r2,r2,r1
;;;1326     /* Write to TIMx CCMR1 register */
;;;1327     TIMx->CCMR1 = tmpccmr1;
00000c  8302              STRH     r2,[r0,#0x18]
;;;1328   }
00000e  4770              BX       lr
;;;1329   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1341     */
;;;1342   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  2200              MOVS     r2,#0
;;;1343   {
;;;1344     uint16_t tmpccmr1 = 0;
;;;1345     /* Check the parameters */
;;;1346     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1347     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1348     tmpccmr1 = TIMx->CCMR1;
000002  8b02              LDRH     r2,[r0,#0x18]
;;;1349     /* Reset the OC2M Bits */
;;;1350     tmpccmr1 &= CCMR_OC24M_Mask;
000004  f64873ff          MOV      r3,#0x8fff
000008  401a              ANDS     r2,r2,r3
;;;1351     /* Configure The Forced output Mode */
;;;1352     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00000a  060b              LSLS     r3,r1,#24
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1353     /* Write to TIMx CCMR1 register */
;;;1354     TIMx->CCMR1 = tmpccmr1;
000010  8302              STRH     r2,[r0,#0x18]
;;;1355   }
000012  4770              BX       lr
;;;1356   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1368     */
;;;1369   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  2200              MOVS     r2,#0
;;;1370   {
;;;1371     uint16_t tmpccmr2 = 0;
;;;1372     /* Check the parameters */
;;;1373     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1374     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1375     tmpccmr2 = TIMx->CCMR2;
000002  8b82              LDRH     r2,[r0,#0x1c]
;;;1376     /* Reset the OC1M Bits */
;;;1377     tmpccmr2 &= CCMR_OC13M_Mask;
000004  f64f738f          MOV      r3,#0xff8f
000008  401a              ANDS     r2,r2,r3
;;;1378     /* Configure The Forced output Mode */
;;;1379     tmpccmr2 |= TIM_ForcedAction;
00000a  430a              ORRS     r2,r2,r1
;;;1380     /* Write to TIMx CCMR2 register */
;;;1381     TIMx->CCMR2 = tmpccmr2;
00000c  8382              STRH     r2,[r0,#0x1c]
;;;1382   }
00000e  4770              BX       lr
;;;1383   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1395     */
;;;1396   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  2200              MOVS     r2,#0
;;;1397   {
;;;1398     uint16_t tmpccmr2 = 0;
;;;1399     /* Check the parameters */
;;;1400     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1401     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1402     tmpccmr2 = TIMx->CCMR2;
000002  8b82              LDRH     r2,[r0,#0x1c]
;;;1403     /* Reset the OC2M Bits */
;;;1404     tmpccmr2 &= CCMR_OC24M_Mask;
000004  f64873ff          MOV      r3,#0x8fff
000008  401a              ANDS     r2,r2,r3
;;;1405     /* Configure The Forced output Mode */
;;;1406     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00000a  060b              LSLS     r3,r1,#24
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1407     /* Write to TIMx CCMR2 register */
;;;1408     TIMx->CCMR2 = tmpccmr2;
000010  8382              STRH     r2,[r0,#0x1c]
;;;1409   }
000012  4770              BX       lr
;;;1410   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;900      */
;;;901    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;902    { 
;;;903      /* Check the parameters */
;;;904      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;905      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;906      assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
;;;907      /* Set the event sources */
;;;908      TIMx->EGR = TIM_EventSource;
;;;909    }
000002  4770              BX       lr
;;;910    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2469     */
;;;2470   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2471   {
;;;2472     /* Check the parameters */
;;;2473     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2474     /* Get the Capture 1 Register value */
;;;2475     return TIMx->CCR1;
000002  8e88              LDRH     r0,[r1,#0x34]
;;;2476   }
000004  4770              BX       lr
;;;2477   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2483     */
;;;2484   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2485   {
;;;2486     /* Check the parameters */
;;;2487     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2488     /* Get the Capture 2 Register value */
;;;2489     return TIMx->CCR2;
000002  8f08              LDRH     r0,[r1,#0x38]
;;;2490   }
000004  4770              BX       lr
;;;2491   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2497     */
;;;2498   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2499   {
;;;2500     /* Check the parameters */
;;;2501     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2502     /* Get the Capture 3 Register value */
;;;2503     return TIMx->CCR3;
000002  8f88              LDRH     r0,[r1,#0x3c]
;;;2504   }
000004  4770              BX       lr
;;;2505   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2511     */
;;;2512   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2513   {
;;;2514     /* Check the parameters */
;;;2515     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2516     /* Get the Capture 4 Register value */
;;;2517     return TIMx->CCR4;
000002  f8b10040          LDRH     r0,[r1,#0x40]
;;;2518   }
000006  4770              BX       lr
;;;2519   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2524     */
;;;2525   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2526   {
;;;2527     /* Check the parameters */
;;;2528     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2529     /* Get the Counter Register value */
;;;2530     return TIMx->CNT;
000002  8c88              LDRH     r0,[r1,#0x24]
;;;2531   }
000004  4770              BX       lr
;;;2532   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2564     */
;;;2565   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2566   { 
;;;2567     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2568     /* Check the parameters */
;;;2569     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2570     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2571     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2572     
;;;2573     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  420b              TST      r3,r1
000008  d001              BEQ      |L37.14|
;;;2574     {
;;;2575       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;2576     }
;;;2577     else
;;;2578     {
;;;2579       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;2580     }
;;;2581     return bitstatus;
;;;2582   }
000010  4770              BX       lr
;;;2583   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2628     */
;;;2629   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2630   {
000002  4602              MOV      r2,r0
;;;2631     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2632     uint16_t itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2633     /* Check the parameters */
;;;2634     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2635     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2636     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2637      
;;;2638     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;2639     
;;;2640     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;2641     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;2642     {
;;;2643       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;2644     }
;;;2645     else
;;;2646     {
;;;2647       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;2648     }
;;;2649     return bitstatus;
;;;2650   }
000020  bd30              POP      {r4,r5,pc}
;;;2651   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2537     */
;;;2538   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2539   {
;;;2540     /* Check the parameters */
;;;2541     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2542     /* Get the Prescaler Register value */
;;;2543     return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;2544   }
000004  4770              BX       lr
;;;2545   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;595      */
;;;596    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;597    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;598      /* Check the parameters */
;;;599      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;600      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;601      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;602      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;603      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;604      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;605      
;;;606      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8828              LDRH     r0,[r5,#0]
000008  b950              CBNZ     r0,|L40.32|
;;;607      {
;;;608        /* TI1 Configuration */
;;;609        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000a  892b              LDRH     r3,[r5,#8]
00000c  88aa              LDRH     r2,[r5,#4]
00000e  8869              LDRH     r1,[r5,#2]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TI1_Config
;;;610                   TIM_ICInitStruct->TIM_ICSelection,
;;;611                   TIM_ICInitStruct->TIM_ICFilter);
;;;612        /* Set the Input Capture Prescaler value */
;;;613        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000016  88e9              LDRH     r1,[r5,#6]
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SetIC1Prescaler
00001e  e025              B        |L40.108|
                  |L40.32|
;;;614      }
;;;615      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000020  8828              LDRH     r0,[r5,#0]
000022  2804              CMP      r0,#4
000024  d10a              BNE      |L40.60|
;;;616      {
;;;617        /* TI2 Configuration */
;;;618        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000026  892b              LDRH     r3,[r5,#8]
000028  88aa              LDRH     r2,[r5,#4]
00002a  8869              LDRH     r1,[r5,#2]
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TI2_Config
;;;619                   TIM_ICInitStruct->TIM_ICSelection,
;;;620                   TIM_ICInitStruct->TIM_ICFilter);
;;;621        /* Set the Input Capture Prescaler value */
;;;622        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e9              LDRH     r1,[r5,#6]
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       TIM_SetIC2Prescaler
00003a  e017              B        |L40.108|
                  |L40.60|
;;;623      }
;;;624      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003c  8828              LDRH     r0,[r5,#0]
00003e  2808              CMP      r0,#8
000040  d10a              BNE      |L40.88|
;;;625      {
;;;626        /* TI3 Configuration */
;;;627        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000042  892b              LDRH     r3,[r5,#8]
000044  88aa              LDRH     r2,[r5,#4]
000046  8869              LDRH     r1,[r5,#2]
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       TI3_Config
;;;628                   TIM_ICInitStruct->TIM_ICSelection,
;;;629                   TIM_ICInitStruct->TIM_ICFilter);
;;;630        /* Set the Input Capture Prescaler value */
;;;631        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004e  88e9              LDRH     r1,[r5,#6]
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       TIM_SetIC3Prescaler
000056  e009              B        |L40.108|
                  |L40.88|
;;;632      }
;;;633      else
;;;634      {
;;;635        /* TI4 Configuration */
;;;636        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000058  892b              LDRH     r3,[r5,#8]
00005a  88aa              LDRH     r2,[r5,#4]
00005c  8869              LDRH     r1,[r5,#2]
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       TI4_Config
;;;637                   TIM_ICInitStruct->TIM_ICSelection,
;;;638                   TIM_ICInitStruct->TIM_ICFilter);
;;;639        /* Set the Input Capture Prescaler value */
;;;640        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000064  88e9              LDRH     r1,[r5,#6]
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.108|
;;;641      }
;;;642    }
00006c  bd70              POP      {r4-r6,pc}
;;;643    
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;772      */
;;;773    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;774    {
;;;775      /* Set the default configuration */
;;;776      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;777      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;778      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;779      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;780      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;781    }
000010  4770              BX       lr
;;;782    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;867      */
;;;868    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;869    {  
;;;870      /* Check the parameters */
;;;871      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;872      assert_param(IS_TIM_IT(TIM_IT));
;;;873      assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
;;;874      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;875      
;;;876      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L42.12|
;;;877      {
;;;878        /* Enable the Interrupt sources */
;;;879        TIMx->DIER |= TIM_IT;
000004  8983              LDRH     r3,[r0,#0xc]
000006  430b              ORRS     r3,r3,r1
000008  8183              STRH     r3,[r0,#0xc]
00000a  e004              B        |L42.22|
                  |L42.12|
;;;880      }
;;;881      else
;;;882      {
;;;883        /* Disable the Interrupt sources */
;;;884        TIMx->DIER &= (uint16_t)~TIM_IT;
00000c  8983              LDRH     r3,[r0,#0xc]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  8183              STRH     r3,[r0,#0xc]
                  |L42.22|
;;;885      }
;;;886    }
000016  bd10              POP      {r4,pc}
;;;887    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;1000     */
;;;1001   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1002   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1003     /* Check the parameters */
;;;1004     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1005     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1006     /* Select the Internal Trigger */
;;;1007     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;1008     /* Select the External clock mode1 */
;;;1009     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  8120              STRH     r0,[r4,#8]
;;;1010   }
000016  bd30              POP      {r4,r5,pc}
;;;1011   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;980      */
;;;981    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;982    {
;;;983      /* Check the parameters */
;;;984      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;985      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;986      TIMx->SMCR &=  SMCR_SMS_Mask;
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;987    }
00000a  4770              BX       lr
;;;988    
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1623     */
;;;1624   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  2200              MOVS     r2,#0
;;;1625   {
;;;1626     uint16_t tmpccmr1 = 0;
;;;1627     /* Check the parameters */
;;;1628     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1629     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1630     /* Get the TIMx CCMR1 register value */
;;;1631     tmpccmr1 = TIMx->CCMR1;
000002  8b02              LDRH     r2,[r0,#0x18]
;;;1632     /* Reset the OC1FE Bit */
;;;1633     tmpccmr1 &= CCMR_OC13FE_Reset;
000004  f64f73fb          MOV      r3,#0xfffb
000008  401a              ANDS     r2,r2,r3
;;;1634     /* Enable or Disable the Output Compare Fast Bit */
;;;1635     tmpccmr1 |= TIM_OCFast;
00000a  430a              ORRS     r2,r2,r1
;;;1636     /* Write to TIMx CCMR1 */
;;;1637     TIMx->CCMR1 = tmpccmr1;
00000c  8302              STRH     r2,[r0,#0x18]
;;;1638   }
00000e  4770              BX       lr
;;;1639   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;287      */
;;;288    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;289    {
;;;290      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;291       
;;;292      /* Check the parameters */
;;;293      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;294      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;295      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;296      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;297      /* Disable the Channel 1: Reset the CC1E Bit */
;;;298      TIMx->CCER &= CCER_CC1E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;299      
;;;300      /* Get the TIMx CCER register value */
;;;301      tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;302      /* Get the TIMx CR2 register value */
;;;303      tmpcr2 =  TIMx->CR2;
000014  8884              LDRH     r4,[r0,#4]
;;;304      
;;;305      /* Get the TIMx CCMR1 register value */
;;;306      tmpccmrx = TIMx->CCMR1;
000016  8b02              LDRH     r2,[r0,#0x18]
;;;307        
;;;308      /* Reset the Output Compare Mode Bits */
;;;309      tmpccmrx &= CCMR_OC13M_Mask;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402a              ANDS     r2,r2,r5
;;;310      
;;;311      /* Select the Output Compare Mode */
;;;312      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432a              ORRS     r2,r2,r5
;;;313      
;;;314      /* Reset the Output Polarity level */
;;;315      tmpccer &= CCER_CC1P_Reset;
000022  1e75              SUBS     r5,r6,#1
000024  402b              ANDS     r3,r3,r5
;;;316      /* Set the Output Compare Polarity */
;;;317      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000026  890d              LDRH     r5,[r1,#8]
000028  432b              ORRS     r3,r3,r5
;;;318      
;;;319      /* Set the Output State */
;;;320      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002a  884d              LDRH     r5,[r1,#2]
00002c  432b              ORRS     r3,r3,r5
;;;321      
;;;322      /* Set the Capture Compare Register value */
;;;323      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00002e  88cd              LDRH     r5,[r1,#6]
000030  8685              STRH     r5,[r0,#0x34]
;;;324      
;;;325      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
000032  4d0f              LDR      r5,|L46.112|
000034  42a8              CMP      r0,r5
000036  d002              BEQ      |L46.62|
000038  4d0e              LDR      r5,|L46.116|
00003a  42a8              CMP      r0,r5
00003c  d113              BNE      |L46.102|
                  |L46.62|
;;;326      {
;;;327        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;328        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;329        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;330        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;331        
;;;332        /* Reset the Output N Polarity level */
;;;333        tmpccer &= CCER_CC1NP_Reset;
00003e  f64f75f7          MOV      r5,#0xfff7
000042  402b              ANDS     r3,r3,r5
;;;334        /* Set the Output N Polarity */
;;;335        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000044  894d              LDRH     r5,[r1,#0xa]
000046  432b              ORRS     r3,r3,r5
;;;336        /* Reset the Output N State */
;;;337        tmpccer &= CCER_CC1NE_Reset;
000048  f64f75fb          MOV      r5,#0xfffb
00004c  402b              ANDS     r3,r3,r5
;;;338        
;;;339        /* Set the Output N State */
;;;340        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00004e  888d              LDRH     r5,[r1,#4]
000050  432b              ORRS     r3,r3,r5
;;;341        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;342        tmpcr2 &= CR2_OIS1_Reset;
000052  f64765ff          MOV      r5,#0x7eff
000056  402c              ANDS     r4,r4,r5
;;;343        tmpcr2 &= CR2_OIS1N_Reset;
000058  f64755ff          MOV      r5,#0x7dff
00005c  402c              ANDS     r4,r4,r5
;;;344        /* Set the Output Idle state */
;;;345        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005e  898d              LDRH     r5,[r1,#0xc]
000060  432c              ORRS     r4,r4,r5
;;;346        /* Set the Output N Idle state */
;;;347        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000062  89cd              LDRH     r5,[r1,#0xe]
000064  432c              ORRS     r4,r4,r5
                  |L46.102|
;;;348      }
;;;349      /* Write to TIMx CR2 */
;;;350      TIMx->CR2 = tmpcr2;
000066  8084              STRH     r4,[r0,#4]
;;;351      
;;;352      /* Write to TIMx CCMR1 */
;;;353      TIMx->CCMR1 = tmpccmrx;
000068  8302              STRH     r2,[r0,#0x18]
;;;354      
;;;355      /* Write to TIMx CCER */
;;;356      TIMx->CCER = tmpccer;
00006a  8403              STRH     r3,[r0,#0x20]
;;;357    }
00006c  bd70              POP      {r4-r6,pc}
;;;358    
                          ENDP

00006e  0000              DCW      0x0000
                  |L46.112|
                          DCD      0x40012c00
                  |L46.116|
                          DCD      0x40013400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1850     */
;;;1851   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  2200              MOVS     r2,#0
;;;1852   {
;;;1853     uint16_t tmpccer = 0;
;;;1854     /* Check the parameters */
;;;1855     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1856     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1857      
;;;1858     tmpccer = TIMx->CCER;
000002  8c02              LDRH     r2,[r0,#0x20]
;;;1859     /* Set or Reset the CC1NP Bit */
;;;1860     tmpccer &= CCER_CC1NP_Reset;
000004  f64f73f7          MOV      r3,#0xfff7
000008  401a              ANDS     r2,r2,r3
;;;1861     tmpccer |= TIM_OCNPolarity;
00000a  430a              ORRS     r2,r2,r1
;;;1862     /* Write to TIMx CCER register */
;;;1863     TIMx->CCER = tmpccer;
00000c  8402              STRH     r2,[r0,#0x20]
;;;1864   }
00000e  4770              BX       lr
;;;1865   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1827     */
;;;1828   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  2200              MOVS     r2,#0
;;;1829   {
;;;1830     uint16_t tmpccer = 0;
;;;1831     /* Check the parameters */
;;;1832     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1833     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1834     tmpccer = TIMx->CCER;
000002  8c02              LDRH     r2,[r0,#0x20]
;;;1835     /* Set or Reset the CC1P Bit */
;;;1836     tmpccer &= CCER_CC1P_Reset;
000004  f64f73fd          MOV      r3,#0xfffd
000008  401a              ANDS     r2,r2,r3
;;;1837     tmpccer |= TIM_OCPolarity;
00000a  430a              ORRS     r2,r2,r1
;;;1838     /* Write to TIMx CCER register */
;;;1839     TIMx->CCER = tmpccer;
00000c  8402              STRH     r2,[r0,#0x20]
;;;1840   }
00000e  4770              BX       lr
;;;1841   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1520     */
;;;1521   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  2200              MOVS     r2,#0
;;;1522   {
;;;1523     uint16_t tmpccmr1 = 0;
;;;1524     /* Check the parameters */
;;;1525     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1526     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1527     tmpccmr1 = TIMx->CCMR1;
000002  8b02              LDRH     r2,[r0,#0x18]
;;;1528     /* Reset the OC1PE Bit */
;;;1529     tmpccmr1 &= CCMR_OC13PE_Reset;
000004  f64f73f7          MOV      r3,#0xfff7
000008  401a              ANDS     r2,r2,r3
;;;1530     /* Enable or Disable the Output Compare Preload feature */
;;;1531     tmpccmr1 |= TIM_OCPreload;
00000a  430a              ORRS     r2,r2,r1
;;;1532     /* Write to TIMx CCMR1 register */
;;;1533     TIMx->CCMR1 = tmpccmr1;
00000c  8302              STRH     r2,[r0,#0x18]
;;;1534   }
00000e  4770              BX       lr
;;;1535   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1649     */
;;;1650   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  2200              MOVS     r2,#0
;;;1651   {
;;;1652     uint16_t tmpccmr1 = 0;
;;;1653     /* Check the parameters */
;;;1654     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1655     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1656     /* Get the TIMx CCMR1 register value */
;;;1657     tmpccmr1 = TIMx->CCMR1;
000002  8b02              LDRH     r2,[r0,#0x18]
;;;1658     /* Reset the OC2FE Bit */
;;;1659     tmpccmr1 &= CCMR_OC24FE_Reset;
000004  f64f33ff          MOV      r3,#0xfbff
000008  401a              ANDS     r2,r2,r3
;;;1660     /* Enable or Disable the Output Compare Fast Bit */
;;;1661     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00000a  060b              LSLS     r3,r1,#24
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1662     /* Write to TIMx CCMR1 */
;;;1663     TIMx->CCMR1 = tmpccmr1;
000010  8302              STRH     r2,[r0,#0x18]
;;;1664   }
000012  4770              BX       lr
;;;1665   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;368      */
;;;369    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;370    {
;;;371      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;372       
;;;373      /* Check the parameters */
;;;374      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;375      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;376      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;377      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;378      /* Disable the Channel 2: Reset the CC2E Bit */
;;;379      TIMx->CCER &= CCER_CC2E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;380      
;;;381      /* Get the TIMx CCER register value */  
;;;382      tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;383      /* Get the TIMx CR2 register value */
;;;384      tmpcr2 =  TIMx->CR2;
000014  8884              LDRH     r4,[r0,#4]
;;;385      
;;;386      /* Get the TIMx CCMR1 register value */
;;;387      tmpccmrx = TIMx->CCMR1;
000016  8b02              LDRH     r2,[r0,#0x18]
;;;388        
;;;389      /* Reset the Output Compare Mode Bits */
;;;390      tmpccmrx &= CCMR_OC24M_Mask;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402a              ANDS     r2,r2,r5
;;;391      
;;;392      /* Select the Output Compare Mode */
;;;393      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  062d              LSLS     r5,r5,#24
000022  ea424215          ORR      r2,r2,r5,LSR #16
;;;394      
;;;395      /* Reset the Output Polarity level */
;;;396      tmpccer &= CCER_CC2P_Reset;
000026  f64f75df          MOV      r5,#0xffdf
00002a  402b              ANDS     r3,r3,r5
;;;397      /* Set the Output Compare Polarity */
;;;398      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
00002c  890d              LDRH     r5,[r1,#8]
00002e  052d              LSLS     r5,r5,#20
000030  ea434315          ORR      r3,r3,r5,LSR #16
;;;399      
;;;400      /* Set the Output State */
;;;401      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000034  884d              LDRH     r5,[r1,#2]
000036  052d              LSLS     r5,r5,#20
000038  ea434315          ORR      r3,r3,r5,LSR #16
;;;402      
;;;403      /* Set the Capture Compare Register value */
;;;404      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
00003c  88cd              LDRH     r5,[r1,#6]
00003e  8705              STRH     r5,[r0,#0x38]
;;;405      
;;;406      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
000040  4d12              LDR      r5,|L51.140|
000042  42a8              CMP      r0,r5
000044  d002              BEQ      |L51.76|
000046  4d12              LDR      r5,|L51.144|
000048  42a8              CMP      r0,r5
00004a  d11b              BNE      |L51.132|
                  |L51.76|
;;;407      {
;;;408        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;409        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;410        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;411        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;412        
;;;413        /* Reset the Output N Polarity level */
;;;414        tmpccer &= CCER_CC2NP_Reset;
00004c  f64f757f          MOV      r5,#0xff7f
000050  402b              ANDS     r3,r3,r5
;;;415        /* Set the Output N Polarity */
;;;416        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000052  894d              LDRH     r5,[r1,#0xa]
000054  052d              LSLS     r5,r5,#20
000056  ea434315          ORR      r3,r3,r5,LSR #16
;;;417        /* Reset the Output N State */
;;;418        tmpccer &= CCER_CC2NE_Reset;
00005a  f64f75bf          MOV      r5,#0xffbf
00005e  402b              ANDS     r3,r3,r5
;;;419        
;;;420        /* Set the Output N State */
;;;421        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000060  888d              LDRH     r5,[r1,#4]
000062  052d              LSLS     r5,r5,#20
000064  ea434315          ORR      r3,r3,r5,LSR #16
;;;422        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;423        tmpcr2 &= CR2_OIS2_Reset;
000068  f64735ff          MOV      r5,#0x7bff
00006c  402c              ANDS     r4,r4,r5
;;;424        tmpcr2 &= CR2_OIS2N_Reset;
00006e  f24775ff          MOV      r5,#0x77ff
000072  402c              ANDS     r4,r4,r5
;;;425        /* Set the Output Idle state */
;;;426        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000074  898d              LDRH     r5,[r1,#0xc]
000076  04ad              LSLS     r5,r5,#18
000078  ea444415          ORR      r4,r4,r5,LSR #16
;;;427        /* Set the Output N Idle state */
;;;428        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
00007c  89cd              LDRH     r5,[r1,#0xe]
00007e  04ad              LSLS     r5,r5,#18
000080  ea444415          ORR      r4,r4,r5,LSR #16
                  |L51.132|
;;;429      }
;;;430      /* Write to TIMx CR2 */
;;;431      TIMx->CR2 = tmpcr2;
000084  8084              STRH     r4,[r0,#4]
;;;432      
;;;433      /* Write to TIMx CCMR1 */
;;;434      TIMx->CCMR1 = tmpccmrx;
000086  8302              STRH     r2,[r0,#0x18]
;;;435      
;;;436      /* Write to TIMx CCER */
;;;437      TIMx->CCER = tmpccer;
000088  8403              STRH     r3,[r0,#0x20]
;;;438    }
00008a  bd70              POP      {r4-r6,pc}
;;;439    
                          ENDP

                  |L51.140|
                          DCD      0x40012c00
                  |L51.144|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1898     */
;;;1899   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  2200              MOVS     r2,#0
;;;1900   {
;;;1901     uint16_t tmpccer = 0;
;;;1902     /* Check the parameters */
;;;1903     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1904     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1905     
;;;1906     tmpccer = TIMx->CCER;
000002  8c02              LDRH     r2,[r0,#0x20]
;;;1907     /* Set or Reset the CC2NP Bit */
;;;1908     tmpccer &= CCER_CC2NP_Reset;
000004  f64f737f          MOV      r3,#0xff7f
000008  401a              ANDS     r2,r2,r3
;;;1909     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
00000a  050b              LSLS     r3,r1,#20
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1910     /* Write to TIMx CCER register */
;;;1911     TIMx->CCER = tmpccer;
000010  8402              STRH     r2,[r0,#0x20]
;;;1912   }
000012  4770              BX       lr
;;;1913   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1875     */
;;;1876   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  2200              MOVS     r2,#0
;;;1877   {
;;;1878     uint16_t tmpccer = 0;
;;;1879     /* Check the parameters */
;;;1880     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1881     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1882     tmpccer = TIMx->CCER;
000002  8c02              LDRH     r2,[r0,#0x20]
;;;1883     /* Set or Reset the CC2P Bit */
;;;1884     tmpccer &= CCER_CC2P_Reset;
000004  f64f73df          MOV      r3,#0xffdf
000008  401a              ANDS     r2,r2,r3
;;;1885     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00000a  050b              LSLS     r3,r1,#20
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1886     /* Write to TIMx CCER register */
;;;1887     TIMx->CCER = tmpccer;
000010  8402              STRH     r2,[r0,#0x20]
;;;1888   }
000012  4770              BX       lr
;;;1889   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1546     */
;;;1547   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  2200              MOVS     r2,#0
;;;1548   {
;;;1549     uint16_t tmpccmr1 = 0;
;;;1550     /* Check the parameters */
;;;1551     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1552     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1553     tmpccmr1 = TIMx->CCMR1;
000002  8b02              LDRH     r2,[r0,#0x18]
;;;1554     /* Reset the OC2PE Bit */
;;;1555     tmpccmr1 &= CCMR_OC24PE_Reset;
000004  f24f73ff          MOV      r3,#0xf7ff
000008  401a              ANDS     r2,r2,r3
;;;1556     /* Enable or Disable the Output Compare Preload feature */
;;;1557     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00000a  060b              LSLS     r3,r1,#24
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1558     /* Write to TIMx CCMR1 register */
;;;1559     TIMx->CCMR1 = tmpccmr1;
000010  8302              STRH     r2,[r0,#0x18]
;;;1560   }
000012  4770              BX       lr
;;;1561   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1675     */
;;;1676   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  2200              MOVS     r2,#0
;;;1677   {
;;;1678     uint16_t tmpccmr2 = 0;
;;;1679     /* Check the parameters */
;;;1680     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1681     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1682     /* Get the TIMx CCMR2 register value */
;;;1683     tmpccmr2 = TIMx->CCMR2;
000002  8b82              LDRH     r2,[r0,#0x1c]
;;;1684     /* Reset the OC3FE Bit */
;;;1685     tmpccmr2 &= CCMR_OC13FE_Reset;
000004  f64f73fb          MOV      r3,#0xfffb
000008  401a              ANDS     r2,r2,r3
;;;1686     /* Enable or Disable the Output Compare Fast Bit */
;;;1687     tmpccmr2 |= TIM_OCFast;
00000a  430a              ORRS     r2,r2,r1
;;;1688     /* Write to TIMx CCMR2 */
;;;1689     TIMx->CCMR2 = tmpccmr2;
00000c  8382              STRH     r2,[r0,#0x1c]
;;;1690   }
00000e  4770              BX       lr
;;;1691   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;449      */
;;;450    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;451    {
;;;452      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;453       
;;;454      /* Check the parameters */
;;;455      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;456      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;457      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;458      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;459      /* Disable the Channel 2: Reset the CC2E Bit */
;;;460      TIMx->CCER &= CCER_CC3E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;461      
;;;462      /* Get the TIMx CCER register value */
;;;463      tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;464      /* Get the TIMx CR2 register value */
;;;465      tmpcr2 =  TIMx->CR2;
000014  8884              LDRH     r4,[r0,#4]
;;;466      
;;;467      /* Get the TIMx CCMR2 register value */
;;;468      tmpccmrx = TIMx->CCMR2;
000016  8b82              LDRH     r2,[r0,#0x1c]
;;;469        
;;;470      /* Reset the Output Compare Mode Bits */
;;;471      tmpccmrx &= CCMR_OC13M_Mask;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402a              ANDS     r2,r2,r5
;;;472      
;;;473      /* Select the Output Compare Mode */
;;;474      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432a              ORRS     r2,r2,r5
;;;475      
;;;476      /* Reset the Output Polarity level */
;;;477      tmpccer &= CCER_CC3P_Reset;
000022  f64f55ff          MOV      r5,#0xfdff
000026  402b              ANDS     r3,r3,r5
;;;478      /* Set the Output Compare Polarity */
;;;479      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000028  890d              LDRH     r5,[r1,#8]
00002a  062d              LSLS     r5,r5,#24
00002c  ea434315          ORR      r3,r3,r5,LSR #16
;;;480      
;;;481      /* Set the Output State */
;;;482      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000030  884d              LDRH     r5,[r1,#2]
000032  062d              LSLS     r5,r5,#24
000034  ea434315          ORR      r3,r3,r5,LSR #16
;;;483      
;;;484      /* Set the Capture Compare Register value */
;;;485      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000038  88cd              LDRH     r5,[r1,#6]
00003a  8785              STRH     r5,[r0,#0x3c]
;;;486      
;;;487      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
00003c  4d12              LDR      r5,|L56.136|
00003e  42a8              CMP      r0,r5
000040  d002              BEQ      |L56.72|
000042  4d12              LDR      r5,|L56.140|
000044  42a8              CMP      r0,r5
000046  d11b              BNE      |L56.128|
                  |L56.72|
;;;488      {
;;;489        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;490        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;491        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;492        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;493        
;;;494        /* Reset the Output N Polarity level */
;;;495        tmpccer &= CCER_CC3NP_Reset;
000048  f24f75ff          MOV      r5,#0xf7ff
00004c  402b              ANDS     r3,r3,r5
;;;496        /* Set the Output N Polarity */
;;;497        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00004e  894d              LDRH     r5,[r1,#0xa]
000050  062d              LSLS     r5,r5,#24
000052  ea434315          ORR      r3,r3,r5,LSR #16
;;;498        /* Reset the Output N State */
;;;499        tmpccer &= CCER_CC3NE_Reset;
000056  f64f35ff          MOV      r5,#0xfbff
00005a  402b              ANDS     r3,r3,r5
;;;500        
;;;501        /* Set the Output N State */
;;;502        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
00005c  888d              LDRH     r5,[r1,#4]
00005e  062d              LSLS     r5,r5,#24
000060  ea434315          ORR      r3,r3,r5,LSR #16
;;;503        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;504        tmpcr2 &= CR2_OIS3_Reset;
000064  f64675ff          MOV      r5,#0x6fff
000068  402c              ANDS     r4,r4,r5
;;;505        tmpcr2 &= CR2_OIS3N_Reset;
00006a  f64575ff          MOV      r5,#0x5fff
00006e  402c              ANDS     r4,r4,r5
;;;506        /* Set the Output Idle state */
;;;507        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000070  898d              LDRH     r5,[r1,#0xc]
000072  052d              LSLS     r5,r5,#20
000074  ea444415          ORR      r4,r4,r5,LSR #16
;;;508        /* Set the Output N Idle state */
;;;509        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000078  89cd              LDRH     r5,[r1,#0xe]
00007a  052d              LSLS     r5,r5,#20
00007c  ea444415          ORR      r4,r4,r5,LSR #16
                  |L56.128|
;;;510      }
;;;511      /* Write to TIMx CR2 */
;;;512      TIMx->CR2 = tmpcr2;
000080  8084              STRH     r4,[r0,#4]
;;;513      
;;;514      /* Write to TIMx CCMR2 */
;;;515      TIMx->CCMR2 = tmpccmrx;
000082  8382              STRH     r2,[r0,#0x1c]
;;;516      
;;;517      /* Write to TIMx CCER */
;;;518      TIMx->CCER = tmpccer;
000084  8403              STRH     r3,[r0,#0x20]
;;;519    }
000086  bd70              POP      {r4-r6,pc}
;;;520    
                          ENDP

                  |L56.136|
                          DCD      0x40012c00
                  |L56.140|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1946     */
;;;1947   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  2200              MOVS     r2,#0
;;;1948   {
;;;1949     uint16_t tmpccer = 0;
;;;1950    
;;;1951     /* Check the parameters */
;;;1952     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1953     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1954       
;;;1955     tmpccer = TIMx->CCER;
000002  8c02              LDRH     r2,[r0,#0x20]
;;;1956     /* Set or Reset the CC3NP Bit */
;;;1957     tmpccer &= CCER_CC3NP_Reset;
000004  f24f73ff          MOV      r3,#0xf7ff
000008  401a              ANDS     r2,r2,r3
;;;1958     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00000a  060b              LSLS     r3,r1,#24
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1959     /* Write to TIMx CCER register */
;;;1960     TIMx->CCER = tmpccer;
000010  8402              STRH     r2,[r0,#0x20]
;;;1961   }
000012  4770              BX       lr
;;;1962   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1923     */
;;;1924   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  2200              MOVS     r2,#0
;;;1925   {
;;;1926     uint16_t tmpccer = 0;
;;;1927     /* Check the parameters */
;;;1928     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1929     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1930     tmpccer = TIMx->CCER;
000002  8c02              LDRH     r2,[r0,#0x20]
;;;1931     /* Set or Reset the CC3P Bit */
;;;1932     tmpccer &= CCER_CC3P_Reset;
000004  f64f53ff          MOV      r3,#0xfdff
000008  401a              ANDS     r2,r2,r3
;;;1933     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00000a  060b              LSLS     r3,r1,#24
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1934     /* Write to TIMx CCER register */
;;;1935     TIMx->CCER = tmpccer;
000010  8402              STRH     r2,[r0,#0x20]
;;;1936   }
000012  4770              BX       lr
;;;1937   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1572     */
;;;1573   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  2200              MOVS     r2,#0
;;;1574   {
;;;1575     uint16_t tmpccmr2 = 0;
;;;1576     /* Check the parameters */
;;;1577     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1578     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1579     tmpccmr2 = TIMx->CCMR2;
000002  8b82              LDRH     r2,[r0,#0x1c]
;;;1580     /* Reset the OC3PE Bit */
;;;1581     tmpccmr2 &= CCMR_OC13PE_Reset;
000004  f64f73f7          MOV      r3,#0xfff7
000008  401a              ANDS     r2,r2,r3
;;;1582     /* Enable or Disable the Output Compare Preload feature */
;;;1583     tmpccmr2 |= TIM_OCPreload;
00000a  430a              ORRS     r2,r2,r1
;;;1584     /* Write to TIMx CCMR2 register */
;;;1585     TIMx->CCMR2 = tmpccmr2;
00000c  8382              STRH     r2,[r0,#0x1c]
;;;1586   }
00000e  4770              BX       lr
;;;1587   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1701     */
;;;1702   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  2200              MOVS     r2,#0
;;;1703   {
;;;1704     uint16_t tmpccmr2 = 0;
;;;1705     /* Check the parameters */
;;;1706     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1707     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1708     /* Get the TIMx CCMR2 register value */
;;;1709     tmpccmr2 = TIMx->CCMR2;
000002  8b82              LDRH     r2,[r0,#0x1c]
;;;1710     /* Reset the OC4FE Bit */
;;;1711     tmpccmr2 &= CCMR_OC24FE_Reset;
000004  f64f33ff          MOV      r3,#0xfbff
000008  401a              ANDS     r2,r2,r3
;;;1712     /* Enable or Disable the Output Compare Fast Bit */
;;;1713     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00000a  060b              LSLS     r3,r1,#24
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1714     /* Write to TIMx CCMR2 */
;;;1715     TIMx->CCMR2 = tmpccmr2;
000010  8382              STRH     r2,[r0,#0x1c]
;;;1716   }
000012  4770              BX       lr
;;;1717   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;530      */
;;;531    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;532    {
;;;533      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;534       
;;;535      /* Check the parameters */
;;;536      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;537      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;538      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;539      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;540      /* Disable the Channel 2: Reset the CC4E Bit */
;;;541      TIMx->CCER &= CCER_CC4E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;542      
;;;543      /* Get the TIMx CCER register value */
;;;544      tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;545      /* Get the TIMx CR2 register value */
;;;546      tmpcr2 =  TIMx->CR2;
000014  8884              LDRH     r4,[r0,#4]
;;;547      
;;;548      /* Get the TIMx CCMR2 register value */
;;;549      tmpccmrx = TIMx->CCMR2;
000016  8b82              LDRH     r2,[r0,#0x1c]
;;;550        
;;;551      /* Reset the Output Compare Mode Bits */
;;;552      tmpccmrx &= CCMR_OC24M_Mask;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402a              ANDS     r2,r2,r5
;;;553      
;;;554      /* Select the Output Compare Mode */
;;;555      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  062d              LSLS     r5,r5,#24
000022  ea424215          ORR      r2,r2,r5,LSR #16
;;;556      
;;;557      /* Reset the Output Polarity level */
;;;558      tmpccer &= CCER_CC4P_Reset;
000026  f64d75ff          MOV      r5,#0xdfff
00002a  402b              ANDS     r3,r3,r5
;;;559      /* Set the Output Compare Polarity */
;;;560      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
00002c  890d              LDRH     r5,[r1,#8]
00002e  072d              LSLS     r5,r5,#28
000030  ea434315          ORR      r3,r3,r5,LSR #16
;;;561      
;;;562      /* Set the Output State */
;;;563      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000034  884d              LDRH     r5,[r1,#2]
000036  072d              LSLS     r5,r5,#28
000038  ea434315          ORR      r3,r3,r5,LSR #16
;;;564      
;;;565      /* Set the Capture Compare Register value */
;;;566      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
00003c  88cd              LDRH     r5,[r1,#6]
00003e  f8a05040          STRH     r5,[r0,#0x40]
;;;567      
;;;568      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
000042  4d08              LDR      r5,|L61.100|
000044  42a8              CMP      r0,r5
000046  d002              BEQ      |L61.78|
000048  4d07              LDR      r5,|L61.104|
00004a  42a8              CMP      r0,r5
00004c  d105              BNE      |L61.90|
                  |L61.78|
;;;569      {
;;;570        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;571        /* Reset the Ouput Compare IDLE State */
;;;572        tmpcr2 &= CR2_OIS4_Reset;
00004e  f3c4040d          UBFX     r4,r4,#0,#14
;;;573        /* Set the Output Idle state */
;;;574        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000052  898d              LDRH     r5,[r1,#0xc]
000054  05ad              LSLS     r5,r5,#22
000056  ea444415          ORR      r4,r4,r5,LSR #16
                  |L61.90|
;;;575      }
;;;576      /* Write to TIMx CR2 */
;;;577      TIMx->CR2 = tmpcr2;
00005a  8084              STRH     r4,[r0,#4]
;;;578      
;;;579      /* Write to TIMx CCMR2 */  
;;;580      TIMx->CCMR2 = tmpccmrx;
00005c  8382              STRH     r2,[r0,#0x1c]
;;;581      
;;;582      /* Write to TIMx CCER */
;;;583      TIMx->CCER = tmpccer;
00005e  8403              STRH     r3,[r0,#0x20]
;;;584    }
000060  bd70              POP      {r4-r6,pc}
;;;585    
                          ENDP

000062  0000              DCW      0x0000
                  |L61.100|
                          DCD      0x40012c00
                  |L61.104|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1972     */
;;;1973   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  2200              MOVS     r2,#0
;;;1974   {
;;;1975     uint16_t tmpccer = 0;
;;;1976     /* Check the parameters */
;;;1977     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1978     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1979     tmpccer = TIMx->CCER;
000002  8c02              LDRH     r2,[r0,#0x20]
;;;1980     /* Set or Reset the CC4P Bit */
;;;1981     tmpccer &= CCER_CC4P_Reset;
000004  f64d73ff          MOV      r3,#0xdfff
000008  401a              ANDS     r2,r2,r3
;;;1982     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00000a  070b              LSLS     r3,r1,#28
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1983     /* Write to TIMx CCER register */
;;;1984     TIMx->CCER = tmpccer;
000010  8402              STRH     r2,[r0,#0x20]
;;;1985   }
000012  4770              BX       lr
;;;1986   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1598     */
;;;1599   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  2200              MOVS     r2,#0
;;;1600   {
;;;1601     uint16_t tmpccmr2 = 0;
;;;1602     /* Check the parameters */
;;;1603     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1604     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1605     tmpccmr2 = TIMx->CCMR2;
000002  8b82              LDRH     r2,[r0,#0x1c]
;;;1606     /* Reset the OC4PE Bit */
;;;1607     tmpccmr2 &= CCMR_OC24PE_Reset;
000004  f24f73ff          MOV      r3,#0xf7ff
000008  401a              ANDS     r2,r2,r3
;;;1608     /* Enable or Disable the Output Compare Preload feature */
;;;1609     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00000a  060b              LSLS     r3,r1,#24
00000c  ea424213          ORR      r2,r2,r3,LSR #16
;;;1610     /* Write to TIMx CCMR2 register */
;;;1611     TIMx->CCMR2 = tmpccmr2;
000010  8382              STRH     r2,[r0,#0x1c]
;;;1612   }
000012  4770              BX       lr
;;;1613   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;753      */
;;;754    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;755    {
;;;756      /* Set the default configuration */
;;;757      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;758      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;759      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;760      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;761      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;762      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;763      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;764      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;765    }
000012  4770              BX       lr
;;;766    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;654      */
;;;655    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;656    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;657      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;658      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;659      /* Check the parameters */
;;;660      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;661      /* Select the Opposite Input Polarity */
;;;662      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8868              LDRH     r0,[r5,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;663      {
;;;664        icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;665      }
;;;666      else
;;;667      {
;;;668        icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;669      }
;;;670      /* Select the Opposite Input */
;;;671      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a8              LDRH     r0,[r5,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;672      {
;;;673        icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;674      }
;;;675      else
;;;676      {
;;;677        icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;678      }
;;;679      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8828              LDRH     r0,[r5,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;680      {
;;;681        /* TI1 Configuration */
;;;682        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  892b              LDRH     r3,[r5,#8]
000028  88aa              LDRH     r2,[r5,#4]
00002a  8869              LDRH     r1,[r5,#2]
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TI1_Config
;;;683                   TIM_ICInitStruct->TIM_ICFilter);
;;;684        /* Set the Input Capture Prescaler value */
;;;685        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e9              LDRH     r1,[r5,#6]
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;686        /* TI2 Configuration */
;;;687        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  892b              LDRH     r3,[r5,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       TI2_Config
;;;688        /* Set the Input Capture Prescaler value */
;;;689        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e9              LDRH     r1,[r5,#6]
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;690      }
;;;691      else
;;;692      { 
;;;693        /* TI2 Configuration */
;;;694        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  892b              LDRH     r3,[r5,#8]
000052  88aa              LDRH     r2,[r5,#4]
000054  8869              LDRH     r1,[r5,#2]
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       TI2_Config
;;;695                   TIM_ICInitStruct->TIM_ICFilter);
;;;696        /* Set the Input Capture Prescaler value */
;;;697        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e9              LDRH     r1,[r5,#6]
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;698        /* TI1 Configuration */
;;;699        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  892b              LDRH     r3,[r5,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       TI1_Config
;;;700        /* Set the Input Capture Prescaler value */
;;;701        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e9              LDRH     r1,[r5,#6]
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;702      }
;;;703    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;704    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1174     */
;;;1175   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1176   {
;;;1177     /* Check the parameters */
;;;1178     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1179     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1180     /* Set the Prescaler value */
;;;1181     TIMx->PSC = Prescaler;
;;;1182     /* Set or reset the UG Bit */
;;;1183     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1184   }
000004  4770              BX       lr
;;;1185   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1467     */
;;;1468   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L67.12|
;;;1469   {
;;;1470     /* Check the parameters */
;;;1471     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1472     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1473     if (NewState != DISABLE)
;;;1474     {
;;;1475       /* Set the CCDS Bit */
;;;1476       TIMx->CR2 |= CR2_CCDS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L67.22|
                  |L67.12|
;;;1477     }
;;;1478     else
;;;1479     {
;;;1480       /* Reset the CCDS Bit */
;;;1481       TIMx->CR2 &= CR2_CCDS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L67.22|
;;;1482     }
;;;1483   }
000016  4770              BX       lr
;;;1484   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1442     */
;;;1443   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;1444   {
;;;1445     /* Check the parameters */
;;;1446     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1447     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1448     if (NewState != DISABLE)
;;;1449     {
;;;1450       /* Set the COM Bit */
;;;1451       TIMx->CR2 |= CR2_CCUS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;1452     }
;;;1453     else
;;;1454     {
;;;1455       /* Reset the COM Bit */
;;;1456       TIMx->CR2 &= CR2_CCUS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;1457     }
;;;1458   }
000016  4770              BX       lr
;;;1459   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2144     */
;;;2145   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;2146   {
;;;2147     /* Check the parameters */
;;;2148     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2149     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2150     if (NewState != DISABLE)
;;;2151     {
;;;2152       /* Set the TI1S Bit */
;;;2153       TIMx->CR2 |= CR2_TI1S_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;2154     }
;;;2155     else
;;;2156     {
;;;2157       /* Reset the TI1S Bit */
;;;2158       TIMx->CR2 &= CR2_TI1S_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;2159     }
;;;2160   }
000016  4770              BX       lr
;;;2161   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1229     */
;;;1230   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  2200              MOVS     r2,#0
;;;1231   {
;;;1232     uint16_t tmpsmcr = 0;
;;;1233     /* Check the parameters */
;;;1234     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1235     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1236     /* Get the TIMx SMCR register value */
;;;1237     tmpsmcr = TIMx->SMCR;
000002  8902              LDRH     r2,[r0,#8]
;;;1238     /* Reset the TS Bits */
;;;1239     tmpsmcr &= SMCR_TS_Mask;
000004  f64f738f          MOV      r3,#0xff8f
000008  401a              ANDS     r2,r2,r3
;;;1240     /* Set the Input Trigger source */
;;;1241     tmpsmcr |= TIM_InputTriggerSource;
00000a  430a              ORRS     r2,r2,r1
;;;1242     /* Write to TIMx SMCR */
;;;1243     TIMx->SMCR = tmpsmcr;
00000c  8102              STRH     r2,[r0,#8]
;;;1244   }
00000e  4770              BX       lr
;;;1245   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2245     */
;;;2246   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2247   {
;;;2248     /* Check the parameters */
;;;2249     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2250     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2251     /* Reset the MSM Bit */
;;;2252     TIMx->SMCR &= SMCR_MSM_Reset;
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2253     
;;;2254     /* Set or Reset the MSM Bit */
;;;2255     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2256   }
000010  4770              BX       lr
;;;2257   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2060     */
;;;2061   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;2062   {
;;;2063     /* Check the parameters */
;;;2064     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2065     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2066     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2067     
;;;2068     /* Disable the Channel: Reset the CCxE Bit */
;;;2069     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43e4              MVNS     r4,r4
00000a  b2a4              UXTH     r4,r4
00000c  4023              ANDS     r3,r3,r4
00000e  8403              STRH     r3,[r0,#0x20]
;;;2070     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000010  b109              CBZ      r1,|L72.22|
000012  2908              CMP      r1,#8
000014  d118              BNE      |L72.72|
                  |L72.22|
;;;2071     {
;;;2072       /* Reset the OCxM bits in the CCMRx register */
;;;2073       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
000016  f1000318          ADD      r3,r0,#0x18
00001a  eb030361          ADD      r3,r3,r1,ASR #1
00001e  681c              LDR      r4,[r3,#0]
000020  f64f738f          MOV      r3,#0xff8f
000024  401c              ANDS     r4,r4,r3
000026  f1000318          ADD      r3,r0,#0x18
00002a  eb030361          ADD      r3,r3,r1,ASR #1
00002e  601c              STR      r4,[r3,#0]
;;;2074      
;;;2075       /* Configure the OCxM bits in the CCMRx register */
;;;2076       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) |= TIM_OCMode;
000030  f1000318          ADD      r3,r0,#0x18
000034  eb030361          ADD      r3,r3,r1,ASR #1
000038  681c              LDR      r4,[r3,#0]
00003a  4314              ORRS     r4,r4,r2
00003c  f1000318          ADD      r3,r0,#0x18
000040  eb030361          ADD      r3,r3,r1,ASR #1
000044  601c              STR      r4,[r3,#0]
000046  e021              B        |L72.140|
                  |L72.72|
;;;2077     }
;;;2078     else
;;;2079     {
;;;2080       /* Reset the OCxM bits in the CCMRx register */
;;;2081       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + ((uint16_t)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
000048  1f0b              SUBS     r3,r1,#4
00004a  b29c              UXTH     r4,r3
00004c  f1000318          ADD      r3,r0,#0x18
000050  eb030364          ADD      r3,r3,r4,ASR #1
000054  681c              LDR      r4,[r3,#0]
000056  f64873ff          MOV      r3,#0x8fff
00005a  401c              ANDS     r4,r4,r3
00005c  1f0b              SUBS     r3,r1,#4
00005e  b29d              UXTH     r5,r3
000060  f1000318          ADD      r3,r0,#0x18
000064  eb030365          ADD      r3,r3,r5,ASR #1
000068  601c              STR      r4,[r3,#0]
;;;2082       
;;;2083       /* Configure the OCxM bits in the CCMRx register */
;;;2084       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + ((uint16_t)(TIM_Channel - 4)>> 1))) |= (uint16_t)(TIM_OCMode << 8);
00006a  1f0b              SUBS     r3,r1,#4
00006c  b29c              UXTH     r4,r3
00006e  f1000318          ADD      r3,r0,#0x18
000072  eb030364          ADD      r3,r3,r4,ASR #1
000076  681b              LDR      r3,[r3,#0]
000078  0614              LSLS     r4,r2,#24
00007a  ea434314          ORR      r3,r3,r4,LSR #16
00007e  1f0c              SUBS     r4,r1,#4
000080  b2a5              UXTH     r5,r4
000082  f1000418          ADD      r4,r0,#0x18
000086  eb040465          ADD      r4,r4,r5,ASR #1
00008a  6023              STR      r3,[r4,#0]
                  |L72.140|
;;;2085     }
;;;2086   }
00008c  bd30              POP      {r4,r5,pc}
;;;2087   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2170     */
;;;2171   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2172   {
;;;2173     /* Check the parameters */
;;;2174     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2175     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2176     /* Reset the OPM Bit */
;;;2177     TIMx->CR1 &= CR1_OPM_Reset;
000002  f24033f7          MOV      r3,#0x3f7
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;2178     /* Configure the OPM Mode */
;;;2179     TIMx->CR1 |= TIM_OPMode;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;2180   }
000010  4770              BX       lr
;;;2181   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2199     */
;;;2200   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2201   {
;;;2202     /* Check the parameters */
;;;2203     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2204     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2205     assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
;;;2206     /* Reset the MMS Bits */
;;;2207     TIMx->CR2 &= CR2_MMS_Mask;
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  8082              STRH     r2,[r0,#4]
;;;2208     /* Select the TRGO source */
;;;2209     TIMx->CR2 |=  TIM_TRGOSource;
00000a  8882              LDRH     r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  8082              STRH     r2,[r0,#4]
;;;2210   }
000010  4770              BX       lr
;;;2211   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2223     */
;;;2224   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2225   {
;;;2226     /* Check the parameters */
;;;2227     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2228     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2229     /* Reset the SMS Bits */
;;;2230     TIMx->SMCR &= SMCR_SMS_Mask;
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2231     /* Select the Slave Mode */
;;;2232     TIMx->SMCR |= TIM_SlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2233   }
000010  4770              BX       lr
;;;2234   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2277     */
;;;2278   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2279   {
;;;2280     /* Check the parameters */
;;;2281     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2282     /* Set the Autoreload Register value */
;;;2283     TIMx->ARR = Autoreload;
;;;2284   }
000002  4770              BX       lr
;;;2285   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2452     */
;;;2453   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2454   {
;;;2455     /* Check the parameters */
;;;2456     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2457     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2458     /* Reset the CKD Bits */
;;;2459     TIMx->CR1 &= CR1_CKD_Mask;
000002  b2d2              UXTB     r2,r2
000004  8002              STRH     r2,[r0,#0]
;;;2460     /* Set the CKD value */
;;;2461     TIMx->CR1 |= TIM_CKD;
000006  8802              LDRH     r2,[r0,#0]
000008  430a              ORRS     r2,r2,r1
00000a  8002              STRH     r2,[r0,#0]
;;;2462   }
00000c  4770              BX       lr
;;;2463   
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2292     */
;;;2293   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2294   {
;;;2295     /* Check the parameters */
;;;2296     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2297     /* Set the Capture Compare1 Register value */
;;;2298     TIMx->CCR1 = Compare1;
;;;2299   }
000002  4770              BX       lr
;;;2300   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2307     */
;;;2308   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2309   {
;;;2310     /* Check the parameters */
;;;2311     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2312     /* Set the Capture Compare2 Register value */
;;;2313     TIMx->CCR2 = Compare2;
;;;2314   }
000002  4770              BX       lr
;;;2315   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2322     */
;;;2323   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2324   {
;;;2325     /* Check the parameters */
;;;2326     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2327     /* Set the Capture Compare3 Register value */
;;;2328     TIMx->CCR3 = Compare3;
;;;2329   }
000002  4770              BX       lr
;;;2330   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2337     */
;;;2338   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2339   {
;;;2340     /* Check the parameters */
;;;2341     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2342     /* Set the Capture Compare4 Register value */
;;;2343     TIMx->CCR4 = Compare4;
;;;2344   }
000004  4770              BX       lr
;;;2345   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2263     */
;;;2264   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2265   {
;;;2266     /* Check the parameters */
;;;2267     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2268     /* Set the Counter Register value */
;;;2269     TIMx->CNT = Counter;
;;;2270   }
000002  4770              BX       lr
;;;2271   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2358     */
;;;2359   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2360   {
;;;2361     /* Check the parameters */
;;;2362     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2363     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2364     /* Reset the IC1PSC Bits */
;;;2365     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2366     /* Set the IC1PSC value */
;;;2367     TIMx->CCMR1 |= TIM_ICPSC;
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  8302              STRH     r2,[r0,#0x18]
;;;2368   }
000010  4770              BX       lr
;;;2369   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2382     */
;;;2383   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2384   {
;;;2385     /* Check the parameters */
;;;2386     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2387     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2388     /* Reset the IC2PSC Bits */
;;;2389     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2390     /* Set the IC2PSC value */
;;;2391     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  060b              LSLS     r3,r1,#24
00000e  ea424213          ORR      r2,r2,r3,LSR #16
000012  8302              STRH     r2,[r0,#0x18]
;;;2392   }
000014  4770              BX       lr
;;;2393   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2406     */
;;;2407   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2408   {
;;;2409     /* Check the parameters */
;;;2410     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2411     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2412     /* Reset the IC3PSC Bits */
;;;2413     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2414     /* Set the IC3PSC value */
;;;2415     TIMx->CCMR2 |= TIM_ICPSC;
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2416   }
000010  4770              BX       lr
;;;2417   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2430     */
;;;2431   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2432   {  
;;;2433     /* Check the parameters */
;;;2434     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2435     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2436     /* Reset the IC4PSC Bits */
;;;2437     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2438     /* Set the IC4PSC value */
;;;2439     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  060b              LSLS     r3,r1,#24
00000e  ea424213          ORR      r2,r2,r3,LSR #16
000012  8382              STRH     r2,[r0,#0x1c]
;;;2440   }
000014  4770              BX       lr
;;;2441   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1028     */
;;;1029   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1030                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1031   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1032     /* Check the parameters */
;;;1033     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1034     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1035     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1036     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1037     /* Configure the Timer Input Clock Source */
;;;1038     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L87.30|
;;;1039     {
;;;1040       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L87.42|
                  |L87.30|
;;;1041     }
;;;1042     else
;;;1043     {
;;;1044       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L87.42|
;;;1045     }
;;;1046     /* Select the Trigger source */
;;;1047     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;1048     /* Select the External clock mode1 */
;;;1049     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  8920              LDRH     r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  8120              STRH     r0,[r4,#8]
;;;1050   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1051   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;250      */
;;;251    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  8802              LDRH     r2,[r0,#0]
;;;252    {
;;;253      /* Check the parameters */
;;;254      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;255      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;256      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;257      /* Select the Counter Mode and set the clock division */
;;;258      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
000002  f002028f          AND      r2,r2,#0x8f
000006  8002              STRH     r2,[r0,#0]
;;;259      TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
000008  88ca              LDRH     r2,[r1,#6]
00000a  884b              LDRH     r3,[r1,#2]
00000c  431a              ORRS     r2,r2,r3
00000e  8803              LDRH     r3,[r0,#0]
000010  431a              ORRS     r2,r2,r3
000012  8002              STRH     r2,[r0,#0]
;;;260                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;261      
;;;262      /* Set the Autoreload value */
;;;263      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000014  888a              LDRH     r2,[r1,#4]
000016  8582              STRH     r2,[r0,#0x2c]
;;;264     
;;;265      /* Set the Prescaler value */
;;;266      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000018  880a              LDRH     r2,[r1,#0]
00001a  8502              STRH     r2,[r0,#0x28]
;;;267        
;;;268      if (((*(uint32_t*)&TIMx) == TIM1_BASE) || ((*(uint32_t*)&TIMx) == TIM8_BASE))  
00001c  4a05              LDR      r2,|L88.52|
00001e  4290              CMP      r0,r2
000020  d002              BEQ      |L88.40|
000022  4a05              LDR      r2,|L88.56|
000024  4290              CMP      r0,r2
000026  d101              BNE      |L88.44|
                  |L88.40|
;;;269      {
;;;270        /* Set the Repetition Counter value */
;;;271        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000028  7a0a              LDRB     r2,[r1,#8]
00002a  8602              STRH     r2,[r0,#0x30]
                  |L88.44|
;;;272      }
;;;273    
;;;274      /* Generate an update event to reload the Prescaler value immediatly */
;;;275      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
00002c  2201              MOVS     r2,#1
00002e  8282              STRH     r2,[r0,#0x14]
;;;276    }
000030  4770              BX       lr
;;;277    
                          ENDP

000032  0000              DCW      0x0000
                  |L88.52|
                          DCD      0x40012c00
                  |L88.56|
                          DCD      0x40013400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;737      */
;;;738    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;739    {
;;;740      /* Set the default configuration */
;;;741      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;742      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;743      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;744      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;745      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;746    }
000010  4770              BX       lr
;;;747    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2094     */
;;;2095   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L90.12|
;;;2096   {
;;;2097     /* Check the parameters */
;;;2098     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2099     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2100     if (NewState != DISABLE)
;;;2101     {
;;;2102       /* Set the Update Disable Bit */
;;;2103       TIMx->CR1 |= CR1_UDIS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L90.22|
                  |L90.12|
;;;2104     }
;;;2105     else
;;;2106     {
;;;2107       /* Reset the Update Disable Bit */
;;;2108       TIMx->CR1 &= CR1_UDIS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fd          MOV      r3,#0x3fd
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L90.22|
;;;2109     }
;;;2110   }
000016  4770              BX       lr
;;;2111   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2120     */
;;;2121   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  b121              CBZ      r1,|L91.12|
;;;2122   {
;;;2123     /* Check the parameters */
;;;2124     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2125     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2126     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2127     {
;;;2128       /* Set the URS Bit */
;;;2129       TIMx->CR1 |= CR1_URS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;2130     }
;;;2131     else
;;;2132     {
;;;2133       /* Reset the URS Bit */
;;;2134       TIMx->CR1 &= CR1_URS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fb          MOV      r3,#0x3fb
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L91.22|
;;;2135     }
;;;2136   }
000016  4770              BX       lr
;;;2137   
                          ENDP


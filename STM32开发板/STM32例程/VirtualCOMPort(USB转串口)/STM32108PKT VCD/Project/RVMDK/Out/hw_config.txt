; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Out\hw_config.o --depend=.\Out\hw_config.d --device=DARMSTM --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Core\CM3 -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I"D:\Program Files\KeilARM350\ARM\INC\ST\STM32F10x" ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;112    *******************************************************************************/
;;;113    void Enter_LowPowerMode(void)
000000  2003              MOVS     r0,#3
;;;114    {
;;;115      /* Set the device state to suspend */
;;;116      bDeviceState = SUSPENDED;
000002  4901              LDR      r1,|L1.8|
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;117    }
000006  4770              BX       lr
;;;118    
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;369    *******************************************************************************/
;;;370    void Get_SerialNum(void)
000000  b510              PUSH     {r4,lr}
;;;371    {
;;;372      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;373    
;;;374      Device_Serial0 = *(__IO uint32_t*)(0x1FFFF7E8);
000002  4b10              LDR      r3,|L2.68|
000004  6818              LDR      r0,[r3,#0]
;;;375      Device_Serial1 = *(__IO uint32_t*)(0x1FFFF7EC);
000006  4b10              LDR      r3,|L2.72|
000008  f8d317ec          LDR      r1,[r3,#0x7ec]
;;;376      Device_Serial2 = *(__IO uint32_t*)(0x1FFFF7F0);
00000c  4b0d              LDR      r3,|L2.68|
00000e  3308              ADDS     r3,r3,#8
000010  681a              LDR      r2,[r3,#0]
;;;377    
;;;378      if (Device_Serial0 != 0)
000012  b1a8              CBZ      r0,|L2.64|
;;;379      {
;;;380        Virtual_Com_Port_StringSerial[2] = (uint8_t)(Device_Serial0 & 0x000000FF);
000014  4c0d              LDR      r4,|L2.76|
000016  70a0              STRB     r0,[r4,#2]
;;;381        Virtual_Com_Port_StringSerial[4] = (uint8_t)((Device_Serial0 & 0x0000FF00) >> 8);
000018  0a03              LSRS     r3,r0,#8
00001a  7123              STRB     r3,[r4,#4]
;;;382        Virtual_Com_Port_StringSerial[6] = (uint8_t)((Device_Serial0 & 0x00FF0000) >> 16);
00001c  0c03              LSRS     r3,r0,#16
00001e  71a3              STRB     r3,[r4,#6]
;;;383        Virtual_Com_Port_StringSerial[8] = (uint8_t)((Device_Serial0 & 0xFF000000) >> 24);
000020  0e03              LSRS     r3,r0,#24
000022  7223              STRB     r3,[r4,#8]
;;;384    
;;;385        Virtual_Com_Port_StringSerial[10] = (uint8_t)(Device_Serial1 & 0x000000FF);
000024  72a1              STRB     r1,[r4,#0xa]
;;;386        Virtual_Com_Port_StringSerial[12] = (uint8_t)((Device_Serial1 & 0x0000FF00) >> 8);
000026  0a0b              LSRS     r3,r1,#8
000028  7323              STRB     r3,[r4,#0xc]
;;;387        Virtual_Com_Port_StringSerial[14] = (uint8_t)((Device_Serial1 & 0x00FF0000) >> 16);
00002a  0c0b              LSRS     r3,r1,#16
00002c  73a3              STRB     r3,[r4,#0xe]
;;;388        Virtual_Com_Port_StringSerial[16] = (uint8_t)((Device_Serial1 & 0xFF000000) >> 24);
00002e  0e0b              LSRS     r3,r1,#24
000030  7423              STRB     r3,[r4,#0x10]
;;;389    
;;;390        Virtual_Com_Port_StringSerial[18] = (uint8_t)(Device_Serial2 & 0x000000FF);
000032  74a2              STRB     r2,[r4,#0x12]
;;;391        Virtual_Com_Port_StringSerial[20] = (uint8_t)((Device_Serial2 & 0x0000FF00) >> 8);
000034  0a13              LSRS     r3,r2,#8
000036  7523              STRB     r3,[r4,#0x14]
;;;392        Virtual_Com_Port_StringSerial[22] = (uint8_t)((Device_Serial2 & 0x00FF0000) >> 16);
000038  0c13              LSRS     r3,r2,#16
00003a  75a3              STRB     r3,[r4,#0x16]
;;;393        Virtual_Com_Port_StringSerial[24] = (uint8_t)((Device_Serial2 & 0xFF000000) >> 24);
00003c  0e13              LSRS     r3,r2,#24
00003e  7623              STRB     r3,[r4,#0x18]
                  |L2.64|
;;;394      }
;;;395    }
000040  bd10              POP      {r4,pc}
;;;396    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x1ffff7e8
                  |L2.72|
                          DCD      0x1ffff000
                  |L2.76|
                          DCD      Virtual_Com_Port_StringSerial

                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;124    *******************************************************************************/
;;;125    void Leave_LowPowerMode(void)
000000  4805              LDR      r0,|L3.24|
;;;126    {
;;;127      DEVICE_INFO *pInfo = &Device_Info;
;;;128    
;;;129      /* Set the device state to the correct state */
;;;130      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
000004  b119              CBZ      r1,|L3.14|
;;;131      {
;;;132        /* Device configured */
;;;133        bDeviceState = CONFIGURED;
000006  2105              MOVS     r1,#5
000008  4a04              LDR      r2,|L3.28|
00000a  6011              STR      r1,[r2,#0]  ; bDeviceState
00000c  e002              B        |L3.20|
                  |L3.14|
;;;134      }
;;;135      else
;;;136      {
;;;137        bDeviceState = ATTACHED;
00000e  2101              MOVS     r1,#1
000010  4a02              LDR      r2,|L3.28|
000012  6011              STR      r1,[r2,#0]  ; bDeviceState
                  |L3.20|
;;;138      }
;;;139    }
000014  4770              BX       lr
;;;140    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      Device_Info
                  |L3.28|
                          DCD      bDeviceState

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;52     *******************************************************************************/
;;;53     void Set_System(void)
000000  b508              PUSH     {r3,lr}
;;;54     {
;;;55       GPIO_InitTypeDef GPIO_InitStructure;
;;;56     
;;;57       /* Setup the microcontroller system. Initialize the Embedded Flash Interface,  
;;;58          initialize the PLL and update the SystemFrequency variable. */
;;;59       SystemInit();
000002  f7fffffe          BL       SystemInit
;;;60       
;;;61       /* Enable GPIOA, GPIOD and USART1 clock */
;;;62       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1  , ENABLE);
000006  2101              MOVS     r1,#1
000008  f2440004          MOV      r0,#0x4004
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;63       
;;;64       /* Enable TIM2 clock */
;;;65       RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
000010  2101              MOVS     r1,#1
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;66         
;;;67       /* Configure USART1 Rx (PA.10) as input floating */
;;;68       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000018  f44f6080          MOV      r0,#0x400
00001c  f8ad0000          STRH     r0,[sp,#0]
;;;69       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000020  2004              MOVS     r0,#4
000022  f88d0003          STRB     r0,[sp,#3]
;;;70       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
000026  2001              MOVS     r0,#1
000028  f88d0002          STRB     r0,[sp,#2]
;;;71       GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4813              LDR      r0,|L4.124|
000030  f7fffffe          BL       GPIO_Init
;;;72     
;;;73       /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;74       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000034  f44f7000          MOV      r0,#0x200
000038  f8ad0000          STRH     r0,[sp,#0]
;;;75       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
00003c  2001              MOVS     r0,#1
00003e  f88d0002          STRB     r0,[sp,#2]
;;;76       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000042  2018              MOVS     r0,#0x18
000044  f88d0003          STRB     r0,[sp,#3]
;;;77       GPIO_Init(GPIOA, &GPIO_InitStructure);
000048  4669              MOV      r1,sp
00004a  480c              LDR      r0,|L4.124|
00004c  f7fffffe          BL       GPIO_Init
;;;78       
;;;79       /* PA Configure: USB DISCONNECT(PA8) as output */
;;;80       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
000050  2080              MOVS     r0,#0x80
000052  f8ad0000          STRH     r0,[sp,#0]
;;;81       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000056  2002              MOVS     r0,#2
000058  f88d0002          STRB     r0,[sp,#2]
;;;82       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00005c  2010              MOVS     r0,#0x10
00005e  f88d0003          STRB     r0,[sp,#3]
;;;83       GPIO_Init(GPIOA, &GPIO_InitStructure);  
000062  4669              MOV      r1,sp
000064  4805              LDR      r0,|L4.124|
000066  f7fffffe          BL       GPIO_Init
;;;84        
;;;85       
;;;86       pbuffer_in_usart = buffer_in;
00006a  4805              LDR      r0,|L4.128|
00006c  4905              LDR      r1,|L4.132|
00006e  6008              STR      r0,[r1,#0]  ; pbuffer_in_usart
;;;87       pbuffer_in_usb = buffer_in;
000070  4905              LDR      r1,|L4.136|
000072  6008              STR      r0,[r1,#0]  ; pbuffer_in_usb
;;;88       
;;;89       pbuffer_out_usart = buffer_out;
000074  4805              LDR      r0,|L4.140|
000076  4906              LDR      r1,|L4.144|
000078  6008              STR      r0,[r1,#0]  ; pbuffer_out_usart
;;;90      
;;;91     }
00007a  bd08              POP      {r3,pc}
;;;92     
                          ENDP

                  |L4.124|
                          DCD      0x40010800
                  |L4.128|
                          DCD      buffer_in
                  |L4.132|
                          DCD      pbuffer_in_usart
                  |L4.136|
                          DCD      pbuffer_in_usb
                  |L4.140|
                          DCD      buffer_out
                  |L4.144|
                          DCD      pbuffer_out_usart

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;98     *******************************************************************************/
;;;99     void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;100    {
;;;101      /* USBCLK = PLLCLK / 1.5 */
;;;102      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;103      /* Enable USB clock */
;;;104      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  05c8              LSLS     r0,r1,#23
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;105    }
000010  bd10              POP      {r4,pc}
;;;106    
                          ENDP


                          AREA ||i.Timer_Init||, CODE, READONLY, ALIGN=1

                  Timer_Init PROC
;;;404    *******************************************************************************/
;;;405    void Timer_Init(uint16_t Time_ARR)
000000  b510              PUSH     {r4,lr}
;;;406    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;407      /* ---------------------------------------------------------------
;;;408        TIM2 Configuration: Timing Mode:
;;;409        TIM2CLK = 72 MHz, Prescaler = 23, TIM2 counter clock = 3MHz
;;;410        TIM2 ARR Register = 14999 => TIM2 Frequency = TIM2 counter clock/(ARR + 1)
;;;411        TIM2 Frequency = 200Hz.(5ms)
;;;412        TIM2 ARR Register = 29999 => TIM2 Frequency = TIM2 counter clock/(ARR + 1)
;;;413        TIM2 Frequency = 100Hz.(10ms)
;;;414        TIM2 ARR Register = 2999 => TIM2 Frequency = TIM2 counter clock/(ARR + 1)
;;;415        TIM2 Frequency = 1000Hz.(1ms)
;;;416      --------------------------------------------------------------- */
;;;417      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;418      TIM_OCInitTypeDef  TIM_OCInitStructure;  
;;;419      
;;;420      TIM_DeInit(TIM2);         /* deinitiate */
000006  f04f4080          MOV      r0,#0x40000000
00000a  f7fffffe          BL       TIM_DeInit
;;;421      
;;;422      TIM_TimeBaseStructure.TIM_Period = Time_ARR;   /* Time base configuration */
00000e  f8ad4018          STRH     r4,[sp,#0x18]
;;;423      TIM_TimeBaseStructure.TIM_Prescaler = 23;
000012  2017              MOVS     r0,#0x17
000014  f8ad0014          STRH     r0,[sp,#0x14]
;;;424      TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000018  2000              MOVS     r0,#0
00001a  f8ad001a          STRH     r0,[sp,#0x1a]
;;;425      TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
00001e  f8ad0016          STRH     r0,[sp,#0x16]
;;;426      TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
000022  a905              ADD      r1,sp,#0x14
000024  f04f4080          MOV      r0,#0x40000000
000028  f7fffffe          BL       TIM_TimeBaseInit
;;;427    
;;;428      TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;   /* Timing Mode :Channel1 */
00002c  2000              MOVS     r0,#0
00002e  f8ad0004          STRH     r0,[sp,#4]
;;;429      TIM_OC1Init(TIM2, &TIM_OCInitStructure);
000032  a901              ADD      r1,sp,#4
000034  f04f4080          MOV      r0,#0x40000000
000038  f7fffffe          BL       TIM_OC1Init
;;;430      TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);
00003c  2108              MOVS     r1,#8
00003e  06c8              LSLS     r0,r1,#27
000040  f7fffffe          BL       TIM_OC1PreloadConfig
;;;431      TIM_ARRPreloadConfig(TIM2, ENABLE);  
000044  2101              MOVS     r1,#1
000046  0788              LSLS     r0,r1,#30
000048  f7fffffe          BL       TIM_ARRPreloadConfig
;;;432    
;;;433      TIM_ITConfig(TIM2, TIM_IT_CC1, ENABLE);   /* TIM IT enable */
00004c  2201              MOVS     r2,#1
00004e  2102              MOVS     r1,#2
000050  0748              LSLS     r0,r1,#29
000052  f7fffffe          BL       TIM_ITConfig
;;;434    
;;;435      TIM_Cmd(TIM2, ENABLE);  /* TIM3 enable counter */
000056  2101              MOVS     r1,#1
000058  0788              LSLS     r0,r1,#30
00005a  f7fffffe          BL       TIM_Cmd
;;;436    }
00005e  b008              ADD      sp,sp,#0x20
000060  bd10              POP      {r4,pc}
;;;437    
                          ENDP


                          AREA ||i.USART_2_USB_Send_Data||, CODE, READONLY, ALIGN=2

                  USART_2_USB_Send_Data PROC
;;;347    *******************************************************************************/
;;;348    void USART_2_USB_Send_Data(void)
000000  b510              PUSH     {r4,lr}
;;;349    {
;;;350      if (linecoding.datatype == 7)
000002  4814              LDR      r0,|L7.84|
000004  7980              LDRB     r0,[r0,#6]  ; linecoding
000006  2807              CMP      r0,#7
000008  d10b              BNE      |L7.34|
;;;351      {
;;;352        *pbuffer_in_usart++ = USART_ReceiveData(USART1) & 0x7F;
00000a  4813              LDR      r0,|L7.88|
00000c  f7fffffe          BL       USART_ReceiveData
000010  f000017f          AND      r1,r0,#0x7f
000014  4811              LDR      r0,|L7.92|
000016  6804              LDR      r4,[r0,#0]  ; pbuffer_in_usart
000018  1c60              ADDS     r0,r4,#1
00001a  4a10              LDR      r2,|L7.92|
00001c  6010              STR      r0,[r2,#0]  ; pbuffer_in_usart
00001e  7021              STRB     r1,[r4,#0]
000020  e00d              B        |L7.62|
                  |L7.34|
;;;353      }
;;;354      else if (linecoding.datatype == 8)
000022  480c              LDR      r0,|L7.84|
000024  7980              LDRB     r0,[r0,#6]  ; linecoding
000026  2808              CMP      r0,#8
000028  d109              BNE      |L7.62|
;;;355      {
;;;356        *pbuffer_in_usart++ = USART_ReceiveData(USART1);
00002a  480b              LDR      r0,|L7.88|
00002c  f7fffffe          BL       USART_ReceiveData
000030  b2c1              UXTB     r1,r0
000032  480a              LDR      r0,|L7.92|
000034  6804              LDR      r4,[r0,#0]  ; pbuffer_in_usart
000036  1c60              ADDS     r0,r4,#1
000038  4a08              LDR      r2,|L7.92|
00003a  6010              STR      r0,[r2,#0]  ; pbuffer_in_usart
00003c  7021              STRB     r1,[r4,#0]
                  |L7.62|
;;;357      }
;;;358      
;;;359      if (pbuffer_in_usart == &buffer_in[BUFFER_SIZE])
00003e  4807              LDR      r0,|L7.92|
000040  6801              LDR      r1,[r0,#0]  ; pbuffer_in_usart
000042  4807              LDR      r0,|L7.96|
000044  4281              CMP      r1,r0
000046  d103              BNE      |L7.80|
;;;360        pbuffer_in_usart = buffer_in;
000048  f5a06080          SUB      r0,r0,#0x400
00004c  4903              LDR      r1,|L7.92|
00004e  6008              STR      r0,[r1,#0]  ; pbuffer_in_usart
                  |L7.80|
;;;361    }
000050  bd10              POP      {r4,pc}
;;;362    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      linecoding
                  |L7.88|
                          DCD      0x40013800
                  |L7.92|
                          DCD      pbuffer_in_usart
                  |L7.96|
                          DCD      buffer_in+0x400

                          AREA ||i.USART_Config||, CODE, READONLY, ALIGN=2

                  USART_Config PROC
;;;241    *******************************************************************************/
;;;242    bool USART_Config(void)
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244    
;;;245      /* set the Stop bit*/
;;;246      switch (linecoding.format)
000002  4840              LDR      r0,|L8.260|
000004  7900              LDRB     r0,[r0,#4]  ; linecoding
000006  b120              CBZ      r0,|L8.18|
000008  2801              CMP      r0,#1
00000a  d006              BEQ      |L8.26|
00000c  2802              CMP      r0,#2
00000e  d10e              BNE      |L8.46|
000010  e008              B        |L8.36|
                  |L8.18|
;;;247      {
;;;248        case 0:
;;;249          USART_InitStructure.USART_StopBits = USART_StopBits_1;
000012  2000              MOVS     r0,#0
000014  493c              LDR      r1,|L8.264|
000016  80c8              STRH     r0,[r1,#6]
;;;250          break;
000018  e00d              B        |L8.54|
                  |L8.26|
;;;251        case 1:
;;;252          USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
00001a  f44f5040          MOV      r0,#0x3000
00001e  493a              LDR      r1,|L8.264|
000020  80c8              STRH     r0,[r1,#6]
;;;253          break;
000022  e008              B        |L8.54|
                  |L8.36|
;;;254        case 2:
;;;255          USART_InitStructure.USART_StopBits = USART_StopBits_2;
000024  f44f5000          MOV      r0,#0x2000
000028  4937              LDR      r1,|L8.264|
00002a  80c8              STRH     r0,[r1,#6]
;;;256          break;
00002c  e003              B        |L8.54|
                  |L8.46|
;;;257        default :
;;;258        {
;;;259          USART_Config_Default();
00002e  f7fffffe          BL       USART_Config_Default
;;;260          return (FALSE);
000032  2000              MOVS     r0,#0
                  |L8.52|
;;;261        }
;;;262      }
;;;263    
;;;264      /* set the parity bit*/
;;;265      switch (linecoding.paritytype)
;;;266      {
;;;267        case 0:
;;;268          USART_InitStructure.USART_Parity = USART_Parity_No;
;;;269          break;
;;;270        case 1:
;;;271          USART_InitStructure.USART_Parity = USART_Parity_Even;
;;;272          break;
;;;273        case 2:
;;;274          USART_InitStructure.USART_Parity = USART_Parity_Odd;
;;;275          break;
;;;276        default :
;;;277        {
;;;278          USART_Config_Default();
;;;279          return (FALSE);
;;;280        }
;;;281      }
;;;282    
;;;283      /*set the data type : only 8bits and 9bits is supported */
;;;284      switch (linecoding.datatype)
;;;285      {
;;;286        case 0x07:
;;;287          /* With this configuration a parity (Even or Odd) should be set */
;;;288          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;289          break;
;;;290        case 0x08:
;;;291          if (USART_InitStructure.USART_Parity == USART_Parity_No)
;;;292          {
;;;293            USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;294          }
;;;295          else 
;;;296          {
;;;297            USART_InitStructure.USART_WordLength = USART_WordLength_9b;
;;;298          }
;;;299          
;;;300          break;
;;;301        default :
;;;302        {
;;;303          USART_Config_Default();
;;;304          return (FALSE);
;;;305        }
;;;306      }
;;;307    
;;;308      if (linecoding.bitrate < 115200) 
;;;309        TimeBase = TIMER_ARR_10MS;
;;;310      else if (linecoding.bitrate >= 256000)
;;;311        TimeBase = TIMER_ARR_1MS;
;;;312      else 
;;;313        TimeBase = TIMER_ARR_5MS;
;;;314      Timer_Init(TimeBase);
;;;315      
;;;316      USART_InitStructure.USART_BaudRate = linecoding.bitrate;
;;;317      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;318      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;319      USART_Init(USART1, &USART_InitStructure);
;;;320      USART_Cmd(USART1, ENABLE);
;;;321      return (TRUE);
;;;322    }
000034  bd10              POP      {r4,pc}
                  |L8.54|
000036  bf00              NOP                            ;250
000038  4832              LDR      r0,|L8.260|
00003a  7940              LDRB     r0,[r0,#5]            ;265  ; linecoding
00003c  b120              CBZ      r0,|L8.72|
00003e  2801              CMP      r0,#1                 ;265
000040  d006              BEQ      |L8.80|
000042  2802              CMP      r0,#2                 ;265
000044  d10e              BNE      |L8.100|
000046  e008              B        |L8.90|
                  |L8.72|
000048  2000              MOVS     r0,#0                 ;268
00004a  492f              LDR      r1,|L8.264|
00004c  8108              STRH     r0,[r1,#8]            ;268
00004e  e00d              B        |L8.108|
                  |L8.80|
000050  f44f6080          MOV      r0,#0x400             ;271
000054  492c              LDR      r1,|L8.264|
000056  8108              STRH     r0,[r1,#8]            ;271
000058  e008              B        |L8.108|
                  |L8.90|
00005a  f44f60c0          MOV      r0,#0x600             ;274
00005e  492a              LDR      r1,|L8.264|
000060  8108              STRH     r0,[r1,#8]            ;274
000062  e003              B        |L8.108|
                  |L8.100|
000064  f7fffffe          BL       USART_Config_Default
000068  2000              MOVS     r0,#0                 ;279
00006a  e7e3              B        |L8.52|
                  |L8.108|
00006c  bf00              NOP                            ;269
00006e  4825              LDR      r0,|L8.260|
000070  7980              LDRB     r0,[r0,#6]            ;284  ; linecoding
000072  2807              CMP      r0,#7                 ;284
000074  d002              BEQ      |L8.124|
000076  2808              CMP      r0,#8                 ;284
000078  d110              BNE      |L8.156|
00007a  e003              B        |L8.132|
                  |L8.124|
00007c  2000              MOVS     r0,#0                 ;288
00007e  4922              LDR      r1,|L8.264|
000080  8088              STRH     r0,[r1,#4]            ;288
000082  e00f              B        |L8.164|
                  |L8.132|
000084  4820              LDR      r0,|L8.264|
000086  8900              LDRH     r0,[r0,#8]            ;291  ; USART_InitStructure
000088  b918              CBNZ     r0,|L8.146|
00008a  2000              MOVS     r0,#0                 ;293
00008c  491e              LDR      r1,|L8.264|
00008e  8088              STRH     r0,[r1,#4]            ;293
000090  e003              B        |L8.154|
                  |L8.146|
000092  f44f5080          MOV      r0,#0x1000            ;297
000096  491c              LDR      r1,|L8.264|
000098  8088              STRH     r0,[r1,#4]            ;297
                  |L8.154|
00009a  e003              B        |L8.164|
                  |L8.156|
00009c  f7fffffe          BL       USART_Config_Default
0000a0  2000              MOVS     r0,#0                 ;304
0000a2  e7c7              B        |L8.52|
                  |L8.164|
0000a4  bf00              NOP                            ;289
0000a6  4817              LDR      r0,|L8.260|
0000a8  6800              LDR      r0,[r0,#0]            ;308  ; linecoding
0000aa  f5b03fe1          CMP      r0,#0x1c200           ;308
0000ae  d204              BCS      |L8.186|
0000b0  f247502f          MOV      r0,#0x752f            ;309
0000b4  4915              LDR      r1,|L8.268|
0000b6  6008              STR      r0,[r1,#0]            ;309  ; TimeBase
0000b8  e00d              B        |L8.214|
                  |L8.186|
0000ba  4812              LDR      r0,|L8.260|
0000bc  6800              LDR      r0,[r0,#0]            ;310  ; linecoding
0000be  f5b03f7a          CMP      r0,#0x3e800           ;310
0000c2  d304              BCC      |L8.206|
0000c4  f64030b7          MOV      r0,#0xbb7             ;311
0000c8  4910              LDR      r1,|L8.268|
0000ca  6008              STR      r0,[r1,#0]            ;311  ; TimeBase
0000cc  e003              B        |L8.214|
                  |L8.206|
0000ce  f6432097          MOV      r0,#0x3a97            ;313
0000d2  490e              LDR      r1,|L8.268|
0000d4  6008              STR      r0,[r1,#0]            ;313  ; TimeBase
                  |L8.214|
0000d6  480d              LDR      r0,|L8.268|
0000d8  6800              LDR      r0,[r0,#0]            ;314  ; TimeBase
0000da  b280              UXTH     r0,r0                 ;314
0000dc  f7fffffe          BL       Timer_Init
0000e0  4808              LDR      r0,|L8.260|
0000e2  6800              LDR      r0,[r0,#0]            ;316  ; linecoding
0000e4  4908              LDR      r1,|L8.264|
0000e6  6008              STR      r0,[r1,#0]            ;316  ; USART_InitStructure
0000e8  2000              MOVS     r0,#0                 ;317
0000ea  8188              STRH     r0,[r1,#0xc]          ;317
0000ec  200c              MOVS     r0,#0xc               ;318
0000ee  8148              STRH     r0,[r1,#0xa]          ;318
0000f0  4807              LDR      r0,|L8.272|
0000f2  f7fffffe          BL       USART_Init
0000f6  2101              MOVS     r1,#1                 ;320
0000f8  4805              LDR      r0,|L8.272|
0000fa  f7fffffe          BL       USART_Cmd
0000fe  2001              MOVS     r0,#1                 ;321
000100  e798              B        |L8.52|
;;;323    
                          ENDP

000102  0000              DCW      0x0000
                  |L8.260|
                          DCD      linecoding
                  |L8.264|
                          DCD      USART_InitStructure
                  |L8.268|
                          DCD      TimeBase
                  |L8.272|
                          DCD      0x40013800

                          AREA ||i.USART_Config_Default||, CODE, READONLY, ALIGN=2

                  USART_Config_Default PROC
;;;208    *******************************************************************************/
;;;209    void USART_Config_Default(void)
000000  b510              PUSH     {r4,lr}
;;;210    {
;;;211      /* USART1 default configuration */
;;;212      /* USART1 configured as follow:
;;;213            - BaudRate = 9600 baud  
;;;214            - Word Length = 8 Bits
;;;215            - One Stop Bit
;;;216            - Parity Odd
;;;217            - Hardware flow control desabled
;;;218            - Receive and transmit enabled
;;;219      */
;;;220      USART_InitStructure.USART_BaudRate = 115200;
000002  f44f30e1          MOV      r0,#0x1c200
000006  490c              LDR      r1,|L9.56|
000008  6008              STR      r0,[r1,#0]  ; USART_InitStructure
;;;221      USART_InitStructure.USART_WordLength = USART_WordLength_9b;
00000a  f44f5080          MOV      r0,#0x1000
00000e  8088              STRH     r0,[r1,#4]
;;;222      USART_InitStructure.USART_StopBits = USART_StopBits_1;
000010  2000              MOVS     r0,#0
000012  80c8              STRH     r0,[r1,#6]
;;;223      USART_InitStructure.USART_Parity = USART_Parity_Even;
000014  f44f6080          MOV      r0,#0x400
000018  8108              STRH     r0,[r1,#8]
;;;224      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00001a  2000              MOVS     r0,#0
00001c  8188              STRH     r0,[r1,#0xc]
;;;225      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00001e  200c              MOVS     r0,#0xc
000020  8148              STRH     r0,[r1,#0xa]
;;;226    
;;;227      /* Configure the USART1 */
;;;228      USART_Init(USART1, &USART_InitStructure);
000022  4806              LDR      r0,|L9.60|
000024  f7fffffe          BL       USART_Init
;;;229    
;;;230      /* Enable the USART Receive interrupt */
;;;231      USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
000028  2201              MOVS     r2,#1
00002a  f2405125          MOV      r1,#0x525
00002e  4803              LDR      r0,|L9.60|
000030  f7fffffe          BL       USART_ITConfig
;;;232    }
000034  bd10              POP      {r4,pc}
;;;233    
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      USART_InitStructure
                  |L9.60|
                          DCD      0x40013800

                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;190    *******************************************************************************/
;;;191    void USB_Cable_Config (FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;192    {
000002  4604              MOV      r4,r0
;;;193      if (NewState == DISABLE)
000004  b924              CBNZ     r4,|L10.16|
;;;194      {
;;;195        GPIO_ResetBits(GPIOA, GPIO_Pin_7);
000006  2180              MOVS     r1,#0x80
000008  4804              LDR      r0,|L10.28|
00000a  f7fffffe          BL       GPIO_ResetBits
00000e  e003              B        |L10.24|
                  |L10.16|
;;;196      }
;;;197      else
;;;198      {
;;;199        GPIO_SetBits(GPIOA, GPIO_Pin_7);
000010  2180              MOVS     r1,#0x80
000012  4802              LDR      r0,|L10.28|
000014  f7fffffe          BL       GPIO_SetBits
                  |L10.24|
;;;200      }
;;;201    }
000018  bd10              POP      {r4,pc}
;;;202    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40010800

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;146    *******************************************************************************/
;;;147    void USB_Interrupts_Config(void)
000000  b508              PUSH     {r3,lr}
;;;148    {
;;;149      NVIC_InitTypeDef NVIC_InitStructure;
;;;150    
;;;151    //#ifdef  VECT_TAB_RAM
;;;152    #if defined (VECT_TAB_RAM)
;;;153      /* Set the Vector Table base location at 0x20000000 */ 
;;;154      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;155    #else  /* VECT_TAB_FLASH  */
;;;156      /* Set the Vector Table base location at 0x08000000 */ 
;;;157      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;158    #endif 
;;;159    
;;;160      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
00000c  f44f60c0          MOV      r0,#0x600
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;161    
;;;162      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
000014  2014              MOVS     r0,#0x14
000016  f88d0000          STRB     r0,[sp,#0]
;;;163      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001a  2000              MOVS     r0,#0
00001c  f88d0001          STRB     r0,[sp,#1]
;;;164      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  f88d0002          STRB     r0,[sp,#2]
;;;165      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  2001              MOVS     r0,#1
000026  f88d0003          STRB     r0,[sp,#3]
;;;166      NVIC_Init(&NVIC_InitStructure);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
;;;167    
;;;168      /* Enable USART1 Interrupt */
;;;169      NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000030  2025              MOVS     r0,#0x25
000032  f88d0000          STRB     r0,[sp,#0]
;;;170      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000036  2001              MOVS     r0,#1
000038  f88d0001          STRB     r0,[sp,#1]
;;;171      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00003c  2000              MOVS     r0,#0
00003e  f88d0002          STRB     r0,[sp,#2]
;;;172      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000042  2001              MOVS     r0,#1
000044  f88d0003          STRB     r0,[sp,#3]
;;;173      NVIC_Init(&NVIC_InitStructure);
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       NVIC_Init
;;;174      
;;;175      NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
00004e  201c              MOVS     r0,#0x1c
000050  f88d0000          STRB     r0,[sp,#0]
;;;176      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000054  2001              MOVS     r0,#1
000056  f88d0001          STRB     r0,[sp,#1]
;;;177      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
00005a  f88d0002          STRB     r0,[sp,#2]
;;;178      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00005e  f88d0003          STRB     r0,[sp,#3]
;;;179      NVIC_Init(&NVIC_InitStructure);
000062  4668              MOV      r0,sp
000064  f7fffffe          BL       NVIC_Init
;;;180    }
000068  bd08              POP      {r3,pc}
;;;181    
                          ENDP


                          AREA ||i.USB_To_USART_Send_Data||, CODE, READONLY, ALIGN=2

                  USB_To_USART_Send_Data PROC
;;;330    *******************************************************************************/
;;;331    void USB_To_USART_Send_Data(uint8_t* data_buffer, uint8_t Nb_bytes)
000000  b570              PUSH     {r4-r6,lr}
;;;332    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;333      uint32_t i;
;;;334    
;;;335      for (i = 0; i < Nb_bytes; i++)
000006  2600              MOVS     r6,#0
000008  e00b              B        |L12.34|
                  |L12.10|
;;;336      {
;;;337        USART_SendData(USART1, *(data_buffer + i));
00000a  5da1              LDRB     r1,[r4,r6]
00000c  4806              LDR      r0,|L12.40|
00000e  f7fffffe          BL       USART_SendData
;;;338        while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); 
000012  bf00              NOP      
                  |L12.20|
000014  2180              MOVS     r1,#0x80
000016  4804              LDR      r0,|L12.40|
000018  f7fffffe          BL       USART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L12.20|
000020  1c76              ADDS     r6,r6,#1              ;335
                  |L12.34|
000022  42ae              CMP      r6,r5                 ;335
000024  d3f1              BCC      |L12.10|
;;;339      }
;;;340    }
000026  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP

                  |L12.40|
                          DCD      0x40013800

                          AREA ||i.usart_2_usb_send||, CODE, READONLY, ALIGN=2

                  usart_2_usb_send PROC
;;;444    volatile USB_USART_STATE usart_2_usb_process;
;;;445    void usart_2_usb_send(void)
000000  b570              PUSH     {r4-r6,lr}
;;;446    {
;;;447      unsigned char *ptemp = NULL;
000002  2400              MOVS     r4,#0
;;;448      unsigned char * temp1;
;;;449      unsigned int temp2;
;;;450      if (pbuffer_in_usb == &buffer_in[BUFFER_SIZE])
000004  482f              LDR      r0,|L13.196|
000006  6801              LDR      r1,[r0,#0]  ; pbuffer_in_usb
000008  482f              LDR      r0,|L13.200|
00000a  4281              CMP      r1,r0
00000c  d103              BNE      |L13.22|
;;;451        pbuffer_in_usb = buffer_in;
00000e  f5a06080          SUB      r0,r0,#0x400
000012  492c              LDR      r1,|L13.196|
000014  6008              STR      r0,[r1,#0]  ; pbuffer_in_usb
                  |L13.22|
;;;452      temp1 = pbuffer_in_usart;
000016  482d              LDR      r0,|L13.204|
000018  6805              LDR      r5,[r0,#0]  ; pbuffer_in_usart
;;;453      if(pbuffer_in_usb == temp1) {
00001a  482a              LDR      r0,|L13.196|
00001c  6800              LDR      r0,[r0,#0]  ; pbuffer_in_usb
00001e  42a8              CMP      r0,r5
000020  d106              BNE      |L13.48|
;;;454        usart_2_usb_process = WAIT_USART2USB_END;        // no data needed to send from USB
000022  2002              MOVS     r0,#2
000024  492a              LDR      r1,|L13.208|
000026  7008              STRB     r0,[r1,#0]
;;;455        usart_2_usb_complete = TRUE;
000028  2001              MOVS     r0,#1
00002a  492a              LDR      r1,|L13.212|
00002c  7008              STRB     r0,[r1,#0]
                  |L13.46|
;;;456        return;
;;;457      }
;;;458      else if(pbuffer_in_usb > temp1) {  // if the pbuffer_in_usart is rollback
;;;459        usart_2_usb_count = &buffer_in[BUFFER_SIZE] - pbuffer_in_usb;
;;;460      }
;;;461      else {
;;;462        temp2 = (unsigned int)pbuffer_in_usart;
;;;463        temp2 = temp2 - (unsigned int)pbuffer_in_usb;
;;;464        usart_2_usb_count = temp2;
;;;465      }
;;;466      
;;;467      if (usart_2_usb_count > VIRTUAL_COM_PORT_DATA_SIZE){
;;;468        ptemp = pbuffer_in_usb;
;;;469        UserToPMABufferCopy(ptemp, ENDP1_TXADDR, VIRTUAL_COM_PORT_DATA_SIZE);
;;;470        SetEPTxCount(ENDP1, VIRTUAL_COM_PORT_DATA_SIZE);
;;;471        usart_2_usb_count -= VIRTUAL_COM_PORT_DATA_SIZE;
;;;472        pbuffer_in_usb += VIRTUAL_COM_PORT_DATA_SIZE;
;;;473      }
;;;474      else {
;;;475        ptemp = pbuffer_in_usb;
;;;476        UserToPMABufferCopy(ptemp, ENDP1_TXADDR, usart_2_usb_count);
;;;477        SetEPTxCount(ENDP1, usart_2_usb_count);
;;;478        temp2 = usart_2_usb_count;
;;;479        pbuffer_in_usb += temp2;
;;;480        usart_2_usb_count = 0;    
;;;481      }
;;;482      
;;;483      usart_2_usb_process = WAIT_USART2USB_END; 
;;;484      SetEPTxValid(ENDP1); 
;;;485    }
00002e  bd70              POP      {r4-r6,pc}
                  |L13.48|
000030  4824              LDR      r0,|L13.196|
000032  6800              LDR      r0,[r0,#0]            ;458  ; pbuffer_in_usb
000034  42a8              CMP      r0,r5                 ;458
000036  d906              BLS      |L13.70|
000038  4823              LDR      r0,|L13.200|
00003a  4922              LDR      r1,|L13.196|
00003c  6809              LDR      r1,[r1,#0]            ;459  ; pbuffer_in_usb
00003e  1a40              SUBS     r0,r0,r1              ;459
000040  4925              LDR      r1,|L13.216|
000042  8008              STRH     r0,[r1,#0]            ;459
000044  e006              B        |L13.84|
                  |L13.70|
000046  4821              LDR      r0,|L13.204|
000048  6806              LDR      r6,[r0,#0]            ;462  ; pbuffer_in_usart
00004a  481e              LDR      r0,|L13.196|
00004c  6800              LDR      r0,[r0,#0]            ;463  ; pbuffer_in_usb
00004e  1a36              SUBS     r6,r6,r0              ;463
000050  4921              LDR      r1,|L13.216|
000052  800e              STRH     r6,[r1,#0]            ;464
                  |L13.84|
000054  4820              LDR      r0,|L13.216|
000056  8800              LDRH     r0,[r0,#0]            ;467  ; usart_2_usb_count
000058  2840              CMP      r0,#0x40              ;467
00005a  dd15              BLE      |L13.136|
00005c  4819              LDR      r0,|L13.196|
00005e  6804              LDR      r4,[r0,#0]            ;468  ; pbuffer_in_usb
000060  2240              MOVS     r2,#0x40              ;469
000062  21c0              MOVS     r1,#0xc0              ;469
000064  4620              MOV      r0,r4                 ;469
000066  f7fffffe          BL       UserToPMABufferCopy
00006a  2140              MOVS     r1,#0x40              ;470
00006c  2001              MOVS     r0,#1                 ;470
00006e  f7fffffe          BL       SetEPTxCount
000072  4819              LDR      r0,|L13.216|
000074  8800              LDRH     r0,[r0,#0]            ;471  ; usart_2_usb_count
000076  3840              SUBS     r0,r0,#0x40           ;471
000078  4917              LDR      r1,|L13.216|
00007a  8008              STRH     r0,[r1,#0]            ;471
00007c  4811              LDR      r0,|L13.196|
00007e  6800              LDR      r0,[r0,#0]            ;472  ; pbuffer_in_usb
000080  3040              ADDS     r0,r0,#0x40           ;472
000082  4910              LDR      r1,|L13.196|
000084  6008              STR      r0,[r1,#0]            ;472  ; pbuffer_in_usb
000086  e016              B        |L13.182|
                  |L13.136|
000088  480e              LDR      r0,|L13.196|
00008a  6804              LDR      r4,[r0,#0]            ;475  ; pbuffer_in_usb
00008c  4812              LDR      r0,|L13.216|
00008e  8802              LDRH     r2,[r0,#0]            ;476  ; usart_2_usb_count
000090  21c0              MOVS     r1,#0xc0              ;476
000092  4620              MOV      r0,r4                 ;476
000094  f7fffffe          BL       UserToPMABufferCopy
000098  480f              LDR      r0,|L13.216|
00009a  8801              LDRH     r1,[r0,#0]            ;477  ; usart_2_usb_count
00009c  2001              MOVS     r0,#1                 ;477
00009e  f7fffffe          BL       SetEPTxCount
0000a2  480d              LDR      r0,|L13.216|
0000a4  8806              LDRH     r6,[r0,#0]            ;478  ; usart_2_usb_count
0000a6  4807              LDR      r0,|L13.196|
0000a8  6800              LDR      r0,[r0,#0]            ;479  ; pbuffer_in_usb
0000aa  4430              ADD      r0,r0,r6              ;479
0000ac  4905              LDR      r1,|L13.196|
0000ae  6008              STR      r0,[r1,#0]            ;479  ; pbuffer_in_usb
0000b0  2000              MOVS     r0,#0                 ;480
0000b2  4909              LDR      r1,|L13.216|
0000b4  8008              STRH     r0,[r1,#0]            ;480
                  |L13.182|
0000b6  2002              MOVS     r0,#2                 ;483
0000b8  4905              LDR      r1,|L13.208|
0000ba  7008              STRB     r0,[r1,#0]            ;483
0000bc  2001              MOVS     r0,#1                 ;484
0000be  f7fffffe          BL       SetEPTxValid
0000c2  e7b4              B        |L13.46|
;;;486    
                          ENDP

                  |L13.196|
                          DCD      pbuffer_in_usb
                  |L13.200|
                          DCD      buffer_in+0x400
                  |L13.204|
                          DCD      pbuffer_in_usart
                  |L13.208|
                          DCD      usart_2_usb_process
                  |L13.212|
                          DCD      usart_2_usb_complete
                  |L13.216|
                          DCD      usart_2_usb_count

                          AREA ||i.usart_2_usb_waitend||, CODE, READONLY, ALIGN=2

                  usart_2_usb_waitend PROC
;;;494    #define CR1_CEN_Set                 ((uint16_t)0x0001)
;;;495    void usart_2_usb_waitend(void)
000000  4809              LDR      r0,|L14.40|
;;;496    {
;;;497      if (usart_2_usb_complete == TRUE){
000002  7800              LDRB     r0,[r0,#0]  ; usart_2_usb_complete
000004  2801              CMP      r0,#1
000006  d10d              BNE      |L14.36|
;;;498        usart_2_usb_process = USART_RECEIVE;     
000008  2000              MOVS     r0,#0
00000a  4908              LDR      r1,|L14.44|
00000c  7008              STRB     r0,[r1,#0]
;;;499        TIM2->CR1 |= CR1_CEN_Set;       // enable timer
00000e  f04f4080          MOV      r0,#0x40000000
000012  8800              LDRH     r0,[r0,#0]
000014  f0400001          ORR      r0,r0,#1
000018  f04f4180          MOV      r1,#0x40000000
00001c  8008              STRH     r0,[r1,#0]
;;;500        usart_2_usb_complete = FALSE;
00001e  2000              MOVS     r0,#0
000020  4901              LDR      r1,|L14.40|
000022  7008              STRB     r0,[r1,#0]
                  |L14.36|
;;;501      }
;;;502      else {
;;;503      }
;;;504    }
000024  4770              BX       lr
;;;505    
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      usart_2_usb_complete
                  |L14.44|
                          DCD      usart_2_usb_process

                          AREA ||i.usb_2_usart_send_data||, CODE, READONLY, ALIGN=2

                  usb_2_usart_send_data PROC
;;;513    extern __IO uint32_t count_out;
;;;514    void usb_2_usart_send_data(void)
000000  b510              PUSH     {r4,lr}
;;;515    {
;;;516      if (count_out == 0) {
000002  480f              LDR      r0,|L15.64|
000004  6800              LDR      r0,[r0,#0]  ; count_out
000006  b948              CBNZ     r0,|L15.28|
;;;517        USART_ITConfig(USART1, USART_IT_TXE, DISABLE); 
000008  2200              MOVS     r2,#0
00000a  f2407127          MOV      r1,#0x727
00000e  480d              LDR      r0,|L15.68|
000010  f7fffffe          BL       USART_ITConfig
;;;518        SetEPRxValid(ENDP3);
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       SetEPRxValid
00001a  e00f              B        |L15.60|
                  |L15.28|
;;;519      }
;;;520      else {
;;;521        USART1->DR = *pbuffer_out_usart & (uint16_t)0x01FF;
00001c  480a              LDR      r0,|L15.72|
00001e  6800              LDR      r0,[r0,#0]  ; pbuffer_out_usart
000020  7800              LDRB     r0,[r0,#0]
000022  4908              LDR      r1,|L15.68|
000024  1d09              ADDS     r1,r1,#4
000026  8008              STRH     r0,[r1,#0]
;;;522        pbuffer_out_usart++;
000028  4807              LDR      r0,|L15.72|
00002a  6800              LDR      r0,[r0,#0]  ; pbuffer_out_usart
00002c  1c40              ADDS     r0,r0,#1
00002e  4906              LDR      r1,|L15.72|
000030  6008              STR      r0,[r1,#0]  ; pbuffer_out_usart
;;;523        count_out--;
000032  4803              LDR      r0,|L15.64|
000034  6800              LDR      r0,[r0,#0]  ; count_out
000036  1e40              SUBS     r0,r0,#1
000038  4901              LDR      r1,|L15.64|
00003a  6008              STR      r0,[r1,#0]  ; count_out
                  |L15.60|
;;;524      }
;;;525    }
00003c  bd10              POP      {r4,pc}
;;;526    /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
                          DCD      count_out
                  |L15.68|
                          DCD      0x40013800
                  |L15.72|
                          DCD      pbuffer_out_usart

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_InitStructure
                          %        16
                  buffer_in
                          %        1024
                  buffer_out
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  pbuffer_in_usart
                          DCD      0x00000000
                  pbuffer_in_usb
                          DCD      0x00000000
                  pbuffer_out_usart
                          DCD      0x00000000
                  TimeBase
                          DCD      0x00000000
                  usart_2_usb_count
000010  0000              DCB      0x00,0x00
                  usart_2_usb_complete
000012  00                DCB      0x00
                  usart_2_usb_process
000013  00                DCB      0x00

C51 COMPILER V7.00  TEST72                                                                 09/16/2012 15:52:35 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE TEST72
OBJECT MODULE PLACED IN TEST72.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE TEST72.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          ////////////////////////////////////////////////////////////////////////////
   2          //                给力者单片机开发学习系统，开发学习都给力！              //
   3          ////////////////////////////////////////////////////////////////////////////
   4          //                     学习51单片机，其实可以很简单                       //
   5          ////////////////////////////////////////////////////////////////////////////
   6          //                宁波芯动电子有限公司  www.MovingChip.com                //
   7          ////////////////////////////////////////////////////////////////////////////
   8          
   9          #include <AT89X52.h>       //调用51单片机的头文件
  10          
  11          //---------------------------------------
  12          //1602液晶相关I/O设置
  13          sbit E=P2^3;               //1602液晶的E脚接在P2.3口上
  14          sbit RW=P2^4;              //1602液晶的RW脚接在P2.4口上
  15          sbit RS=P2^5;              //1602液晶的RS脚接在P2.5口上
  16          //---------------------------------------
  17          sbit Key_Data =P3^5;
  18          sbit Key_CLK =P3^3; 
  19          //---------------------------------------
  20          
  21          unsigned char IntNum = 0; //中断次数计数
  22          unsigned char KeyV; //键值
  23          unsigned char DisNum = 0; //显示用指针
  24          unsigned char Key_UP=0, Shift = 0;//Key_UP是键松开标识，Shift是Shift键按下标识
  25          unsigned char keybuf;
  26          unsigned char disbuf[32];
  27          unsigned char weizhi;
  28          bit BF; //标识是否有字符被收到
  29          bit disbit;
  30                           
  31          
  32          unsigned char code UnShifted[58][2] = {
  33          0x1C, 'a',
  34          0x32, 'b',
  35          0x21, 'c',
  36          0x23, 'd',
  37          0x24, 'e',
  38          0x2B, 'f',
  39          0x34, 'g',
  40          0x33, 'h',
  41          0x43, 'i',
  42          0x3B, 'j',
  43          0x42, 'k',
  44          0x4B, 'l',
  45          0x3A, 'm',
  46          0x31, 'n',
  47          0x44, 'o',
  48          0x4D, 'p',
  49          0x15, 'q',
  50          0x2D, 'r',
  51          0x1B, 's',
  52          0x2C, 't',
  53          0x3C, 'u',
  54          0x2A, 'v',
  55          0x1D, 'w',
C51 COMPILER V7.00  TEST72                                                                 09/16/2012 15:52:35 PAGE 2   

  56          0x22, 'x',
  57          0x35, 'y',
  58          0x1A, 'z',
  59          0x45, '0',
  60          0x16, '1',
  61          0x1E, '2',
  62          0x26, '3',
  63          0x25, '4',
  64          0x2E, '5',
  65          0x36, '6',
  66          0x3D, '7',
  67          0x3E, '8',
  68          0x46, '9',
  69          0x70, '0',
  70          0x69, '1',
  71          0x72, '2',
  72          0x7A, '3',
  73          0x6B, '4',
  74          0x73, '5',
  75          0x74, '6',
  76          0x6C, '7',
  77          0x75, '8',
  78          0x7D, '9',
  79          
  80          0x4E, '-',
  81          0x55, '=',
  82          0x5D, ' ',
  83          0x29, ' ',
  84          0x54, '[',
  85          0x5B, ']',
  86          0x4C, ';',
  87          0x52, ' ',
  88          0x41, ',',
  89          0x49, '.',
  90          0x4A, '/',
  91          0x71, '.',
  92          };
  93          unsigned char code Shifted[59][2] = {
  94          0x1C,'A',
  95          0x32,'B',
  96          0x21,'C',
  97          0x23,'D',
  98          0x24,'E',
  99          0x2B,'F',
 100          0x34,'G',
 101          0x33,'H',
 102          0x43,'I',
 103          0x3B,'J',
 104          0x42,'K',
 105          0x4B,'L',
 106          0x3A,'M',
 107          0x31,'N',
 108          0x44,'O',
 109          0x4D,'P',
 110          0x15,'Q',
 111          0x2D,'R',
 112          0x1B,'S',
 113          0x2C,'T',
 114          0x3C,'U',
 115          0x2A,'V',
 116          0x1D,'W',
 117          0x22,'X',
C51 COMPILER V7.00  TEST72                                                                 09/16/2012 15:52:35 PAGE 3   

 118          0x35,'Y',
 119          0x1A,'Z',
 120          
 121          0x45,')',
 122          0x16,'!',
 123          0x1E,'@',
 124          0x26,'#',
 125          0x25,'$',
 126          0x2E,'%',
 127          0x36,'^',
 128          0x3D,'&',
 129          0x3E,'*',
 130          0x46,'(',        
 131            
 132          0x4e,'_',
 133          0x4E,'_',
 134          0x55,'+',
 135          0x5D,'|',
 136          0x29,' ',
 137          0x29,' ',
 138          0x29,' ',
 139          0x4C,':',
 140          0x29,' ',
 141          0x41,'<',
 142          0x49,'>',
 143          0x4A,'?',
 144          0x71,'.',
 145          
 146          0x70,'0',
 147          0x69,'1',
 148          0x72,'2',
 149          0x7A,'3',
 150          0x6B,'4',
 151          0x73,'5',
 152          0x74,'6',
 153          0x6C,'7',
 154          0x75,'8',
 155          0x7D,'9',
 156          };
 157          
 158          //---------------------------------------
 159          //名称：键处理函数      
 160          //适用：给力者GL9单片机开发学习系统
 161          //公司：宁波芯动电子有限公司
 162          //网址：www.MovingChip.com
 163          //日期：20120916
 164          //---------------------------------------
 165          unsigned char  Decode(unsigned char ScanCode)
 166          //注意:如SHIFT+G为12H 34H F0H 34H F0H 12H?
 167          //也就是说shift的通码+G的通码+shift的断码+G的断码
 168          {
 169   1              unsigned char TempCyc; 
 170   1              unsigned char KeyChar=0;
 171   1              if (!Key_UP) //当键盘松开时
 172   1              {
 173   2                      switch (ScanCode)
 174   2                      {
 175   3                              case 0xF0 : // 当收到0xF0，Key_UP置1表示断码开始
 176   3                              Key_UP = 1;
 177   3                      break;
 178   3      
 179   3                              case 0x12 : // 左 SHIFT
C51 COMPILER V7.00  TEST72                                                                 09/16/2012 15:52:35 PAGE 4   

 180   3                              Shift = 1;
 181   3                      break;
 182   3      
 183   3                              case 0x59 : // 右 SHIFT
 184   3                              Shift = 1;
 185   3                  break;
 186   3                              case 0x66:  //backspace
 187   3                                      if(weizhi>0)
 188   3                                      {
 189   4                                              weizhi--;
 190   4                                              disbuf[weizhi]=0x20;
 191   4                                              disbit=1;
 192   4                                      }
 193   3                              break;
 194   3                              default: 
 195   3                              if (DisNum > 15) DisNum = 0; 
 196   3                              if(!Shift) //如果SHIFT没按下
 197   3                              {
 198   4                                      for (TempCyc = 0;(UnShifted[TempCyc][0]!=ScanCode)&&(TempCyc<59); TempCyc++); //查表显示
 199   4                                      if (UnShifted[TempCyc][0] == ScanCode) 
 200   4                                              {
 201   5                              KeyChar=UnShifted[TempCyc][1];  
 202   5                                                      disbit=1;
 203   5                                                      disbuf[weizhi]=KeyChar;
 204   5                                                      if(++weizhi>31) 
 205   5                                                      {
 206   6                                                              for(weizhi=0;weizhi<32;weizhi++) disbuf[weizhi]=0x20;
 207   6                                                              weizhi=0;
 208   6                                                      }
 209   5                                              }                               
 210   4                                      DisNum++;
 211   4                              } 
 212   3                              else //按下SHIFT
 213   3                              {
 214   4                                      for(TempCyc = 0; (Shifted[TempCyc][0]!=ScanCode)&&(TempCyc<59); TempCyc++); //查表显示
 215   4                                      if (Shifted[TempCyc][0] == ScanCode) 
 216   4                                              {
 217   5                              KeyChar=Shifted[TempCyc][1];
 218   5                                                      disbit=1;
 219   5                                                      disbuf[weizhi]=KeyChar;
 220   5                                                      if(++weizhi>31) 
 221   5                                                      {
 222   6                                                              for(weizhi=0;weizhi<32;weizhi++) disbuf[weizhi]=0x20;
 223   6                                                              weizhi=0;
 224   6                                                      }
 225   5                                              }
 226   4                                      DisNum++;
 227   4                              }
 228   3                      break;
 229   3              }
 230   2              }
 231   1              else
 232   1              { 
 233   2                      Key_UP = 0;
 234   2                      switch (ScanCode) //当键松开时不处理判码，如G 34H F0H 34H 那么第二个34H不会被处理
 235   2                      {
 236   3                              case 0x12 : // 左 SHIFT
 237   3                              Shift = 0;
 238   3                      break;
 239   3                              case 0x59 : // 右 SHIFT
 240   3                              Shift = 0;
 241   3                      break;
C51 COMPILER V7.00  TEST72                                                                 09/16/2012 15:52:35 PAGE 5   

 242   3                      }
 243   2              }
 244   1              return KeyChar;
 245   1      }       
 246          //---------------------------------------
 247          //名称：键盘扫描函数
 248          //适用：给力者GL9单片机开发学习系统
 249          //公司：宁波芯动电子有限公司
 250          //网址：www.MovingChip.com
 251          //日期：20120916
 252          //--------------------------------------- 
 253          void scakey()
 254          {               
 255   1              if (BF)
 256   1              {                               
 257   2                      Decode(keybuf);
 258   2                      BF=0;
 259   2                      EX1=0;  
 260   2                      EA=1;           
 261   2              }
 262   1              else
 263   1              EX1 = 1; //开中断               
 264   1      } 
 265          
 266          //---------------------------------------
 267          //名称：外部INT1中断服务程序
 268          //适用：给力者GL9单片机开发学习系统
 269          //公司：宁波芯动电子有限公司
 270          //网址：www.MovingChip.com
 271          //日期：20120916
 272          //---------------------------------------
 273          void INIT1(void) interrupt 2 
 274          {
 275   1      
 276   1          //***此处用户自行添加外部INT1中断处理程序***
 277   1              if ((IntNum > 0) && (IntNum < 9))
 278   1              { 
 279   2                      KeyV = KeyV >> 1; //因键盘数据是低>>高，结合上一句所以右移一位
 280   2                      if (Key_Data) KeyV = KeyV | 0x80; //当键盘数据线为1时为1到最高位
 281   2              }
 282   1              IntNum++;
 283   1              while (!Key_CLK); //等待PS/2CLK拉高
 284   1              if (IntNum > 10)
 285   1              {
 286   2                      IntNum = 0; //当中断11次后表示一帧数据收完，清变量准备下一次接收
 287   2                      BF = 1; //标识有字符输入完了 
 288   2                      keybuf=KeyV;
 289   2                      KeyV=0;                 
 290   2              }
 291   1          //******************************************
 292   1      }
 293          
 294          //---------------------------------------
 295          //名称：1602液晶用延时函数
 296          //适用：给力者GL9单片机开发学习系统
 297          //公司：宁波芯动电子有限公司
 298          //网址：www.MovingChip.com
 299          //日期：20120916
 300          //---------------------------------------
 301          void Delay1602(unsigned int t)
 302          { 
 303   1           unsigned int k;      //定义一个16位寄存器用来做延时用 
C51 COMPILER V7.00  TEST72                                                                 09/16/2012 15:52:35 PAGE 6   

 304   1           for(k=0;k<t;k++);    //延时 
 305   1      } 
 306          
 307          //---------------------------------------
 308          //名称：1602液晶忙检测函数
 309          //适用：给力者GL9单片机开发学习系统
 310          //公司：宁波芯动电子有限公司
 311          //网址：www.MovingChip.com
 312          //日期：20120916
 313          //---------------------------------------
 314          void LCD1602_busy(void)
 315          { 
 316   1           P0_7=1;              //将P0.7置1，为读状态做准备 
 317   1           RS=0;                //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
 318   1           RW=1;                //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
 319   1           E=1;                 //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
 320   1           while(P0_7==1);      //由P0.7读入1，表示1602液晶忙，需要等待
 321   1           E=0;                 //读完以后，恢复E的电平
 322   1      } 
 323          
 324          //---------------------------------------
 325          //名称：1600写命令函数
 326          //适用：给力者GL9单片机开发学习系统
 327          //公司：宁波芯动电子有限公司
 328          //网址：www.MovingChip.com
 329          //日期：20120916
 330          //---------------------------------------
 331          void LCD1602_Write_com(unsigned char combuf)
 332          { 
 333   1           RS=0;                //选择指令寄存器
 334   1           RW=0;                //选择写状态
 335   1           P0=combuf;           //将命令字通过P0口送至DB
 336   1           E=1;                 //E高电平将命令字写入1602液晶
 337   1           E=0;                 //写完以后，恢复E的电平
 338   1      } 
 339          
 340          //---------------------------------------
 341          //名称：1602写命令函数(带忙检测)
 342          //适用：给力者GL9单片机开发学习系统
 343          //公司：宁波芯动电子有限公司
 344          //网址：www.MovingChip.com
 345          //日期：20120916
 346          //---------------------------------------
 347          void LCD1602_Write_com_busy(unsigned char combuf)
 348          { 
 349   1           LCD1602_busy();            //调用忙检测函数
 350   1           LCD1602_Write_com(combuf); //调用忙检测函数
 351   1      } 
 352          
 353          //---------------------------------------
 354          //名称：1602写数据函数(带忙检测)
 355          //适用：给力者GL9单片机开发学习系统
 356          //公司：宁波芯动电子有限公司
 357          //网址：www.MovingChip.com
 358          //日期：20120916
 359          //---------------------------------------
 360          void LCD1602_Write_data_busy(unsigned char databuf)
 361          { 
 362   1           LCD1602_busy();      //调用忙检测函数
 363   1           RS=1;                //选择数据寄存器
 364   1           RW=0;                //选择写状态
 365   1           P0=databuf;          //将命令字通过P0口送至DB
C51 COMPILER V7.00  TEST72                                                                 09/16/2012 15:52:35 PAGE 7   

 366   1           E=1;                 //E高电平将命令字写入1602液晶
 367   1           E=0;                 //写完以后，恢复E的电平
 368   1      } 
 369          
 370          //---------------------------------------
 371          //名称：1602液晶显示地址写函数
 372          //适用：给力者GL9单片机开发学习系统
 373          //公司：宁波芯动电子有限公司
 374          //网址：www.MovingChip.com
 375          //日期：20120916
 376          //---------------------------------------
 377          void LCD1602_Write_address(unsigned char x,unsigned char y)
 378          { 
 379   1           x&=0x0f;             //列地址限制在0-15间
 380   1           y&=0x01;             //行地址限制在0-1间
 381   1           if(y==0)             //如果是第一行
 382   1               LCD1602_Write_com_busy(x|0x80);        //将列地址写入
 383   1           else                 //如果是第二行
 384   1               LCD1602_Write_com_busy((x+0x40)|0x80); //将列地址写入
 385   1      } 
 386          
 387          //---------------------------------------
 388          //名称：1602液晶初始化函数
 389          //适用：给力者GL9单片机开发学习系统
 390          //公司：宁波芯动电子有限公司
 391          //网址：www.MovingChip.com
 392          //日期：20120916
 393          //---------------------------------------
 394          void LCD1602_init(void)
 395          { 
 396   1           Delay1602(1500);               //调用延时函数
 397   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
 398   1           Delay1602(500);                //调用延时函数
 399   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
 400   1           Delay1602(500);                //调用延时函数
 401   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
 402   1           LCD1602_Write_com_busy(0x38);  //8位数据总线，两行显示模式，5*7点阵显示
 403   1           LCD1602_Write_com_busy(0x08);  //显示功能关，无光标
 404   1           LCD1602_Write_com_busy(0x01);  //清屏
 405   1           LCD1602_Write_com_busy(0x06);  //写入新的数据后，光标右移，显示屏不移动
 406   1           LCD1602_Write_com_busy(0x0C);  //显示功能开，无光标
 407   1      } 
 408          
 409          //---------------------------------------
 410          //名称：1602液晶指定地址显示函数
 411          //适用：给力者GL9单片机开发学习系统
 412          //公司：宁波芯动电子有限公司
 413          //网址：www.MovingChip.com
 414          //日期：20120916
 415          //---------------------------------------
 416          void LCD1602_Disp(unsigned char x,unsigned char y,unsigned char buf)
 417          { 
 418   1           LCD1602_Write_address(x,y);    //先将地址信息写入
 419   1           LCD1602_Write_data_busy(buf);  //再写入要显示的数据
 420   1      } 
 421          
 422          //---------------------------------------
 423          //名称: 主函数
 424          //适用：给力者GL9单片机开发学习系统
 425          //公司：宁波芯动电子有限公司
 426          //网址：www.MovingChip.com
 427          //日期：20120916
C51 COMPILER V7.00  TEST72                                                                 09/16/2012 15:52:35 PAGE 8   

 428          //---------------------------------------
 429          void main(void)            //主函数,单片机开机后就是从这个函数开始运行
 430          {
 431   1              unsigned char k,l;
 432   1          LCD1602_init();        //调用1602液晶初始化函数
 433   1                      
 434   1          //***外部中断INT1初始化***
 435   1          IT1=1;                 //下降沿触发方式
 436   1          EX1=1;                 //外部INT1中断允许
 437   1          //**********************
 438   1      
 439   1          //***开全局中断设置****
 440   1          //外部中断INT1设置了中断允许,此处要开全局中断
 441   1          EA=1;                  //开全局中断
 442   1          //*********************
 443   1      
 444   1              for(weizhi=0;weizhi<32;weizhi++) disbuf[weizhi]=0x20;
 445   1              weizhi=0;
 446   1              while(1)
 447   1              {        
 448   2                      scakey();
 449   2                      if(disbit)
 450   2                      {
 451   3                              disbit=0;
 452   3                              LCD1602_init();
 453   3                              for(k=0;k<2;k++)
 454   3                              {
 455   4                                      for(l=0;l<16;l++)
 456   4                                      {
 457   5                                              LCD1602_Disp(l,k,disbuf[k*14+l]);   //                                  
 458   5                                      }
 459   4                              }
 460   3                      }                                       
 461   2              }
 462   1      }
 463          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    592    ----
   CONSTANT SIZE    =    234    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     39       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\stm32f10x_i2c.o --depend=.\Obj\stm32f10x_i2c.d --device=DARMSTM --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\Core\CM3 -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\Obj\stm32f10x_i2c.crf ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;785      */
;;;786    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;787    {
;;;788      /* Check the parameters */
;;;789      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;790      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;791      if (NewState != DISABLE)
;;;792      {
;;;793        /* Enable the selected I2C ARP */
;;;794        I2Cx->CR1 |= CR1_ENARP_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L1.12|
000006  f0410110          ORR      r1,r1,#0x10
00000a  e001              B        |L1.16|
                  |L1.12|
;;;795      }
;;;796      else
;;;797      {
;;;798        /* Disable the selected I2C ARP */
;;;799        I2Cx->CR1 &= CR1_ENARP_Reset;
00000c  f0210110          BIC      r1,r1,#0x10
                  |L1.16|
000010  8001              STRH     r1,[r0,#0]            ;794
;;;800      }
;;;801    }
000012  4770              BX       lr
;;;802    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;438      */
;;;439    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;440    {
;;;441      /* Check the parameters */
;;;442      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;443      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;444      if (NewState != DISABLE)
;;;445      {
;;;446        /* Enable the acknowledgement */
;;;447        I2Cx->CR1 |= CR1_ACK_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  f4416180          ORR      r1,r1,#0x400
00000a  e001              B        |L2.16|
                  |L2.12|
;;;448      }
;;;449      else
;;;450      {
;;;451        /* Disable the acknowledgement */
;;;452        I2Cx->CR1 &= CR1_ACK_Reset;
00000c  f4216180          BIC      r1,r1,#0x400
                  |L2.16|
000010  8001              STRH     r1,[r0,#0]            ;447
;;;453      }
;;;454    }
000012  4770              BX       lr
;;;455    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;748      */
;;;749    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;750    {
;;;751      /* Check the parameters */
;;;752      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;753      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;754      if (NewState != DISABLE)
;;;755      {
;;;756        /* Enable the selected I2C PEC calculation */
;;;757        I2Cx->CR1 |= CR1_ENPEC_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410120          ORR      r1,r1,#0x20
00000a  e001              B        |L3.16|
                  |L3.12|
;;;758      }
;;;759      else
;;;760      {
;;;761        /* Disable the selected I2C PEC calculation */
;;;762        I2Cx->CR1 &= CR1_ENPEC_Reset;
00000c  f0210120          BIC      r1,r1,#0x20
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;757
;;;763      }
;;;764    }
000012  4770              BX       lr
;;;765    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;893      */
;;;894    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  4602              MOV      r2,r0
;;;895    {
;;;896      uint32_t lastevent = 0;
;;;897      uint32_t flag1 = 0, flag2 = 0;
;;;898      ErrorStatus status = ERROR;
;;;899      /* Check the parameters */
;;;900      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;901      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;902      /* Read the I2Cx status register */
;;;903      flag1 = I2Cx->SR1;
000002  8a93              LDRH     r3,[r2,#0x14]
000004  2000              MOVS     r0,#0                 ;898
;;;904      flag2 = I2Cx->SR2;
000006  8b12              LDRH     r2,[r2,#0x18]
;;;905      flag2 = flag2 << 16;
;;;906      /* Get the last event value from I2C status register */
;;;907      lastevent = (flag1 | flag2) & FLAG_Mask;
000008  ea434302          ORR      r3,r3,r2,LSL #16
00000c  f023427f          BIC      r2,r3,#0xff000000
;;;908      /* Check whether the last event is equal to I2C_EVENT */
;;;909      if (lastevent == I2C_EVENT )
000010  428a              CMP      r2,r1
000012  d100              BNE      |L4.22|
;;;910      {
;;;911        /* SUCCESS: last event is equal to I2C_EVENT */
;;;912        status = SUCCESS;
000014  2001              MOVS     r0,#1
                  |L4.22|
;;;913      }
;;;914      else
;;;915      {
;;;916        /* ERROR: last event is different from I2C_EVENT */
;;;917        status = ERROR;
;;;918      }
;;;919      /* Return status */
;;;920      return status;
;;;921    }
000016  4770              BX       lr
;;;922    
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1026     */
;;;1027   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1028   {
;;;1029     uint32_t flagpos = 0;
;;;1030     /* Check the parameters */
;;;1031     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1032     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1033     /* Get the I2C flag position */
;;;1034     flagpos = I2C_FLAG & FLAG_Mask;
;;;1035     /* Clear the selected I2C flag */
;;;1036     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1037   }
000004  4770              BX       lr
;;;1038   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1117     */
;;;1118   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1119   {
;;;1120     uint32_t flagpos = 0;
;;;1121     /* Check the parameters */
;;;1122     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1123     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1124     /* Get the I2C flag position */
;;;1125     flagpos = I2C_IT & FLAG_Mask;
;;;1126     /* Clear the selected I2C flag */
;;;1127     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1128   }
000004  4770              BX       lr
;;;1129   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;318      */
;;;319    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;320    {
;;;321      /* Check the parameters */
;;;322      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;323      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;324      if (NewState != DISABLE)
;;;325      {
;;;326        /* Enable the selected I2C peripheral */
;;;327        I2Cx->CR1 |= CR1_PE_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1
00000a  e001              B        |L7.16|
                  |L7.12|
;;;328      }
;;;329      else
;;;330      {
;;;331        /* Disable the selected I2C peripheral */
;;;332        I2Cx->CR1 &= CR1_PE_Reset;
00000c  f0210101          BIC      r1,r1,#1
                  |L7.16|
000010  8001              STRH     r1,[r0,#0]            ;327
;;;333      }
;;;334    }
000012  4770              BX       lr
;;;335    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;342      */
;;;343    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;344    {
;;;345      /* Check the parameters */
;;;346      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;347      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;348      if (NewState != DISABLE)
;;;349      {
;;;350        /* Enable the selected I2C DMA requests */
;;;351        I2Cx->CR2 |= CR2_DMAEN_Set;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L8.12|
000006  f4416100          ORR      r1,r1,#0x800
00000a  e001              B        |L8.16|
                  |L8.12|
;;;352      }
;;;353      else
;;;354      {
;;;355        /* Disable the selected I2C DMA requests */
;;;356        I2Cx->CR2 &= CR2_DMAEN_Reset;
00000c  f4216100          BIC      r1,r1,#0x800
                  |L8.16|
000010  8081              STRH     r1,[r0,#4]            ;351
;;;357      }
;;;358    }
000012  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;366      */
;;;367    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;371      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;372      if (NewState != DISABLE)
;;;373      {
;;;374        /* Next DMA transfer is the last transfer */
;;;375        I2Cx->CR2 |= CR2_LAST_Set;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L9.12|
000006  f4415180          ORR      r1,r1,#0x1000
00000a  e001              B        |L9.16|
                  |L9.12|
;;;376      }
;;;377      else
;;;378      {
;;;379        /* Next DMA transfer is not the last transfer */
;;;380        I2Cx->CR2 &= CR2_LAST_Reset;
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L9.16|
000010  8081              STRH     r1,[r0,#4]            ;375
;;;381      }
;;;382    }
000012  4770              BX       lr
;;;383    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;161      */
;;;162    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  490a              LDR      r1,|L10.44|
;;;163    {
000002  b510              PUSH     {r4,lr}
;;;164      /* Check the parameters */
;;;165      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;166      switch (*(uint32_t*)&I2Cx)
000004  1840              ADDS     r0,r0,r1
000006  d00d              BEQ      |L10.36|
000008  f5b06f80          CMP      r0,#0x400
00000c  d10d              BNE      |L10.42|
;;;167      {
;;;168        case I2C1_BASE:
;;;169          /* Enable I2C1 reset state */
;;;170          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;171          /* Release I2C1 from reset state */
;;;172          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;173          break;
;;;174        case I2C2_BASE:
;;;175          /* Enable I2C2 reset state */
;;;176          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00000e  2101              MOVS     r1,#1
000010  058c              LSLS     r4,r1,#22
                  |L10.18|
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;177          /* Release I2C2 from reset state */
;;;178          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
000018  4620              MOV      r0,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  2100              MOVS     r1,#0
000020  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L10.36|
000024  2101              MOVS     r1,#1                 ;170
000026  054c              LSLS     r4,r1,#21             ;170
000028  e7f3              B        |L10.18|
                  |L10.42|
;;;179          break;
;;;180        default:
;;;181          break;
;;;182      }
;;;183    }
00002a  bd10              POP      {r4,pc}
;;;184    
                          ENDP

                  |L10.44|
                          DCD      0xbfffac00

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;483      */
;;;484    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;485    {
;;;486      /* Check the parameters */
;;;487      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;488      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;489      if (NewState != DISABLE)
;;;490      {
;;;491        /* Enable dual addressing mode */
;;;492        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L11.12|
000006  f0410101          ORR      r1,r1,#1
00000a  e001              B        |L11.16|
                  |L11.12|
;;;493      }
;;;494      else
;;;495      {
;;;496        /* Disable dual addressing mode */
;;;497        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
00000c  f0210101          BIC      r1,r1,#1
                  |L11.16|
000010  8181              STRH     r1,[r0,#0xc]          ;492
;;;498      }
;;;499    }
000012  4770              BX       lr
;;;500    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;835      */
;;;836    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;837    {
;;;838      /* Check the parameters */
;;;839      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;840      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;841      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;842      {
;;;843        /* I2C fast mode Tlow/Thigh=2 */
;;;844        I2Cx->CCR &= I2C_DutyCycle_2;
000004  8b81              LDRH     r1,[r0,#0x1c]
000006  d002              BEQ      |L12.14|
000008  f4214180          BIC      r1,r1,#0x4000
00000c  e001              B        |L12.18|
                  |L12.14|
;;;845      }
;;;846      else
;;;847      {
;;;848        /* I2C fast mode Tlow/Thigh=16/9 */
;;;849        I2Cx->CCR |= I2C_DutyCycle_16_9;
00000e  f4414180          ORR      r1,r1,#0x4000
                  |L12.18|
000012  8381              STRH     r1,[r0,#0x1c]         ;844
;;;850      }
;;;851    }
000014  4770              BX       lr
;;;852    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;507      */
;;;508    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;509    {
;;;510      /* Check the parameters */
;;;511      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;512      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;513      if (NewState != DISABLE)
;;;514      {
;;;515        /* Enable generall call */
;;;516        I2Cx->CR1 |= CR1_ENGC_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L13.12|
000006  f0410140          ORR      r1,r1,#0x40
00000a  e001              B        |L13.16|
                  |L13.12|
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Disable generall call */
;;;521        I2Cx->CR1 &= CR1_ENGC_Reset;
00000c  f0210140          BIC      r1,r1,#0x40
                  |L13.16|
000010  8001              STRH     r1,[r0,#0]            ;516
;;;522      }
;;;523    }
000012  4770              BX       lr
;;;524    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;390      */
;;;391    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;392    {
;;;393      /* Check the parameters */
;;;394      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;395      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;396      if (NewState != DISABLE)
;;;397      {
;;;398        /* Generate a START condition */
;;;399        I2Cx->CR1 |= CR1_START_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L14.12|
000006  f4417180          ORR      r1,r1,#0x100
00000a  e001              B        |L14.16|
                  |L14.12|
;;;400      }
;;;401      else
;;;402      {
;;;403        /* Disable the START condition generation */
;;;404        I2Cx->CR1 &= CR1_START_Reset;
00000c  f4217180          BIC      r1,r1,#0x100
                  |L14.16|
000010  8001              STRH     r1,[r0,#0]            ;399
;;;405      }
;;;406    }
000012  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;414      */
;;;415    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;416    {
;;;417      /* Check the parameters */
;;;418      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;419      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;420      if (NewState != DISABLE)
;;;421      {
;;;422        /* Generate a STOP condition */
;;;423        I2Cx->CR1 |= CR1_STOP_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f4417100          ORR      r1,r1,#0x200
00000a  e001              B        |L15.16|
                  |L15.12|
;;;424      }
;;;425      else
;;;426      {
;;;427        /* Disable the STOP condition generation */
;;;428        I2Cx->CR1 &= CR1_STOP_Reset;
00000c  f4217100          BIC      r1,r1,#0x200
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;423
;;;429      }
;;;430    }
000012  4770              BX       lr
;;;431    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;951      */
;;;952    FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  4602              MOV      r2,r0
;;;953    {
;;;954      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;955      __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;956      /* Check the parameters */
;;;957      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;958      assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;959      /* Get the I2Cx peripheral base address */
;;;960      i2cxbase = (*(uint32_t*)&(I2Cx));
;;;961      
;;;962      /* Read flag register index */
;;;963      i2creg = I2C_FLAG >> 28;
000004  0f0b              LSRS     r3,r1,#28
;;;964      
;;;965      /* Get bit[23:0] of the flag */
;;;966      I2C_FLAG &= FLAG_Mask;
000006  f021417f          BIC      r1,r1,#0xff000000
;;;967      
;;;968      if(i2creg != 0)
00000a  d001              BEQ      |L16.16|
;;;969      {
;;;970        /* Get the I2Cx SR1 register address */
;;;971        i2cxbase += 0x14;
00000c  3214              ADDS     r2,r2,#0x14
00000e  e001              B        |L16.20|
                  |L16.16|
;;;972      }
;;;973      else
;;;974      {
;;;975        /* Flag in I2Cx SR2 Register */
;;;976        I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
000010  0c09              LSRS     r1,r1,#16
;;;977        /* Get the I2Cx SR2 register address */
;;;978        i2cxbase += 0x18;
000012  3218              ADDS     r2,r2,#0x18
                  |L16.20|
;;;979      }
;;;980      
;;;981      if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
000014  6812              LDR      r2,[r2,#0]
000016  420a              TST      r2,r1
000018  d000              BEQ      |L16.28|
;;;982      {
;;;983        /* I2C_FLAG is set */
;;;984        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L16.28|
;;;985      }
;;;986      else
;;;987      {
;;;988        /* I2C_FLAG is reset */
;;;989        bitstatus = RESET;
;;;990      }
;;;991      
;;;992      /* Return the I2C_FLAG status */
;;;993      return  bitstatus;
;;;994    }
00001c  4770              BX       lr
;;;995    
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1060     */
;;;1061   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1062   {
000002  4602              MOV      r2,r0
;;;1063     ITStatus bitstatus = RESET;
;;;1064     uint32_t enablestatus = 0;
;;;1065     /* Check the parameters */
;;;1066     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1067     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1068     /* Check if the interrupt source is enabled or not */
;;;1069     enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;  
000004  8893              LDRH     r3,[r2,#4]
000006  2000              MOVS     r0,#0                 ;1063
000008  f00164e0          AND      r4,r1,#0x7000000
;;;1070     /* Get bit[23:0] of the flag */
;;;1071     I2C_IT &= FLAG_Mask;
;;;1072     /* Check the status of the specified I2C flag */
;;;1073     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
00000c  8a92              LDRH     r2,[r2,#0x14]
00000e  f021417f          BIC      r1,r1,#0xff000000     ;1071
000012  ea034314          AND      r3,r3,r4,LSR #16      ;1069
000016  420a              TST      r2,r1
000018  d002              BEQ      |L17.32|
00001a  2b00              CMP      r3,#0
00001c  d000              BEQ      |L17.32|
;;;1074     {
;;;1075       /* I2C_IT is set */
;;;1076       bitstatus = SET;
00001e  2001              MOVS     r0,#1
                  |L17.32|
;;;1077     }
;;;1078     else
;;;1079     {
;;;1080       /* I2C_IT is reset */
;;;1081       bitstatus = RESET;
;;;1082     }
;;;1083     /* Return the I2C_IT status */
;;;1084     return  bitstatus;
;;;1085   }
000020  bd10              POP      {r4,pc}
;;;1086   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;857      */
;;;858    uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;859    {
;;;860      uint32_t lastevent = 0;
;;;861      uint32_t flag1 = 0, flag2 = 0;
;;;862      /* Check the parameters */
;;;863      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;864      /* Read the I2Cx status register */
;;;865      flag1 = I2Cx->SR1;
;;;866      flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;867      flag2 = flag2 << 16;
;;;868      /* Get the last event value from I2C status register */
;;;869      lastevent = (flag1 | flag2) & FLAG_Mask;
000004  ea414100          ORR      r1,r1,r0,LSL #16
000008  f021407f          BIC      r0,r1,#0xff000000
;;;870      /* Return status */
;;;871      return lastevent;
;;;872    }
00000c  4770              BX       lr
;;;873    
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;770      */
;;;771    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;772    {
;;;773      /* Check the parameters */
;;;774      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;775      /* Return the selected I2C PEC value */
;;;776      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;777    }
000004  4770              BX       lr
;;;778    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;537      */
;;;538    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;539    {
;;;540      /* Check the parameters */
;;;541      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;542      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;543      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;544      
;;;545      if (NewState != DISABLE)
;;;546      {
;;;547        /* Enable the selected I2C interrupts */
;;;548        I2Cx->CR2 |= I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  d001              BEQ      |L20.10|
000006  430a              ORRS     r2,r2,r1
000008  e000              B        |L20.12|
                  |L20.10|
;;;549      }
;;;550      else
;;;551      {
;;;552        /* Disable the selected I2C interrupts */
;;;553        I2Cx->CR2 &= (uint16_t)~I2C_IT;
00000a  438a              BICS     r2,r2,r1
                  |L20.12|
00000c  8082              STRH     r2,[r0,#4]            ;548
;;;554      }
;;;555    }
00000e  4770              BX       lr
;;;556    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;193      */
;;;194    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;195    {
000002  4604              MOV      r4,r0
;;;196      uint16_t tmpreg = 0, freqrange = 0;
;;;197      uint16_t result = 0x04;
;;;198      uint32_t pclk1 = 8000000;
;;;199      RCC_ClocksTypeDef  rcc_clocks;
;;;200      /* Check the parameters */
;;;201      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;202      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;203      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;204      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;205      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;206      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;207      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;208    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;209      /* Get the I2Cx CR2 value */
;;;210      tmpreg = I2Cx->CR2;
000004  8880              LDRH     r0,[r0,#4]
000006  b086              SUB      sp,sp,#0x18           ;195
000008  460d              MOV      r5,r1                 ;195
;;;211      /* Clear frequency FREQ[5:0] bits */
;;;212      tmpreg &= CR2_FREQ_Reset;
00000a  f020063f          BIC      r6,r0,#0x3f
;;;213      /* Get pclk1 frequency value */
;;;214      RCC_GetClocksFreq(&rcc_clocks);
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       RCC_GetClocksFreq
;;;215      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;216      /* Set frequency bits depending on pclk1 value */
;;;217      freqrange = (uint16_t)(pclk1 / 1000000);
000014  4926              LDR      r1,|L21.176|
000016  9803              LDR      r0,[sp,#0xc]
000018  fbb0f1f1          UDIV     r1,r0,r1
00001c  b289              UXTH     r1,r1
;;;218      tmpreg |= freqrange;
00001e  430e              ORRS     r6,r6,r1
;;;219      /* Write to I2Cx CR2 */
;;;220      I2Cx->CR2 = tmpreg;
000020  80a6              STRH     r6,[r4,#4]
;;;221    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;222      /* Disable the selected I2C peripheral to configure TRISE */
;;;223      I2Cx->CR1 &= CR1_PE_Reset;
000022  8822              LDRH     r2,[r4,#0]
000024  f0220201          BIC      r2,r2,#1
000028  8022              STRH     r2,[r4,#0]
;;;224      /* Reset tmpreg value */
;;;225      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;226      tmpreg = 0;
;;;227      /* Configure speed in standard mode */
;;;228      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00002a  4b22              LDR      r3,|L21.180|
00002c  68ea              LDR      r2,[r5,#0xc]
00002e  429a              CMP      r2,r3
000030  d81c              BHI      |L21.108|
;;;229      {
;;;230        /* Standard mode speed calculate */
;;;231        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000032  0052              LSLS     r2,r2,#1
000034  fbb0f0f2          UDIV     r0,r0,r2
000038  b280              UXTH     r0,r0
;;;232        /* Test if CCR value is under 0x4*/
;;;233        if (result < 0x04)
00003a  2804              CMP      r0,#4
00003c  d200              BCS      |L21.64|
;;;234        {
;;;235          /* Set minimum allowed value */
;;;236          result = 0x04;  
00003e  2004              MOVS     r0,#4
                  |L21.64|
;;;237        }
;;;238        /* Set speed value for standard mode */
;;;239        tmpreg |= result;	  
;;;240        /* Set Maximum Rise Time for standard mode */
;;;241        I2Cx->TRISE = freqrange + 1; 
000040  1c49              ADDS     r1,r1,#1
000042  8421              STRH     r1,[r4,#0x20]
;;;242      }
;;;243      /* Configure speed in fast mode */
;;;244      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;245      {
;;;246        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;247        {
;;;248          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;249          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;250        }
;;;251        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;252        {
;;;253          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;254          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;255          /* Set DUTY bit */
;;;256          result |= I2C_DutyCycle_16_9;
;;;257        }
;;;258        /* Test if CCR value is under 0x1*/
;;;259        if ((result & CCR_CCR_Set) == 0)
;;;260        {
;;;261          /* Set minimum allowed value */
;;;262          result |= (uint16_t)0x0001;  
;;;263        }
;;;264        /* Set speed value and set F/S bit for fast mode */
;;;265        tmpreg |= result | CCR_FS_Set;
;;;266        /* Set Maximum Rise Time for fast mode */
;;;267        I2Cx->TRISE = (uint16_t)(((freqrange * 300) / 1000) + 1);  
;;;268      }
;;;269      /* Write to I2Cx CCR */
;;;270      I2Cx->CCR = tmpreg;
000044  83a0              STRH     r0,[r4,#0x1c]
;;;271      /* Enable the selected I2C peripheral */
;;;272      I2Cx->CR1 |= CR1_PE_Set;
000046  8820              LDRH     r0,[r4,#0]
000048  f0400001          ORR      r0,r0,#1
00004c  8020              STRH     r0,[r4,#0]
;;;273    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;274      /* Get the I2Cx CR1 value */
;;;275      tmpreg = I2Cx->CR1;
00004e  8820              LDRH     r0,[r4,#0]
;;;276      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;277      tmpreg &= CR1_CLEAR_Mask;
000050  f64f31f5          MOV      r1,#0xfbf5
000054  4008              ANDS     r0,r0,r1
;;;278      /* Configure I2Cx: mode and acknowledgement */
;;;279      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;280      /* Set ACK bit according to I2C_Ack value */
;;;281      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000056  8829              LDRH     r1,[r5,#0]
000058  88ea              LDRH     r2,[r5,#6]
00005a  4311              ORRS     r1,r1,r2
00005c  4301              ORRS     r1,r1,r0
;;;282      /* Write to I2Cx CR1 */
;;;283      I2Cx->CR1 = tmpreg;
00005e  8021              STRH     r1,[r4,#0]
;;;284    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;285      /* Set I2Cx Own Address1 and acknowledged address */
;;;286      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
000060  8928              LDRH     r0,[r5,#8]
000062  88a9              LDRH     r1,[r5,#4]
000064  4308              ORRS     r0,r0,r1
000066  8120              STRH     r0,[r4,#8]
;;;287    }
000068  b006              ADD      sp,sp,#0x18
00006a  bd70              POP      {r4-r6,pc}
                  |L21.108|
00006c  886b              LDRH     r3,[r5,#2]            ;246
00006e  f5a3463f          SUB      r6,r3,#0xbf00         ;246
000072  3eff              SUBS     r6,r6,#0xff           ;246
000074  d105              BNE      |L21.130|
000076  eb020242          ADD      r2,r2,r2,LSL #1       ;249
00007a  fbb0f0f2          UDIV     r0,r0,r2              ;249
00007e  b280              UXTH     r0,r0                 ;249
000080  e008              B        |L21.148|
                  |L21.130|
000082  eb0203c2          ADD      r3,r2,r2,LSL #3       ;254
000086  eb031202          ADD      r2,r3,r2,LSL #4       ;254
00008a  fbb0f0f2          UDIV     r0,r0,r2              ;254
00008e  b280              UXTH     r0,r0                 ;254
000090  f4404080          ORR      r0,r0,#0x4000         ;256
                  |L21.148|
000094  0502              LSLS     r2,r0,#20             ;259
000096  d101              BNE      |L21.156|
000098  f0400001          ORR      r0,r0,#1              ;262
                  |L21.156|
00009c  f44f7296          MOV      r2,#0x12c             ;267
0000a0  4351              MULS     r1,r2,r1              ;267
0000a2  f44f727a          MOV      r2,#0x3e8             ;267
0000a6  fbb1f1f2          UDIV     r1,r1,r2              ;267
0000aa  f4404000          ORR      r0,r0,#0x8000         ;265
0000ae  e7c7              B        |L21.64|
;;;288    
                          ENDP

                  |L21.176|
                          DCD      0x000f4240
                  |L21.180|
                          DCD      0x000186a0

                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;461      */
;;;462    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;463    {
;;;464      uint16_t tmpreg = 0;
;;;465      /* Check the parameters */
;;;466      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;467      /* Get the old register value */
;;;468      tmpreg = I2Cx->OAR2;
;;;469      /* Reset I2Cx Own address2 bit [7:1] */
;;;470      tmpreg &= OAR2_ADD2_Reset;
;;;471      /* Set I2Cx Own address2 */
;;;472      tmpreg |= (uint16_t)(Address & (uint16_t)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  f02202fe          BIC      r2,r2,#0xfe           ;470
00000a  4311              ORRS     r1,r1,r2
;;;473      /* Store the new register value */
;;;474      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;475    }
00000e  4770              BX       lr
;;;476    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;723      */
;;;724    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;725    {
;;;726      /* Check the parameters */
;;;727      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;728      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;729      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;730      {
;;;731        /* Next byte in shift register is PEC */
;;;732        I2Cx->CR1 |= I2C_PECPosition_Next;
000004  8801              LDRH     r1,[r0,#0]
000006  d102              BNE      |L23.14|
000008  f4416100          ORR      r1,r1,#0x800
00000c  e001              B        |L23.18|
                  |L23.14|
;;;733      }
;;;734      else
;;;735      {
;;;736        /* Current byte in shift register is PEC */
;;;737        I2Cx->CR1 &= I2C_PECPosition_Current;
00000e  f4216100          BIC      r1,r1,#0x800
                  |L23.18|
000012  8001              STRH     r1,[r0,#0]            ;732
;;;738      }
;;;739    }
000014  4770              BX       lr
;;;740    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;629      */
;;;630    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  5a40              LDRH     r0,[r0,r1]
;;;631    {
;;;632      /* Check the parameters */
;;;633      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;634      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;635      /* Return the selected register value */
;;;636      return (*(__IO uint16_t *)(*((__IO uint32_t *)&I2Cx) + I2C_Register));
;;;637    }
000002  4770              BX       lr
;;;638    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;575      */
;;;576    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;577    {
;;;578      /* Check the parameters */
;;;579      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;580      /* Return the data in the DR register */
;;;581      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;582    }
000004  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;671      */
;;;672    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;673    {
;;;674      /* Check the parameters */
;;;675      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;676      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;677      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;678      {
;;;679        /* Drive the SMBusAlert pin Low */
;;;680        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000004  8801              LDRH     r1,[r0,#0]
000006  d102              BNE      |L26.14|
000008  f4415100          ORR      r1,r1,#0x2000
00000c  e001              B        |L26.18|
                  |L26.14|
;;;681      }
;;;682      else
;;;683      {
;;;684        /* Drive the SMBusAlert pin High  */
;;;685        I2Cx->CR1 &= I2C_SMBusAlert_High;
00000e  f4215100          BIC      r1,r1,#0x2000
                  |L26.18|
000012  8001              STRH     r1,[r0,#0]            ;680
;;;686      }
;;;687    }
000014  4770              BX       lr
;;;688    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;594      */
;;;595    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L27.8|
;;;596    {
;;;597      /* Check the parameters */
;;;598      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;599      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;600      /* Test on the direction to set/reset the read/write bit */
;;;601      if (I2C_Direction != I2C_Direction_Transmitter)
;;;602      {
;;;603        /* Set the address bit0 for read */
;;;604        Address |= OAR1_ADD0_Set;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L27.12|
                  |L27.8|
;;;605      }
;;;606      else
;;;607      {
;;;608        /* Reset the address bit0 for write */
;;;609        Address &= OAR1_ADD0_Reset;
000008  f00101fe          AND      r1,r1,#0xfe
                  |L27.12|
;;;610      }
;;;611      /* Send the address */
;;;612      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;613    }
00000e  4770              BX       lr
;;;614    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;562      */
;;;563    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;564    {
;;;565      /* Check the parameters */
;;;566      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;567      /* Write in the DR register the data to be sent */
;;;568      I2Cx->DR = Data;
;;;569    }
000002  4770              BX       lr
;;;570    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;645      */
;;;646    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;647    {
;;;648      /* Check the parameters */
;;;649      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;650      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;651      if (NewState != DISABLE)
;;;652      {
;;;653        /* Peripheral under reset */
;;;654        I2Cx->CR1 |= CR1_SWRST_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L29.12|
000006  f4414100          ORR      r1,r1,#0x8000
00000a  e001              B        |L29.16|
                  |L29.12|
;;;655      }
;;;656      else
;;;657      {
;;;658        /* Peripheral not under reset */
;;;659        I2Cx->CR1 &= CR1_SWRST_Reset;
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L29.16|
000010  8001              STRH     r1,[r0,#0]            ;654
;;;660      }
;;;661    }
000012  4770              BX       lr
;;;662    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;809      */
;;;810    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;811    {
;;;812      /* Check the parameters */
;;;813      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;814      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;815      if (NewState == DISABLE)
;;;816      {
;;;817        /* Enable the selected I2C Clock stretching */
;;;818        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d102              BNE      |L30.12|
000006  f0410180          ORR      r1,r1,#0x80
00000a  e001              B        |L30.16|
                  |L30.12|
;;;819      }
;;;820      else
;;;821      {
;;;822        /* Disable the selected I2C Clock stretching */
;;;823        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
00000c  f0210180          BIC      r1,r1,#0x80
                  |L30.16|
000010  8001              STRH     r1,[r0,#0]            ;818
;;;824      }
;;;825    }
000012  4770              BX       lr
;;;826    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;294      */
;;;295    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  2100              MOVS     r1,#0
;;;296    {
;;;297    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;298      /* Initialize the I2C_Mode member */
;;;299      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000002  8001              STRH     r1,[r0,#0]
;;;300      /* Initialize the I2C_DutyCycle member */
;;;301      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000004  f64b72ff          MOV      r2,#0xbfff
000008  8042              STRH     r2,[r0,#2]
;;;302      /* Initialize the I2C_OwnAddress1 member */
;;;303      I2C_InitStruct->I2C_OwnAddress1 = 0;
00000a  8081              STRH     r1,[r0,#4]
;;;304      /* Initialize the I2C_Ack member */
;;;305      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
00000c  80c1              STRH     r1,[r0,#6]
;;;306      /* Initialize the I2C_AcknowledgedAddress member */
;;;307      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00000e  f44f4180          MOV      r1,#0x4000
000012  8101              STRH     r1,[r0,#8]
;;;308      /* initialize the I2C_ClockSpeed member */
;;;309      I2C_InitStruct->I2C_ClockSpeed = 5000;
000014  f2413188          MOV      r1,#0x1388
;;;310    }
000018  60c1              STR      r1,[r0,#0xc]
00001a  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;695      */
;;;696    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;697    {
;;;698      /* Check the parameters */
;;;699      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;700      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;701      if (NewState != DISABLE)
;;;702      {
;;;703        /* Enable the selected I2C PEC transmission */
;;;704        I2Cx->CR1 |= CR1_PEC_Set;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L32.12|
000006  f4415180          ORR      r1,r1,#0x1000
00000a  e001              B        |L32.16|
                  |L32.12|
;;;705      }
;;;706      else
;;;707      {
;;;708        /* Disable the selected I2C PEC transmission */
;;;709        I2Cx->CR1 &= CR1_PEC_Reset;
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L32.16|
000010  8001              STRH     r1,[r0,#0]            ;704
;;;710      }
;;;711    }
000012  4770              BX       lr
;;;712    
                          ENDP


创建子程序 
・  是否检查过先决条件已经满足了？ 
・  定义子程序将要解决的问题了吗？ 
・  结构设计是否足够清楚，使得你可以给子程序起个好名字？ 
・  考虑过如何测试子程序了吗？ 
・  是否从模块化水平或者满足时间和内存要求角度考虑过效率问题？ 
・  是否查阅过参考书；以寻找有帮助的算法？ 
・  是否用详尽的PDL设计子程序？ 
・  在必要时，是否在逻辑设计步骤前考虑了数据？ 
・  是否检查过PDL，它很容易理解吗？ 
・  是否注意到了足以使你返回到结构设计阶段的警告（使用了全局数据，更适合其它子程序的操作，等等）。 
・  是否使用了PDL到代码流程，是否把PDL 作为编码基础并把原有的PDL 转为注释？ 
・  是否精确地把PDL翻译成了代码？ 
・  在作出假设时，验证它们了吗？ 
・  是从几个设计方案中选择了最好的，还是随意选择了一个方案？ 





・ 程序的名字让人困惑。Handlestuff（）能告诉我们程序是干什么的吗？
・ 程序没有被说明（关于说明的问题已经超出了个别子程序的范围，详见第19章“自我说明的子程序”）。
・ 子程序的布局不好。代码的物理组织形式几乎没有给出其逻辑组织形式的任何信息。
布局的使用过于随心所欲，程序每一部分的布局都是不一样的。关于这一点。只要比较一下ExpenseType=2 和ExpenseType=3 两个地方的风格就清楚了（关于布局问题，详见第十八章“布局与风格”）。
・ 子程序的输入变量值InPutRec 被改变过。如果它作为输入变量，那它的值就不该变化。如果要变化它的值，就不该称之为输入变量InputRec。
・ 子程序进行了全局变量的读写操作。它从CorpExpense 中读入变量并写给Profit。它应该与存取子程序通信，而不应直接读写全局变量。
・ 这个子程序的功用不是单一的。它初始化了某些变量。对一个数据库进行写操作，又进行了某些计算工作，而它们又看不出任何联系。一个子程序的功用应该是单一，明了的。
・ 子程序中没有采取预防非法数据的措施。如果CrntQtr的值为“0”，那么，表达式YTDRevenue*4.0／real(CrntQtr)就会出现被零除的错误。
・ 程序中使用了几个常数：100, 4.0, 12, 2和3。关于“神秘”（magic）数的问题见11.1节“常数”
第五章高质量子程序的特点47
・ 在程序中仅使用了域的CORP_DATA 型参数的两个域。如果仅仅使用两个域，那就该仅仅传入特定的域而不是整个结构化变量。
・ 子程序中的一些参数没有使用过。ScreenX 和ScreenY 在程序中没有涉及。
・ 程序中的一个参数被错误标定了。PrevColor被标定为变量型参数，然而在程序中又没有对其赋值。
・ 程序中的参数太多。程序中参数个数的合理上限应该是七个左右。而这个程序中则多达11个。程序中的参数多得怕人，恐怕没谁会仔细检查它们，而且连数一下都不愿意。
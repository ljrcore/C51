//**************************************************************************
//* 
//*   ADC12 Test Program for MSP430F149                      HeCh, 29.05.00
//* 
//*   This program uses ADC interrupts. As soon as a conversion is 
//*   finished an interrupt is generated. The transmission of the 
//*   conversion result is initiated in the Interrupt Service Routine.
//*   The conversion is triggered by the ADC12SC bit in the ADC12CLT1
//*   control register. As soon as this bit is set the sample&hold
//*   is started. The conversion is started automatical. One single
//*   sequence of channels (A0...A15) is converted. After the conversion
//*   of channel A15 and a wait loop the next conversion of a sequence 
//*   is triggered by setting again the ADC12SC bit.
//*
//*   If a conversion is finished an interrupt is generated and in the
//*   interrupt service routine the transmission of the conversion 
//*   result via the USART module is initiatd:
//*   ADC12MEM0 contains the input A0 conversion result,
//*   ADC12MEM1 contains the input A1 conversion result, and so on.
//*
//*   USART Settings:   4800 baud, 8 data bits, even parity, 1 stop bit
//* 
//**************************************************************************

#include "MSP430x14x.h"     // Standard Definition Control Register

#define ADCMEM ((int*) 0x0140)  // ADC12MEMx definition
//--------------------------------------------------------------------------
void Init(void);          // Initialization of System/Control Registers
void SendText(char Text[15]); // string is transmitted via RS232 
void SendADCMem(int MemX); // conversion result of ADCMemX is sent via RS232
int Digit0(int Register); // LSB nibble (digit 0) of Register is sent back
int Digit1(int Register); // middle nibble (digit 1) of Register is sent back
int Digit2(int Register); // MSB nibble (digit 2) of Register is sent back
int Hex2ASCII(int hex);   // conversion of hexadecimal number into ASCII
//--------------------------------------------------------------------------

void main(void)
{   unsigned int wait;

    Init();        // Initialization

    _EINT();       // enable global interrupts

    while (1)
    {  ADC12CTL0 |= 0x01;                // start sampling (trigger signal)
       for (wait=0;wait<=60000;wait++);  // wait loop
    }
}


void Init(void)
{    WDTCTL = WDTPW + WDTHOLD;        // Stop watchdog timer

/* USART Settings:
      UART function, Idle line multiprocessor Protocol,
      4800 baud, 8 data bits, even parity, 1 stop bit   */
     UCTL1 &=~ SWRST;          // reset SWRST bit
     UCTL1 = 0xD0;  
     UBR01 = 0x06;  
     UBR11 = 0x00;  
     UMCTL1 = 0x6F; 
     UTCTL1 = 0x10; 
     URCTL1 = 0x00;    
     ME2 |= 0x20;              // enable USART transmit

     P3SEL = 0x40;             // Pin P3.6 used by USART module
     P3DIR = 0x40;             // Pin P3.6 is output

/* ADC12 Settings: */     
     P6SEL = 0xFF;         // Pin P6 used by ADC module

     ADC12CTL0 &=~ 0x02;   // Disable conversion before changing
                           // the ADC12 settings!!!
                        /* selection of reference and input */
     ADC12MCTL0  = 0x00;    // Ref = AVss, AVcc; Input = A0
     ADC12MCTL1  = 0x01;    // Ref = AVss, AVcc; Input = A1
     ADC12MCTL2  = 0x02;    // Ref = AVss, AVcc; Input = A2
     ADC12MCTL3  = 0x03;    // Ref = AVss, AVcc; Input = A3          
     ADC12MCTL4  = 0x04;    // Ref = AVss, AVcc; Input = A4
     ADC12MCTL5  = 0x05;    // Ref = AVss, AVcc; Input = A5
     ADC12MCTL6  = 0x06;    // Ref = AVss, AVcc; Input = A6
     ADC12MCTL7  = 0x07;    // Ref = AVss, AVcc; Input = A7
     ADC12MCTL8  = 0x08;    // Ref = AVss, AVcc; Input = A8
     ADC12MCTL9  = 0x09;    // Ref = AVss, AVcc; Input = A9
     ADC12MCTL10 = 0x0A;    // Ref = AVss, AVcc; Input = A10
     ADC12MCTL11 = 0x0B;    // Ref = AVss, AVcc; Input = A11
     ADC12MCTL12 = 0x0C;    // Ref = AVss, AVcc; Input = A12
     ADC12MCTL13 = 0x0D;    // Ref = AVss, AVcc; Input = A13
     ADC12MCTL14 = 0x0E;    // Ref = AVss, AVcc; Input = A14
     ADC12MCTL15 = 0x8F;    // Ref = AVss, AVcc; Input = A15
                            // ADC12MCTL15 is end of sequence 
                            // (EOS bit is set!)

     ADC12CTL1 = 0x0202;    // first conv. result is stored in ADC12MEM0
                            // ADC12SC bit triggers Sample&Hold
                            // sample pulse is generated by Sampling Timer
                            // Clock Source: ADC12 internal oscillator
                            // Clock divider: 1
                            // conversion mode: one single sequence

     ADC12CTL0 = 0x009C;    // Sample&Hold Time 0
                            // Sample&Hold Time 1 
                            // Multiple Sample&Hold 
                            // reference voltage is off
                            // ADC12 module is switched on 
                            // Conversion Time Overflow interrupt enabled
                            // Overflow Interrupt enabled 

     ADC12IE = 0xFFFF;      // enable all ADC interrupts
     ADC12CTL0 |= 0x02;     // enable conversion
}



interrupt [ADC_VECTOR] void ADC12(void)   // ADC INTERRUPT HANDLER
{  char overflow[14]="Overflow!\r\0";
   char timing[21]="Timing!\r\0";

   switch (ADC12IV)
   {  case 0x00:      // No interrupt
               break;
      case 0x02:      // ADC overflow
               SendText(overflow);
               break;
      case 0x04:      // ADC timing overflow
               SendText(timing);
               break;
      case 0x06:      // ADC12MEM0 was loaded (ADC12IFG.0)
               SendADCMem(0);
               break;
      case 0x08:      // ADC12MEM1 was loaded (ADC12IFG.1)
               SendADCMem(1);
               break;
      case 0x0A:     // ADC12MEM2 was loaded (ADC12IFG.2)
               SendADCMem(2);
               break;
      case 0x0C:     // ADC12MEM3 was loaded (ADC12IFG.3)
               SendADCMem(3);
               break;
      case 0x0E:     // ADC12MEM4 was loaded (ADC12IFG.4)
               SendADCMem(4);
               break;
      case 0x10:     // ADC12MEM5 was loaded (ADC12IFG.5)
               SendADCMem(5);
               break;
      case 0x12:     // ADC12MEM6 was loaded (ADC12IFG.6)
               SendADCMem(6);
               break;
      case 0x14:     // ADC12MEM7 was loaded (ADC12IFG.7)
               SendADCMem(7);
               break;
      case 0x16:     // ADC12MEM8 was loaded (ADC12IFG.8)
               SendADCMem(8);
               break;
      case 0x18:     // ADC12MEM9 was loaded (ADC12IFG.9)
               SendADCMem(9);
               break;
      case 0x1A:     // ADC12MEM10 was loaded (ADC12IFG.10)
               SendADCMem(10);
               break;
      case 0x1C:     // ADC12MEM11 was loaded (ADC12IFG.11)
               SendADCMem(11);
               break;
      case 0x1E:     // ADC12MEM12 was loaded (ADC12IFG.12)
               SendADCMem(12);
               break;
      case 0x20:     // ADC12MEM13 was loaded (ADC12IFG.13)
               SendADCMem(13);
               break;
      case 0x22:     // ADC12MEM14 was loaded (ADC12IFG.14)
               SendADCMem(14);
               break;
      case 0x24:     // ADC12MEM15 was loaded (ADC12IFG.15)
               SendADCMem(15);
               break;
   }
}

/**************************************************************************/
/***************     RS232    S U B R O U T I N E S   *********************/
/**************************************************************************/
void SendText(char Text[15])
{  int i;

   i=0;
   while (Text[i]!='\0')         // transmit string via RS232
   {  TXBUF1=Text[i++];
      while ((UTCTL1&0x01)==0);    
   }
}

void SendADCMem(int MemX)
{  char prompt1[7]="ADCMEM\0";
   char prompt2='>';
   
   SendText(prompt1);           // transmit "ADCMEM" via RS232

   TXBUF1=Hex2ASCII(MemX);
   while ((UTCTL1&0x01)==0);    

   TXBUF1=prompt2;               // transmit ">" via RS232
   while ((UTCTL1&0x01)==0);    

   TXBUF1='0';                   // transmit "0"
   while ((UTCTL1&0x01)==0);   
   TXBUF1=Digit2(ADCMEM[MemX]);  // transmit digit 2 of ADC12MEMx
   while ((UTCTL1&0x01)==0);   
   TXBUF1=Digit1(ADCMEM[MemX]);  // transmit digit 1 of ADC12MEMx
   while ((UTCTL1&0x01)==0);   
   TXBUF1=Digit0(ADCMEM[MemX]);  // transmit digit 0 of ADC12MEMx
   while ((UTCTL1&0x01)==0);    
   TXBUF1=13;                    // send carriage return
   while ((UTCTL1&0x01)==0);    
}

int Digit0(int Register)         // return LSB nibble (digit 0)
{  int result;

   result = Hex2ASCII(0x0F & Register);
   return result;
}

int Digit1(int Register)         // return nibble (digit 1)
{  int result;

   result = Register >> 4;
   result = Hex2ASCII(0x0F & result);
   return result;
}

int Digit2(int Register)         // return MSB nibble (digit 2)
{  int result;

   result = Register >> 8;
   result = Hex2ASCII(0x0F & result);
   return result;
}

int Hex2ASCII(int hex)        // hexadecimal to ASCII conversion
{  int result;

   if (hex<=9) 
   {  result=hex+'0'; }       // convert number
   else
   {  result=hex+('A'-10); }  // convert letter 
   
   return result;
}
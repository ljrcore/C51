C51 COMPILER V7.00  TEST89                                                                 02/19/2014 10:35:30 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE TEST89
OBJECT MODULE PLACED IN TEST89.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE TEST89.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          ////////////////////////////////////////////////////////////////////////////
   2          //                给力者单片机开发学习系统，开发学习都给力！              //
   3          ////////////////////////////////////////////////////////////////////////////
   4          //                     学习51单片机，其实可以很简单                       //
   5          ////////////////////////////////////////////////////////////////////////////
   6          //                宁波芯动电子有限公司  www.MovingChip.com                //
   7          ////////////////////////////////////////////////////////////////////////////
   8          
   9          #include <AT89X52.h>       //调用51单片机的头文件
  10          #include <Intrins.h>       //因本例需要使用空操作，必须调用这个头文件
  11          
  12          //---------------------------------------
  13          //数码管字形表，供显示时查询
  14          unsigned char code LED[10]=
  15          {                          //定义表格一定要使用code，这样会做到程序存储区中
  16              0x3F,                  //"0"的字形表，0B00111111
  17              0x06,                  //"1"的字形表，0B00000110
  18              0x5B,                  //"2"的字形表，0B01011011
  19              0x4F,                  //"3"的字形表，0B01001111
  20              0x66,                  //"4"的字形表，0B01100110
  21              0x6D,                  //"5"的字形表，0B01101101
  22              0x7D,                  //"6"的字形表，0B01111101
  23              0x07,                  //"7"的字形表，0B00000111
  24              0x7F,                  //"8"的字形表，0B01111111
  25              0x6F,                  //"9"的字形表，0B01101111
  26          };
  27          
  28          //---------------------------------------
  29          //4位数码管相关I/O设置
  30          sbit U16A0=P0^0;           //U16(74HC138)的A0脚接在P0.0口上
  31          sbit U16A1=P0^1;           //U16(74HC138)的A1脚接在P0.1口上
  32          sbit U16A2=P0^2;           //U16(74HC138)的A2脚接在P0.2口上
  33          //---------------------------------------
  34          
  35          //---------------------------------------
  36          //软件模拟IIC相关I/O设置
  37          sbit SCL=P1^1;             //PCF8563T的 SCL 引脚接于单片机的P1^1引脚上
  38          sbit SDA=P1^0;             //PCF8563T的 SDA 引脚接于单片机的P1^0引脚上
  39          //---------------------------------------
  40          
  41          //---------------------------------------
  42          //PCF8563转换用寄存器设置
  43          unsigned char PCFbuf1;      //设置8位的寄存器用来暂存读出时钟参数
  44          unsigned char PCFbuf2;      //设置8位的寄存器用来暂存读出时钟参数
  45          bit Secondbit;
  46          //---------------------------------------
  47          
  48          //---------------------------------------
  49          //名称：IIC启动信号函数
  50          //适用：给力者GL9单片机开发学习系统
  51          //公司：宁波芯动电子有限公司
  52          //网址：www.MovingChip.com
  53          //日期：20140219
  54          //---------------------------------------
  55          void IICstart(void)
C51 COMPILER V7.00  TEST89                                                                 02/19/2014 10:35:30 PAGE 2   

  56          { 
  57   1           SDA=1;                //先将SDA=1，以准备在SCL=1时，将SDA=0
  58   1           SCL=1;                //时钟总线拉高 
  59   1           _nop_();              //略做延时
  60   1           _nop_();              //略做延时
  61   1           SDA=0;                //SCL=1时，将SDA拉低即产生启动信号 
  62   1           _nop_();              //略做延时
  63   1           _nop_();              //略做延时
  64   1           SCL=0;                //将SCL=0，完成启动信号操作 
  65   1      } 
  66          
  67          //---------------------------------------
  68          //名称：IIC停止信号函数
  69          //适用：给力者GL9单片机开发学习系统
  70          //公司：宁波芯动电子有限公司
  71          //网址：www.MovingChip.com
  72          //日期：20140219
  73          //---------------------------------------
  74          void IICstop(void)
  75          { 
  76   1           SDA=0;                //先将SDA=0，以准备在SCL=1时，将SDA=1
  77   1           SCL=1;                //时钟总线拉高 
  78   1           _nop_();              //略做延时
  79   1           _nop_();              //略做延时
  80   1           SDA=1;                //SCL=1时，将SDA拉高即产生停止信号 
  81   1           _nop_();              //略做延时
  82   1           _nop_();              //略做延时
  83   1           SCL=0;                //将SCL=0，完成启动信号操作 
  84   1      } 
  85          
  86          //---------------------------------------
  87          //名称：向IIC总线写入1个字节函数
  88          //适用：给力者GL9单片机开发学习系统
  89          //公司：宁波芯动电子有限公司
  90          //网址：www.MovingChip.com
  91          //日期：20140219
  92          //---------------------------------------
  93          void Write1Byte(unsigned char Buf1)
  94          { 
  95   1           unsigned char k;      //1个字节要分8次写入，需要定义一个寄存器用来计数
  96   1           for(k=0;k<8;k++)      //做一个8次的循环，每次写入1位，需要写8次
  97   1           {
  98   2               if(Buf1&0x80)     //从最高位开始写 
  99   2               {
 100   3                   SDA=1;        //如果欲写入数据为1，就将数据线置1
 101   3               }
 102   2               else
 103   2               {
 104   3                   SDA=0;        //如果欲写入数据为0，就将数据线写0 
 105   3               }
 106   2               _nop_();          //略做延时
 107   2               _nop_();          //略做延时
 108   2               SCL=1;            //时钟线做一个上升沿，将一位数据写入
 109   2               Buf1=Buf1<<1;     //数据左移一位，将下次要写入的位数据移到最高位
 110   2               _nop_();          //略做延时
 111   2               SCL=0;            //将SCL=0，以准备通过上升沿将数据写入
 112   2               _nop_();          //略做延时
 113   2           }
 114   1           SDA=1;                //将SDA=1，准备读应答信号
 115   1           _nop_();              //略做延时
 116   1           SCL=1;                //将SCL=1，做个上升沿准备读应答信号
 117   1           _nop_();              //略做延时
C51 COMPILER V7.00  TEST89                                                                 02/19/2014 10:35:30 PAGE 3   

 118   1           _nop_();              //略做延时
 119   1           SCL=0;                //将SCL=0，结束应答信号读操作
 120   1      } 
 121          
 122          //---------------------------------------
 123          //名称：从IIC总线读入1个字节函数
 124          //适用：给力者GL9单片机开发学习系统
 125          //公司：宁波芯动电子有限公司
 126          //网址：www.MovingChip.com
 127          //日期：20140219
 128          //---------------------------------------
 129          unsigned char Read1Byte(void)
 130          { 
 131   1           unsigned char k;      //1个字节要分8次读出，需要定义一个寄存器用来计数
 132   1           unsigned char t=0;    //定义一个寄存器用保存读出数据
 133   1           for(k=0;k<8;k++)      //做一个8次的循环，每次读入1位，需要读8次
 134   1           {
 135   2               t=t<<1;           //数据左移一位，空出最低位以准备保存读入的一位数据
 136   2               SDA=1;            //将SDA写1准备读
 137   2               SCL=1;            //将SCL=1，做个上升沿准备读一位数据
 138   2               _nop_();          //略做延时
 139   2               _nop_();          //略做延时
 140   2               if(SDA==1)        //读一位数据，并判断 
 141   2               {
 142   3                   t=t|0x01;     //如果读入数据为1，就将接收缓冲区最低一位置1
 143   3               }
 144   2               else
 145   2               {
 146   3                   t=t&0xfe;     //如果读入数据为0，就将接收缓冲区最低一位写0
 147   3               }
 148   2               SCL=0;            //SCL恢复为0，结束一位数据读操作
 149   2               _nop_();          //略做延时
 150   2               _nop_();          //略做延时
 151   2           }
 152   1           return t;             //将读入的一个字节返回
 153   1      } 
 154          
 155          //---------------------------------------
 156          //名称：软件模拟IIC向PCF8563指定地址写一个字节函数
 157          //适用：给力者GL9单片机开发学习系统
 158          //公司：宁波芯动电子有限公司
 159          //网址：www.MovingChip.com
 160          //日期：20140219
 161          //---------------------------------------
 162          void WritePCF8563(unsigned char Address,unsigned char Databuf)
 163          {                          //直接调用本函数即可对PCF8563的Address地址写Databuf
 164   1          IICstart();            //IIC启动信号
 165   1      
 166   1          Write1Byte(0xA2);      //发送PCF8563的器件地址和写信号
 167   1      
 168   1          Write1Byte(Address);   //发送地址
 169   1      
 170   1          Write1Byte(Databuf);   //发送数据
 171   1      
 172   1          IICstop();             //产生IIC停止信号
 173   1      }
 174          
 175          //---------------------------------------
 176          //名称：软件模拟IIC从PCF8563指定地址读一个字节函数
 177          //适用：给力者GL9单片机开发学习系统
 178          //公司：宁波芯动电子有限公司
 179          //网址：www.MovingChip.com
C51 COMPILER V7.00  TEST89                                                                 02/19/2014 10:35:30 PAGE 4   

 180          //日期：20140219
 181          //---------------------------------------
 182          unsigned ReadPCF8563(unsigned char Address)
 183          {                          //直接调用本函数即可从PCF8563的Address地址读出数据返回
 184   1          unsigned char buf;     //定义一个寄存器用来暂存读出的数据
 185   1          IICstart();            //IIC启动信号
 186   1      
 187   1          Write1Byte(0xA2);      //发送PCF8563的器件地址和写信号
 188   1      
 189   1          Write1Byte(Address);   //发送地址
 190   1      
 191   1          IICstart();            //IIC启动信号
 192   1      
 193   1          Write1Byte(0xA3);      //发送PCF8563的器件地址和读信号
 194   1      
 195   1          buf=Read1Byte();//读一个字节数据
 196   1      
 197   1          IICstop();             //产生IIC停止信号
 198   1      
 199   1          return(buf);           //将读出数据返回
 200   1      }
 201          
 202          //---------------------------------------
 203          //名称: 主函数
 204          //适用：给力者GL9单片机开发学习系统
 205          //公司：宁波芯动电子有限公司
 206          //网址：www.MovingChip.com
 207          //日期：20140219
 208          //---------------------------------------
 209          void main(void)            //主函数,单片机开机后就是从这个函数开始运行
 210          {
 211   1      
 212   1          unsigned char c=0;     //定义一个char型变量，做延时用
 213   1          unsigned char d=0;     //定义一个char型变量，控制显示位置
 214   1               unsigned int  e=0;
 215   1          //***初始化时钟芯片的参数为12年9月3日20点03分07秒***
 216   1          WritePCF8563(0x00,0x00); //启动PCF8563
 217   1          WritePCF8563(0x02,0x50); //设置秒初始参数为50
 218   1          WritePCF8563(0x03,0x03); //设置分钟初始参数为03
 219   1          WritePCF8563(0x04,0x20); //设置小时初始参数为20
 220   1          WritePCF8563(0x05,0x03); //设置日初始参数为03
 221   1          WritePCF8563(0x06,0x01); //设置星期初始参数为01
 222   1          WritePCF8563(0x07,0x09); //设置月初始参数为09
 223   1          WritePCF8563(0x08,0x12); //设置年初始参数为12
 224   1          //***************************
 225   1          while(1)               //死循环,单片机初始化后,将一直运行这个死循环
 226   1          {       
 227   2              for(c=0;c<250;c++); //做一个0-250的循环，不执行其他操作，只为延时
 228   2                        if(++e>600)         //延时，做闪烁的亮点
 229   2                        {
 230   3                                      e=0;
 231   3                                      Secondbit=!Secondbit;
 232   3                        }
 233   2                        PCFbuf1=ReadPCF8563(0x04); //读出小时参数        
 234   2                        PCFbuf2=ReadPCF8563(0x03); //读出分钟参数
 235   2              P2=0;              //关一次显示，以免显示出鬼影
 236   2              if(++d>3) d=0;     //先将d加1，然后判断是否大于3，大于3归零
 237   2              if(d==0)           //如果d=0,显示千位
 238   2              {
 239   3                  P0=0xfb;       //U16A0=1,U16A1=1,U16A2=0选通数码管的千位进行显示
 240   3                  P2=LED[(PCFbuf1>>4)&0x03];     //千位显示小时的十位
 241   3              }
C51 COMPILER V7.00  TEST89                                                                 02/19/2014 10:35:30 PAGE 5   

 242   2              else if(d==1)      //如果d=1,显示百位
 243   2              {
 244   3                  P0=0xfa;       //U16A0=0,U16A1=1,U16A2=0选通数码管的百位进行显示
 245   3                  P2=LED[PCFbuf1&0x0f];     //百位显示小时的个位
 246   3                                      P2_7=Secondbit;           //显示闪烁的点
 247   3              }
 248   2              else if(d==2)      //如果d=2,显示十位
 249   2              {
 250   3                  P0=0xf9;       //U16A0=1,U16A1=0,U16A2=0选通数码管的十位进行显示
 251   3                  P2=LED[(PCFbuf2>>4)&0x07];     //十位显示分钟的十位
 252   3              }
 253   2              else               //如果d=3,显示个位
 254   2              {
 255   3                  P0=0xf8;       //U16A0=0,U16A1=0,U16A2=0选通数码管的个位进行显示
 256   3                  P2=LED[PCFbuf2&0x0f];     //个位显示分钟的个位
 257   3              }               
 258   2          }
 259   1      }
 260          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    354    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

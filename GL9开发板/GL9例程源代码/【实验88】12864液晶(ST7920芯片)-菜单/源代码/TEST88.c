////////////////////////////////////////////////////////////////////////////
//                给力者单片机开发学习系统，开发学习都给力！              //
////////////////////////////////////////////////////////////////////////////
//                     学习51单片机，其实可以很简单                       //
////////////////////////////////////////////////////////////////////////////
//                宁波芯动电子有限公司  www.MovingChip.com                //
////////////////////////////////////////////////////////////////////////////

#include <AT89X52.h>       //调用51单片机的头文件
#include <Intrins.h>    //因为本例中用到空操作_nop_();所以必须调用这个头文件
unsigned char code TAB[]={
//第1界面 （开机按任意键后进入此界面）
"系  1:背光灯    " //对应索引Index=0
"统  2:存储器管理" //对应索引Index=1
"菜  3:MP3 播放  " //对应索引Index=2
"单  4:文件夹选项" //对应索引Index=3
//第2界面 （Index=0时按确定进入此界面）
"  1:液晶屏背光灯" //对应索引Index=4
"  2:亮    度 0-9" //对应索引Index=5
"  3:延时时间 0-9" //对应索引Index=6
"  4:其他参数设置" //对应索引Index=7
//第3界面 （Index=1时按确定进入此界面）
"  1:外部存储器  " //对应索引Index=8
"  2:已用大小    " //对应索引Index=9
"  3:剩余大小    " //对应索引Index=10
"  4:其他信息    " //对应索引Index=11
//第4界面 （Index=2时按确定进入此界面）
"  1:多媒体播放器" //对应索引Index=12
"  2:选择歌曲    " //对应索引Index=13
"  3:声音大小    " //对应索引Index=14
"  4:歌手信息    " //对应索引Index=15
//第5界面 （Index=3时按确定进入此界面）
"  1:系统文件    " //对应索引Index=16
"  2:使用说明书  " //对应索引Index=17
"  3:单片机基础  " //对应索引Index=18
"  4:翻页  返回  " //对应索引Index=19
//第6界面 （Index=17时按确定进入此界面）
"  使用说明书    " //对应索引Index=20
"本页省略1000字  " //对应索引Index=21
"  。。。。。    " //对应索引Index=22
"  。。。。。    " //对应索引Index=23
};
unsigned char code TAB1[]={
"系统初始化.     "
"系统初始化..    "
"系统初始化....  "
"按任意键开始!   "
};
//---------------------------------------
//12864液晶相关I/O设置
sbit RS=P2^0; 			//并行数据/控制字选择 H:数据  L:控制字
sbit RW=P2^1; 			//并行读/写选择       H:读    L:写
sbit E =P2^2; 			//并行读写使能        H有效,下降沿锁定数据
sbit PSB=P2^3; 			//串口,并口选择       H:并口  L:串口（开发板上引脚标识为CS1）
sbit RST=P2^5; 			//复位引脚            L:液晶复位
sbit DB0=P0^7; 			//
sbit DB1=P0^6; 			//
sbit DB2=P0^5; 			//
sbit DB3=P0^4; 			//
sbit DB4=P0^3; 			//
sbit DB5=P0^2; 			//
sbit DB6=P0^1; 			//
sbit DB7=P0^0; 			//
//---------------------------------------
unsigned char keycon;   //按键消抖用
bit keybit;					//按键消抖用
unsigned char Index;    //索引
bit Select_bit;  	      //Select_bit=0：显示开机画面  Select_bit=1：显示菜单
bit Menu_bit;          	//Menu_bit=1：刷新菜单页面
bit Start_bit;         	//只显示一次开机画面
//---------------------------------------
//名称：液晶用延时函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
void delay(unsigned int t)
{
	unsigned int i;
	for(i=0;i<t;i++);	
}
//---------------------------------------
//名称：字节内位数据位置转换函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
unsigned char num(unsigned char dat)
{
   unsigned char val;
	val = ((dat & 0x01) << 7) | ((dat & 0x02) << 5) | ((dat & 0x04) << 3) | ((dat & 0x08) << 1) |
   ((dat & 0x10) >> 1) | ((dat & 0x20) >> 3) | ((dat & 0x40) >> 5) | ((dat & 0x80) >> 7);
   return  val;
} 
//---------------------------------------
//名称：写命令函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
void write_com(unsigned char cmdcode)
{		
	RS=0;                   //设置该字节数据为命令代码
	RW=1;                   //设置此次操作为读
	E=1;                    //使能
	_nop_();            		//空操作，做短暂的延时
	_nop_();            		//空操作，做短暂的延时
	E=0;                    //失能
	RS=0;                   //设置该字节数据为命令代码
	RW=0;                   //设置此次操作为读写
	P0=num(cmdcode);    		//将命令写入总线
	_nop_();            		//空操作，做短暂的延时
	E=1;           			//E的下降沿，数据写入
	_nop_();            		//空操作，做短暂的延时
	E=0;           			//E的下降沿，数据写入
}
//---------------------------------------
//名称：写数据函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
void write_data(unsigned char Rsspdata)
{
	RS=0;                   //设置该字节数据为命令代码
	RW=1;                   //设置此次操作为读
	E=1;                    //使能
	_nop_();            		//空操作，做短暂的延时
	_nop_();            		//空操作，做短暂的延时
	E=0;                    //失能
	RS=1;                   //设置该字节数据为数据代码
	RW=0;                   //设置此次操作为读写
	P0=num(Rsspdata);   		//将数据写入总线
	_nop_();            		//空操作，做短暂的延时
	E=1;           			//E的下降沿，数据写入
	_nop_();            		//空操作，做短暂的延时
	E=0;           			//E的下降沿，数据写入
} 
//---------------------------------------
//名称：地址写入函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
void write_xy(unsigned char x,unsigned char y)
{
	unsigned char address;
	switch(y)
	{
		case 0:address=0x80+x;break;  //第一行的首地址是0x80
		case 1:address=0x90+x;break;  //第二行的首地址是0x90
		case 2:address=0x88+x;break;  //第三行的首地址是0x88
		case 3:address=0x98+x;break;  //第四行的首地址是0x98
		default:address=0x80+x;
   }
	write_com(address);	
} 
//---------------------------------------
//名称：菜单及反白处理函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
void Disp_Menu(unsigned char Index)
{
	unsigned char k,m,x,y;
	//以上为显示反白部分
	for(k=0;k<32;k++)          //绘图RAM全部清零
	{
		write_com(0x34);  	 	//扩展指令集
   	write_com(0x80+k);      //先设定垂直地址(0-32)
   	write_com(0x80);        //再设定水平地址(0)  
      write_com(0x30);  		//基本指令集 
   	for(m=0;m<16;m++)       //将绘图RAM全部清零
		{					
   		write_data(0);  
 	      write_data(0);
		}
	}		
	//因为1、3行，2、4行是连在一起的，所以根据
	//显示反白所在不同的行，需要置不同的X,Y值
	switch(Index%4)
	{
		case 0:x=0x80;y=0x80; break;  //反白在第1行,X地址为0,Y地址为0
		case 1:x=0x80;y=0x90;break;  	//反白在第2行,X地址为0,Y地址为16
		case 2:x=0x88;y=0x80;break;  	//反白在第3行,X地址为8,Y地址为0
		case 3:x=0x88;y=0x90;break;  	//反白在第4行,X地址为8,Y地址为16
		default:x=0x80;y=0x80;
   }	
   for(k=0;k<16;k++)
	{		
		write_com(0x34);  		//扩展指令集
   	write_com(y+k);         //先设定垂直地址
   	write_com(x+1);         //再设定水平地址，加1是为了第1个汉字列不反白   
  	   write_com(0x30);  		//基本指令集 
   	for(m=0;m<7;m++)        //因第一个汉字列不反白，所以只反白7个汉字位就可以
		{					
   		write_data(0xff);    //写1，将导致反白
 	      write_data(0xff);    //反白原理为，文字和绘图RAM异或后送显示
		}
	}
	write_com(0x36);  			//写完数据，开图形显示
	write_com(0x30);  			//基本指令集  
	//以上为显示反白部分
	//以下为显示菜单部分
	for(m=0;m<4;m++)
	{
		write_xy(0,m);   			//先写入地址参数
		for(k=0;k<16;k++)       //每行8个汉字，共16个字节内码
		{
			write_data(TAB[(Index/4)*64+m*16+k]); //写入一个字符串数据	
			delay(10);
		}
	}
	//以上为显示菜单部分
}
//---------------------------------------
//名称：开机画面函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
void Disp_Start(void)
{
	unsigned char k,m;
	for(m=0;m<4;m++)						//开机画面有4行
	{
		write_xy(0,m);   					//先写入地址参数
		for(k=0;k<16;k++)             //8个汉字，共16个字节
		{
			write_data(TAB1[m*16+k]);  //查表取开机画面汉字的内码	
			delay(10);
		}
	}
}
//---------------------------------------
//名称：12864初始化函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//--------------------------------------- 
void init_lcd(void)
{	   
	RST=0;           				//复位液晶
	delay(250);      				//加些延时
	RST=1;           				//复位结束
	delay(250);      				//加些延时
	PSB=1;           				//选择8bit并口

	write_com(0x30);  			//基本指令集  
	write_com(0x0c);  			//显示开
	write_com(0x06);  			//光标右移，整体显示不移动
	write_com(0x01);  			//清除显示(清零DDRAM)
	delay(250);
}  
//---------------------------------------
//名称: 按键扫描函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
unsigned char ScanKey(void)
{
 	//***8独立按键扫描部分***
   //按P1-P8键，返回参数1-8	
   if(P1_0==0) return 1;     		//如果P1键按下，返回1
   else if(P1_1==0) return 2; 	//如果P2键按下，返回2
   else if(P1_2==0) return 3; 	//如果P3键按下，返回3
   else if(P1_3==0) return 4; 	//如果P4键按下，返回4    
   else if(P1_4==0) return 5;  	//如果P5键按下，返回5
   else if(P1_5==0) return 6; 	//如果P6键按下，返回6
   else if(P1_6==0) return 7; 	//如果P7键按下，返回7
   else if(P1_7==0) return 8; 	//如果P8键按下，返回8

	return 0;                    	//如果无按键按下，返回0
}
//---------------------------------------
//名称: 按键处理函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//---------------------------------------
void KeyPro(void)
{
	unsigned char k;
	k=ScanKey();
	if(k==0)          	 			//如果无键按下
	{		
		if(keybit==0)
		{
			if(++keycon>50) 			//消除抖动参数，越大消抖效果越好，但是按键越不灵敏
			{
				keycon=0;
				keybit=1;    			//微分用标志位
			}
		}
		else
			keycon=0;			
	}	   
	else if(k==1)      				//如果P1键按下,移动选择
	{
		if(keybit==1)  				//如果标志位有效，说明这个是有效按键
		{
			keybit=0;  					//清除标志位，以保证每次按键只处理一次			
			if(Index<4)					//如果索引为0-3，为第1个界面
			{
				if(++Index>3) Index=0;//移动选择需要控制在0-3以内
			}	
			else if(Index<8)			//如果索引为4-7，为第2个界面
			{
				if(++Index>7) Index=4;//移动选择需要控制在4-7以内
			}
			else if(Index<12)			//如果索引为8-11，为第3个界面
			{
				if(++Index>11) Index=8;//移动选择需要控制在8-11以内
			}
			else if(Index<16)			//如果索引为12-15，为第4个界面
			{
				if(++Index>15) Index=12;//移动选择需要控制在12-15以内
			}
			else if(Index<20)			//如果索引为16-19，为第5个界面
			{
				if(++Index>19) Index=16;//移动选择需要控制在16-19以内				
			}
			else if(Index<24)			//如果索引为20-23，为第6个界面
			{
				if(++Index>23) Index=20;//移动选择需要控制在20-23以内				
			}
			Menu_bit=1;				 	//每移动一次，都要置刷新标志位
		}
	}			
	else if(k==2)      				//如果P2键按下,确定
	{
		if(keybit==1)  				//如果标志位有效，说明这个是有效按键
		{
			keybit=0;  					//清除标志位，以保证每次按键只处理一次	
			Menu_bit=1;				 	//每确定一次，都要置刷新标志位
			switch(Index)
			{
				case 0:Index=4; break;  	//如果选择第1页的第1行，索引转向第2页第1行
				case 1:Index=8;break;  		//如果选择第1页的第2行，索引转向第3页第1行
				case 2:Index=12;break;  	//如果选择第1页的第3行，索引转向第4页第1行
				case 3:Index=16;break;  	//如果选择第1页的第4行，索引转向第5页第1行
				case 17:Index=20;break;  	//如果选择第5页的第2行，索引转向第6页第1行 
				default:Menu_bit=1;			//非定义部分，清零刷新标志位
   		}			
		}
   }
	else if(k==5)      				//如果P5键按下,返回
	{
		if(keybit==1)  				//如果标志位有效，说明这个是有效按键
		{				
			keybit=0;			
			if((Index>3)&&(Index<20))//如果索引在第2-5页以内
			{
				Index=0; 				//将索引转到第1页第1行
				Menu_bit=1;          //刷新页面
			}
			else if((Index>19)&&(Index<24))//如果索引在第6页
			{
				Index=17; 				//将索引转到第5页第2行 
            Menu_bit=1;          //刷新页面
			}
	   }
	}
}
//---------------------------------------
//名称: 主函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20131113
//--------------------------------------- 		
void main(void)
{  
	Select_bit=0;
	Start_bit=0;
	init_lcd();		
  	while(1)
	{		  		
		if(Select_bit==0)         	//显示开机画面
		{
			if(Start_bit==0)       	//为避免刷新带来的屏幕闪动
			{
				Start_bit=1;			//开机画面只允许显示一次	
				Disp_Start();			//显示开机画面内容
			}
			P1=0xff;                //P1口做好读取得准备，先写1
			if(P1!=0xff)            //有任意键按下
			{
				Select_bit=1;        //标志位置1，准备显示菜单画面	
				Menu_bit=1;          //置1显示1次菜单画面
				Index=0;           	//索引初始值为0，反白为第一页第一行
			}
		}
		else            				//显示菜单画面
		{
			KeyPro();               //按键处理函数
			if(Menu_bit==1)			//标志位为1，刷新一次菜单画面
			{
				Menu_bit=0;				//清除标志位，目的只刷新一次
				Disp_Menu(Index); 	//调用菜单及反白画面处理函数
			}
		}
	}
}


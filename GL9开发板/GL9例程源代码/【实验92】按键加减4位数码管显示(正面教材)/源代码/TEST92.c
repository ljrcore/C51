

#include <AT89X52.h>       //调用51单片机的头文件

//---------------------------------------
//数码管字形表，供显示时查询
unsigned char code LED[10]=
{                          //定义表格一定要使用code，这样会做到程序存储区中
    0x3F,                  //"0"的字形表，0B00111111
    0x06,                  //"1"的字形表，0B00000110
    0x5B,                  //"2"的字形表，0B01011011
    0x4F,                  //"3"的字形表，0B01001111
    0x66,                  //"4"的字形表，0B01100110
    0x6D,                  //"5"的字形表，0B01101101
    0x7D,                  //"6"的字形表，0B01111101
    0x07,                  //"7"的字形表，0B00000111
    0x7F,                  //"8"的字形表，0B01111111
    0x6F,                  //"9"的字形表，0B01101111
};

//---------------------------------------
//4位数码管相关I/O设置
sbit U165A0=P0^0;           //U165(74HC138)的A0脚接在P0.0口上
sbit U165A1=P0^1;           //U165(74HC138)的A1脚接在P0.1口上
sbit U165A2=P0^2;           //U165(74HC138)的A2脚接在P0.2口上
//---------------------------------------

//---------------------------------------
//名称: 主函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20140125
//---------------------------------------
void main(void)            //主函数,单片机开机后就是从这个函数开始运行
{

   unsigned char c=0;     //定义一个char型变量，做延时用
   unsigned char d=0;     //定义一个char型变量，控制显示位置
   unsigned int  f=0;     //定义一个int型变量，显示内容用，显示内容0-9999
	unsigned char keycon;
	bit keybit;
	while(1)               //死循环,单片机初始化后,将一直运行这个死循环
   {

      for(c=0;c<250;c++); //做一个0-250的循环，不执行其他操作，只为延时  
//----------------------------------------------------------------------------------
//以下为按键处理部分
   	if(P1_0==1)         //如果P1键没按下
		{			
			if(keybit==0)
			{
				if(++keycon>100) //消除抖动参数，越大消抖效果越好，但是按键越不灵敏
				{
					keycon=0;
					keybit=1;     //时间到达，标志位置1，表示可以接收下一个按键输入了
				}
			}
			else
				keycon=0;		  	
		}	   
		else           	   //如果P1键按下
		{
			if(keybit==1)  	//如果标志位有效，说明这个是有效按键
			{
				keybit=0;  		//清除标志位，以保证每次按键只处理一次
				if(++f>9999) f=0;//加1并限制范围为0-9999，因为4位数码管只能显示到9999
			}
	   }	
//以上为按键部分
//-----------------------------------------------------------------------------------
//以下为显示部分，按键部分处理f的数值，显示部分负责显示
      P2=0;              //关一次显示，以免显示出鬼影
      if(++d>3) d=0;     //先将d加1，然后判断是否大于3，大于3归零
      if(d==0)           //如果d=0,显示千位
      {
         P0=0x1b;       //U165A0=1,U165A1=1,U165A2=0选通数码管的千位进行显示
         P2=LED[f/1000];          //将要显示的f的千位提取出来查表后送显示 
      }
      else if(d==1)      //如果d=1,显示百位
      {
         P0=0x1a;       //U165A0=0,U165A1=1,U165A2=0选通数码管的百位进行显示
         P2=LED[(f%1000)/100];    //将要显示的f的百位提取出来查表后送显示
      }
      else if(d==2)      //如果d=2,显示十位
      {
      	P0=0x19;       //U165A0=1,U165A1=0,U165A2=0选通数码管的十位进行显示
         P2=LED[(f%100)/10];      //将要显示的f的十位提取出来查表后送显示
      }
      else               //如果d=3,显示个位
      {
         P0=0x18;       //U165A0=0,U165A1=0,U165A2=0选通数码管的个位进行显示
         P2=LED[f%10];            //将要显示的f的个位提取出来查表后送显示
      }
//以上为显示部分
   }
}


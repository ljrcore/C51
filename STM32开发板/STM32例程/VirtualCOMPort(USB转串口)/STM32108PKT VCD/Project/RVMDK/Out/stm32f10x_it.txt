; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Out\stm32f10x_it.o --depend=.\Out\stm32f10x_it.d --device=DARMSTM --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Core\CM3 -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I"D:\Program Files\KeilARM350\ARM\INC\ST\STM32F10x" ..\src\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;85     *******************************************************************************/
;;;86     void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;87     {
;;;88       /* Go to infinite loop when Bus Fault exception occurs */
;;;89       while (1)
000002  e7fe              B        |L1.2|
;;;90       {
;;;91       }
;;;92     }
;;;93     
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;126    *******************************************************************************/
;;;127    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;128    {
;;;129    }
;;;130    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;55     *******************************************************************************/
;;;56     void HardFault_Handler(void)
000000  bf00              NOP      
                  |L3.2|
;;;57     {
;;;58       /* Go to infinite loop when Hard Fault exception occurs */
;;;59       while (1)
000002  e7fe              B        |L3.2|
;;;60       {
;;;61       }
;;;62     }
;;;63     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;70     *******************************************************************************/
;;;71     void MemManage_Handler(void)
000000  bf00              NOP      
                  |L4.2|
;;;72     {
;;;73       /* Go to infinite loop when Memory Manage exception occurs */
;;;74       while (1)
000002  e7fe              B        |L4.2|
;;;75       {
;;;76       }
;;;77     }
;;;78     
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;44     *******************************************************************************/
;;;45     void NMI_Handler(void)
000000  4770              BX       lr
;;;46     {
;;;47     }
;;;48     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;137    *******************************************************************************/
;;;138    void PendSV_Handler(void)
000000  4770              BX       lr
;;;139    {
;;;140    }
;;;141    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;115    *******************************************************************************/
;;;116    void SVC_Handler(void)
000000  4770              BX       lr
;;;117    {
;;;118    }
;;;119    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;148    *******************************************************************************/
;;;149    void SysTick_Handler(void)
000000  4770              BX       lr
;;;150    {
;;;151    }
;;;152    
                          ENDP


                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM2_IRQHandler PROC
;;;215    #define EGR_UG_Set              ((u16)0x0001)
;;;216    void TIM2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218      if (TIM_GetITStatus(TIM2, TIM_IT_CC1) != RESET)
000002  2102              MOVS     r1,#2
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b170              CBZ      r0,|L9.42|
;;;219      {
;;;220        TIM2->CR1 &= CR1_CEN_Reset;                           // disable timer
00000c  f04f4080          MOV      r0,#0x40000000
000010  8800              LDRH     r0,[r0,#0]
000012  f24031fe          MOV      r1,#0x3fe
000016  4008              ANDS     r0,r0,r1
000018  f04f4180          MOV      r1,#0x40000000
00001c  8008              STRH     r0,[r1,#0]
;;;221        TIM2->SR = (u16)~TIM_FLAG_CC1;                        // clear timer overflow flag
00001e  f64f70fd          MOV      r0,#0xfffd
000022  8208              STRH     r0,[r1,#0x10]
;;;222        usart_2_usb_process = START_USART2USB; 
000024  2001              MOVS     r0,#1
000026  4901              LDR      r1,|L9.44|
000028  7008              STRB     r0,[r1,#0]
                  |L9.42|
;;;223      }
;;;224    }
00002a  bd10              POP      {r4,pc}
;;;225    
                          ENDP

                  |L9.44|
                          DCD      usart_2_usb_process

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;176    *******************************************************************************/
;;;177    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179      if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  4807              LDR      r0,|L10.36|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b108              CBZ      r0,|L10.18|
;;;180      {
;;;181        /* Send the received data to the PC Host*/
;;;182        USART_2_USB_Send_Data();
00000e  f7fffffe          BL       USART_2_USB_Send_Data
                  |L10.18|
;;;183      }
;;;184      
;;;185      if(USART_GetITStatus(USART1, USART_IT_TXE) != RESET)
000012  f2407127          MOV      r1,#0x727
000016  4803              LDR      r0,|L10.36|
000018  f7fffffe          BL       USART_GetITStatus
00001c  b108              CBZ      r0,|L10.34|
;;;186      {   
;;;187        usb_2_usart_send_data();
00001e  f7fffffe          BL       usb_2_usart_send_data
                  |L10.34|
;;;188      }
;;;189    }
000022  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  |L10.36|
                          DCD      0x40013800

                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=1

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;164    *******************************************************************************/
;;;165    void USB_LP_CAN1_RX0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167      USB_Istr();
000002  f7fffffe          BL       USB_Istr
;;;168    }
000006  bd10              POP      {r4,pc}
;;;169    
                          ENDP


                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;100    *******************************************************************************/
;;;101    void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L12.2|
;;;102    {
;;;103      /* Go to infinite loop when Usage Fault exception occurs */
;;;104      while (1)
000002  e7fe              B        |L12.2|
;;;105      {
;;;106      }
;;;107    }
;;;108    
                          ENDP


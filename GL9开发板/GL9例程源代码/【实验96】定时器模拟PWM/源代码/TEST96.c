////////////////////////////////////////////////////////////////////////////
//                给力者单片机开发学习系统，开发学习都给力！              //
////////////////////////////////////////////////////////////////////////////
//                     学习51单片机，其实可以很简单                       //
////////////////////////////////////////////////////////////////////////////
//                宁波芯动电子有限公司  www.MovingChip.com                //
////////////////////////////////////////////////////////////////////////////

#include <AT89X52.h>       //调用51单片机的头文件

//---------------------------------------
//定义一个数据表格
unsigned char code LED[10]=
{                          //定义表格一定要使用code，这样会做到程序存储区中
    0x3F,                  //表格第1步数据0b00111111
    0x06,                  //表格第2步数据0b00000110
    0x5B,                  //表格第3步数据0b01011011
    0x4F,                  //表格第4步数据0b01001111
    0x66,                  //表格第5步数据0b01100110
    0x6D,                  //表格第6步数据0b01101101
    0x7D,                  //表格第7步数据0b01111101
    0x07,                  //表格第8步数据0b00000111
    0x7F,                  //表格第9步数据0b01111111
    0x6F,                  //表格第10步数据0b01101111
};
//---------------------------------------
//4位数码管相关I/O设置
sbit U16A0=P1^0;           //U16(74HC138)的A0脚接在P1.0口上
sbit U16A1=P1^1;           //U16(74HC138)的A1脚接在P1.1口上
sbit U16A2=P1^2;           //U16(74HC138)的A2脚接在P1.2口上
//---------------------------------------
unsigned char k;
unsigned char keycon;
bit keybit;
unsigned char c=0;     //定义一个char型变量，做延时用
unsigned char d=0;     //定义一个char型变量，控制显示位置
//---------------------------------------
unsigned char DutyCycle;   //定义一个char型变量，PWM占空比
unsigned char Pwm;    		//定义一个char型变量，PWM计数用
//---------------------------------------
//名称：定时器0中断服务程序
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20140424
//---------------------------------------
void Timer0(void) interrupt 1 
{                          	//定时100微秒
    //***此处用户自行添加定时器T0中断处理程序***
	Pwm=Pwm++;
	if(Pwm>99)         			//对中断计次，记到100次后，一个PWM周期结束
	{
		Pwm=0;            		//对计次用寄存器清零，以被下一个计次循环
		if(DutyCycle>0) P0_0=1; //新周期的开始后，输出1
	}
	else if(Pwm>DutyCycle)		//计数到达占空比参数后，输出0
	{
		P0_0=0;						//计数到达占空比参数后，输出0
	}
    //******************************************
}
//---------------------------------------
//名称: 按键扫描函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20140424
//---------------------------------------
unsigned char ScanKey(void)
{
	if(P3_0==0) return 1;     		// 如果P1键按下，返回1
	else if(P3_1==0) return 2; 	// 如果P2键按下，返回2
   else if(P3_2==0) return 3; 	// 如果P3键按下，返回3
   else if(P3_3==0) return 4; 	// 如果P4键按下，返回4    
   else if(P3_4==0) return 5;  	// 如果P5键按下，返回5
   else if(P3_5==0) return 6; 	// 如果P6键按下，返回6
   else if(P3_6==0) return 7; 	// 如果P7键按下，返回7
   else if(P3_7==0) return 8; 	// 如果P8键按下，返回8
	return 0;                    	// 如果无按键按下，返回0
}
//---------------------------------------
//名称: 主函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20140424
//---------------------------------------
void main(void)            //主函数,单片机开机后就是从这个函数开始运行
{	
    //***定时器Timer0初始化***
	TMOD&=0xF0;            //将TMOD的低4位定时器0控制部分清零
   TMOD|=0x02;            //设置定时器0为方式2
   TL0=0x47;              //设置定时器0初值
   TH0=0x47;              //重装初值
   TR0=1;                 //启动定时器0
   ET0=1;                 //Timer0中断允许
    //**********************
    //***开全局中断设置****
    //定时器Timer0设置了中断允许,此处要开全局中断
   EA=1;                  //开全局中断
    //*********************
	DutyCycle=0;
	P0=0;
   while(1)               //死循环,单片机初始化后,将一直运行这个死循环
   {     
		k=ScanKey();				// 调用按键扫描函数
 		if(k==0)          		// 如果无键按下
		{		
			if(keybit==0)
			{
				if(++keycon>50) 	// 消除抖动参数，越大消抖效果越好，但是按键越不灵敏
				{
					keycon=0;
					keybit=1;
				}
			}
			else
				keycon=0;			
		}	   
		else 							// 如果有键按下
		{
    		if(keybit==1)  		// 如果标志位有效，说明这个是有效按键
			{
				keybit=0;  
				if(k==1)        //P1键按下，占空比加1
				{
					if(DutyCycle<100) DutyCycle++;
				}
				else if(k==5)   //P5键按下，占空比减1
				{
					if(DutyCycle>0) DutyCycle--;
				}
				else if(k==2)    //P1键按下，占空比加10
				{
					if(DutyCycle<91) DutyCycle+=10;
					else DutyCycle=100;
				}
				else if(k==6)   //P5键按下，占空比减10
				{
					if(DutyCycle>9) DutyCycle-=10;
					else DutyCycle=0;
				}
			}
		}
		for(c=0;c<250;c++);//做一个0-250的循环，不执行其他操作，只为延时
		//以下为数码管显示部分		
		P2=0;              //关一次显示，以免显示出鬼影
      	if(++d>3) d=0;     //先将d加1，然后判断是否大于3，大于3归零
      	if(d==0)           //如果d=0,显示千位
      	{
          P1=0x03;       //U16A0=1,U16A1=1,U16A2=0选通数码管的千位进行显示
          P2=0 ;         //将要显示的f的千位提取出来查表后送显示 
      	}
      	else if(d==1)      //如果d=1,显示百位
      	{
          P1=0x02;       //U16A0=0,U16A1=1,U16A2=0选通数码管的百位进行显示
          P2=LED[DutyCycle/100];    //将要显示的f的百位提取出来查表后送显示
      	}
      	else if(d==2)      //如果d=2,显示十位
      	{
          P1=0x01;       //U16A0=1,U16A1=0,U16A2=0选通数码管的十位进行显示
          P2=LED[(DutyCycle%100)/10];      //将要显示的f的十位提取出来查表后送显示
      	}
      	else               //如果d=3,显示个位
	    {
          P1=0x00;       //U16A0=0,U16A1=0,U16A2=0选通数码管的个位进行显示
          P2=LED[DutyCycle%10];            //将要显示的f的个位提取出来查表后送显示
      	}
   }
}


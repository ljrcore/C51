; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Out\stm32f10x_rcc.o --depend=.\Out\stm32f10x_rcc.d --device=DARMSTM --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Core\CM3 -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I"D:\Program Files\KeilARM350\ARM\INC\ST\STM32F10x" ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;522      */
;;;523    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  2100              MOVS     r1,#0
;;;524    {
;;;525      uint32_t tmpreg = 0;
;;;526      /* Check the parameters */
;;;527      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;528      tmpreg = RCC->CFGR;
000002  4a03              LDR      r2,|L1.16|
000004  6851              LDR      r1,[r2,#4]
;;;529      /* Clear ADCPRE[1:0] bits */
;;;530      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000006  f4214140          BIC      r1,r1,#0xc000
;;;531      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;532      tmpreg |= RCC_PCLK2;
00000a  4301              ORRS     r1,r1,r0
;;;533      /* Store the new value */
;;;534      RCC->CFGR = tmpreg;
00000c  6051              STR      r1,[r2,#4]
;;;535    }
00000e  4770              BX       lr
;;;536    
                          ENDP

                  |L1.16|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;709      */
;;;710    void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;711    {
;;;712      /* Check the parameters */
;;;713      assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;714      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;715      if (NewState != DISABLE)
;;;716      {
;;;717        RCC->AHBENR |= RCC_AHBPeriph;
000002  4a06              LDR      r2,|L2.28|
000004  6952              LDR      r2,[r2,#0x14]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L2.28|
00000a  615a              STR      r2,[r3,#0x14]
00000c  e004              B        |L2.24|
                  |L2.14|
;;;718      }
;;;719      else
;;;720      {
;;;721        RCC->AHBENR &= ~RCC_AHBPeriph;
00000e  4a03              LDR      r2,|L2.28|
000010  6952              LDR      r2,[r2,#0x14]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L2.28|
000016  615a              STR      r2,[r3,#0x14]
                  |L2.24|
;;;722      }
;;;723    }
000018  4770              BX       lr
;;;724    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;770      */
;;;771    void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L3.14|
;;;772    {
;;;773      /* Check the parameters */
;;;774      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;775      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;776      if (NewState != DISABLE)
;;;777      {
;;;778        RCC->APB1ENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L3.28|
000004  69d2              LDR      r2,[r2,#0x1c]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L3.28|
00000a  61da              STR      r2,[r3,#0x1c]
00000c  e004              B        |L3.24|
                  |L3.14|
;;;779      }
;;;780      else
;;;781      {
;;;782        RCC->APB1ENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L3.28|
000010  69d2              LDR      r2,[r2,#0x1c]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L3.28|
000016  61da              STR      r2,[r3,#0x1c]
                  |L3.24|
;;;783      }
;;;784    }
000018  4770              BX       lr
;;;785    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;829      */
;;;830    void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L4.14|
;;;831    {
;;;832      /* Check the parameters */
;;;833      assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;834      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;835      if (NewState != DISABLE)
;;;836      {
;;;837        RCC->APB1RSTR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L4.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L4.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;838      }
;;;839      else
;;;840      {
;;;841        RCC->APB1RSTR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L4.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L4.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L4.24|
;;;842      }
;;;843    }
000018  4770              BX       lr
;;;844    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;739      */
;;;740    void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L5.14|
;;;741    {
;;;742      /* Check the parameters */
;;;743      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;744      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;745      if (NewState != DISABLE)
;;;746      {
;;;747        RCC->APB2ENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L5.28|
000004  6992              LDR      r2,[r2,#0x18]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L5.28|
00000a  619a              STR      r2,[r3,#0x18]
00000c  e004              B        |L5.24|
                  |L5.14|
;;;748      }
;;;749      else
;;;750      {
;;;751        RCC->APB2ENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L5.28|
000010  6992              LDR      r2,[r2,#0x18]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L5.28|
000016  619a              STR      r2,[r3,#0x18]
                  |L5.24|
;;;752      }
;;;753    }
000018  4770              BX       lr
;;;754    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;799      */
;;;800    void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L6.14|
;;;801    {
;;;802      /* Check the parameters */
;;;803      assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;804      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;805      if (NewState != DISABLE)
;;;806      {
;;;807        RCC->APB2RSTR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L6.28|
000004  68d2              LDR      r2,[r2,#0xc]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L6.28|
00000a  60da              STR      r2,[r3,#0xc]
00000c  e004              B        |L6.24|
                  |L6.14|
;;;808      }
;;;809      else
;;;810      {
;;;811        RCC->APB2RSTR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L6.28|
000010  68d2              LDR      r2,[r2,#0xc]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L6.28|
000016  60da              STR      r2,[r3,#0xc]
                  |L6.24|
;;;812      }
;;;813    }
000018  4770              BX       lr
;;;814    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;272      */
;;;273    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  2100              MOVS     r1,#0
;;;274    {
;;;275      uint32_t tmpreg = 0;
;;;276      /* Check the parameters */
;;;277      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;278      tmpreg = RCC->CR;
000002  4a04              LDR      r2,|L7.20|
000004  6811              LDR      r1,[r2,#0]
;;;279      /* Clear HSITRIM[4:0] bits */
;;;280      tmpreg &= CR_HSITRIM_Mask;
000006  f02101f8          BIC      r1,r1,#0xf8
;;;281      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;282      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00000a  ea4101c0          ORR      r1,r1,r0,LSL #3
;;;283      /* Store the new value */
;;;284      RCC->CR = tmpreg;
00000e  6011              STR      r1,[r2,#0]
;;;285    }
000010  4770              BX       lr
;;;286    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;850      */
;;;851    void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;852    {
;;;853      /* Check the parameters */
;;;854      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;855      *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;856    }
000004  4770              BX       lr
;;;857    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;949      */
;;;950    void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L9.16|
;;;951    {
;;;952      /* Set RMVF bit to clear the reset flags */
;;;953      RCC->CSR |= CSR_RMVF_Set;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L9.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;954    }
00000c  4770              BX       lr
;;;955    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;997      */
;;;998    void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L10.8|
;;;999    {
;;;1000     /* Check the parameters */
;;;1001     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1002     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1003        pending bits */
;;;1004     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1005   }
000004  4770              BX       lr
;;;1006   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;863      */
;;;864    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;865    {
;;;866      /* Check the parameters */
;;;867      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;868      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;869    }
000004  4770              BX       lr
;;;870    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;179      */
;;;180    void RCC_DeInit(void)
000000  480f              LDR      r0,|L12.64|
;;;181    {
;;;182      /* Set HSION bit */
;;;183      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  490d              LDR      r1,|L12.64|
00000a  6008              STR      r0,[r1,#0]
;;;184      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
;;;185      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  490c              LDR      r1,|L12.68|
000012  4008              ANDS     r0,r0,r1
000014  490a              LDR      r1,|L12.64|
000016  6048              STR      r0,[r1,#4]
;;;186      
;;;187      /* Reset HSEON, CSSON and PLLON bits */
;;;188      RCC->CR &= (uint32_t)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  490a              LDR      r1,|L12.72|
00001e  4008              ANDS     r0,r0,r1
000020  4907              LDR      r1,|L12.64|
000022  6008              STR      r0,[r1,#0]
;;;189      /* Reset HSEBYP bit */
;;;190      RCC->CR &= (uint32_t)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f4202080          BIC      r0,r0,#0x40000
00002c  6008              STR      r0,[r1,#0]
;;;191      /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
;;;192      RCC->CFGR &= (uint32_t)0xFF80FFFF;
00002e  4608              MOV      r0,r1
000030  6840              LDR      r0,[r0,#4]
000032  f42000fe          BIC      r0,r0,#0x7f0000
000036  6048              STR      r0,[r1,#4]
;;;193      /* Disable all interrupts */
;;;194      RCC->CIR = 0x00000000;
000038  2000              MOVS     r0,#0
00003a  6088              STR      r0,[r1,#8]
;;;195    }
00003c  4770              BX       lr
;;;196    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0xf8ff0000
                  |L12.72|
                          DCD      0xfef6ffff

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;628      */
;;;629    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b530              PUSH     {r4,r5,lr}
;;;630    {
;;;631      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;632      /* Get SYSCLK source -------------------------------------------------------*/
;;;633      tmp = RCC->CFGR & CFGR_SWS_Mask;
00000a  4d2e              LDR      r5,|L13.196|
00000c  686d              LDR      r5,[r5,#4]
00000e  f005010c          AND      r1,r5,#0xc
;;;634      switch (tmp)
000012  b121              CBZ      r1,|L13.30|
000014  2904              CMP      r1,#4
000016  d005              BEQ      |L13.36|
000018  2908              CMP      r1,#8
00001a  d123              BNE      |L13.100|
00001c  e005              B        |L13.42|
                  |L13.30|
;;;635      {
;;;636        case 0x00:  /* HSI used as system clock */
;;;637          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
00001e  4d2a              LDR      r5,|L13.200|
000020  6005              STR      r5,[r0,#0]
;;;638          break;
000022  e022              B        |L13.106|
                  |L13.36|
;;;639        case 0x04:  /* HSE used as system clock */
;;;640          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
000024  4d28              LDR      r5,|L13.200|
000026  6005              STR      r5,[r0,#0]
;;;641          break;
000028  e01f              B        |L13.106|
                  |L13.42|
;;;642        case 0x08:  /* PLL used as system clock */
;;;643          /* Get PLL clock source and multiplication factor ----------------------*/
;;;644          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00002a  4d26              LDR      r5,|L13.196|
00002c  686d              LDR      r5,[r5,#4]
00002e  f4051270          AND      r2,r5,#0x3c0000
;;;645          pllmull = ( pllmull >> 18) + 2;
000032  2502              MOVS     r5,#2
000034  eb054292          ADD      r2,r5,r2,LSR #18
;;;646          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
000038  4d22              LDR      r5,|L13.196|
00003a  686d              LDR      r5,[r5,#4]
00003c  f4053380          AND      r3,r5,#0x10000
;;;647          if (pllsource == 0x00)
000040  b91b              CBNZ     r3,|L13.74|
;;;648          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;649            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
000042  4d22              LDR      r5,|L13.204|
000044  4355              MULS     r5,r2,r5
000046  6005              STR      r5,[r0,#0]
000048  e00b              B        |L13.98|
                  |L13.74|
;;;650          }
;;;651          else
;;;652          {/* HSE selected as PLL clock entry */
;;;653            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
00004a  4d1e              LDR      r5,|L13.196|
00004c  686d              LDR      r5,[r5,#4]
00004e  f4153f00          TST      r5,#0x20000
000052  d003              BEQ      |L13.92|
;;;654            {/* HSE oscillator clock divided by 2 */
;;;655              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
000054  4d1d              LDR      r5,|L13.204|
000056  4355              MULS     r5,r2,r5
000058  6005              STR      r5,[r0,#0]
00005a  e002              B        |L13.98|
                  |L13.92|
;;;656            }
;;;657            else
;;;658            {
;;;659              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
00005c  4d1a              LDR      r5,|L13.200|
00005e  4355              MULS     r5,r2,r5
000060  6005              STR      r5,[r0,#0]
                  |L13.98|
;;;660            }
;;;661          }
;;;662          break;
000062  e002              B        |L13.106|
                  |L13.100|
;;;663        default:
;;;664          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
000064  4d18              LDR      r5,|L13.200|
000066  6005              STR      r5,[r0,#0]
;;;665          break;
000068  bf00              NOP      
                  |L13.106|
00006a  bf00              NOP                            ;638
;;;666      }
;;;667      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;668      /* Get HCLK prescaler */
;;;669      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
00006c  4d15              LDR      r5,|L13.196|
00006e  686d              LDR      r5,[r5,#4]
000070  f00501f0          AND      r1,r5,#0xf0
;;;670      tmp = tmp >> 4;
000074  0909              LSRS     r1,r1,#4
;;;671      presc = APBAHBPrescTable[tmp];
000076  4d16              LDR      r5,|L13.208|
000078  5c6c              LDRB     r4,[r5,r1]
;;;672      /* HCLK clock frequency */
;;;673      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00007a  6805              LDR      r5,[r0,#0]
00007c  40e5              LSRS     r5,r5,r4
00007e  6045              STR      r5,[r0,#4]
;;;674      /* Get PCLK1 prescaler */
;;;675      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000080  4d10              LDR      r5,|L13.196|
000082  686d              LDR      r5,[r5,#4]
000084  f40561e0          AND      r1,r5,#0x700
;;;676      tmp = tmp >> 8;
000088  0a09              LSRS     r1,r1,#8
;;;677      presc = APBAHBPrescTable[tmp];
00008a  4d11              LDR      r5,|L13.208|
00008c  5c6c              LDRB     r4,[r5,r1]
;;;678      /* PCLK1 clock frequency */
;;;679      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00008e  6845              LDR      r5,[r0,#4]
000090  40e5              LSRS     r5,r5,r4
000092  6085              STR      r5,[r0,#8]
;;;680      /* Get PCLK2 prescaler */
;;;681      tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000094  4d0b              LDR      r5,|L13.196|
000096  686d              LDR      r5,[r5,#4]
000098  f4055160          AND      r1,r5,#0x3800
;;;682      tmp = tmp >> 11;
00009c  0ac9              LSRS     r1,r1,#11
;;;683      presc = APBAHBPrescTable[tmp];
00009e  4d0c              LDR      r5,|L13.208|
0000a0  5c6c              LDRB     r4,[r5,r1]
;;;684      /* PCLK2 clock frequency */
;;;685      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000a2  6845              LDR      r5,[r0,#4]
0000a4  40e5              LSRS     r5,r5,r4
0000a6  60c5              STR      r5,[r0,#0xc]
;;;686      /* Get ADCCLK prescaler */
;;;687      tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
0000a8  4d06              LDR      r5,|L13.196|
0000aa  686d              LDR      r5,[r5,#4]
0000ac  f4054140          AND      r1,r5,#0xc000
;;;688      tmp = tmp >> 14;
0000b0  0b89              LSRS     r1,r1,#14
;;;689      presc = ADCPrescTable[tmp];
0000b2  4d07              LDR      r5,|L13.208|
0000b4  3510              ADDS     r5,r5,#0x10
0000b6  5c6c              LDRB     r4,[r5,r1]
;;;690      /* ADCCLK clock frequency */
;;;691      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
0000b8  68c5              LDR      r5,[r0,#0xc]
0000ba  fbb5f5f4          UDIV     r5,r5,r4
0000be  6105              STR      r5,[r0,#0x10]
;;;692    }
0000c0  bd30              POP      {r4,r5,pc}
;;;693    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L13.196|
                          DCD      0x40021000
                  |L13.200|
                          DCD      0x007a1200
                  |L13.204|
                          DCD      0x003d0900
                  |L13.208|
                          DCD      ||.data||

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;906      */
;;;907    FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;908    {
000002  4601              MOV      r1,r0
;;;909      uint32_t tmp = 0;
000004  2200              MOVS     r2,#0
;;;910      uint32_t statusreg = 0;
000006  2300              MOVS     r3,#0
;;;911      FlagStatus bitstatus = RESET;
000008  2000              MOVS     r0,#0
;;;912      /* Check the parameters */
;;;913      assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;914      /* Get the RCC register index */
;;;915      tmp = RCC_FLAG >> 5;
00000a  114a              ASRS     r2,r1,#5
;;;916      if (tmp == 1)               /* The flag to check is in CR register */
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L14.22|
;;;917      {
;;;918        statusreg = RCC->CR;
000010  4c09              LDR      r4,|L14.56|
000012  6823              LDR      r3,[r4,#0]
000014  e006              B        |L14.36|
                  |L14.22|
;;;919      }
;;;920      else if (tmp == 2)          /* The flag to check is in BDCR register */
000016  2a02              CMP      r2,#2
000018  d102              BNE      |L14.32|
;;;921      {
;;;922        statusreg = RCC->BDCR;
00001a  4c07              LDR      r4,|L14.56|
00001c  6a23              LDR      r3,[r4,#0x20]
00001e  e001              B        |L14.36|
                  |L14.32|
;;;923      }
;;;924      else                       /* The flag to check is in CSR register */
;;;925      {
;;;926        statusreg = RCC->CSR;
000020  4c05              LDR      r4,|L14.56|
000022  6a63              LDR      r3,[r4,#0x24]
                  |L14.36|
;;;927      }
;;;928      /* Get the flag position */
;;;929      tmp = RCC_FLAG & FLAG_Mask;
000024  f001021f          AND      r2,r1,#0x1f
;;;930      if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000028  2401              MOVS     r4,#1
00002a  4094              LSLS     r4,r4,r2
00002c  421c              TST      r4,r3
00002e  d001              BEQ      |L14.52|
;;;931      {
;;;932        bitstatus = SET;
000030  2001              MOVS     r0,#1
000032  e000              B        |L14.54|
                  |L14.52|
;;;933      }
;;;934      else
;;;935      {
;;;936        bitstatus = RESET;
000034  2000              MOVS     r0,#0
                  |L14.54|
;;;937      }
;;;938      /* Return the flag status */
;;;939      return bitstatus;
;;;940    }
000036  bd10              POP      {r4,pc}
;;;941    
                          ENDP

                  |L14.56|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;967      */
;;;968    ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4601              MOV      r1,r0
;;;969    {
;;;970      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;971      /* Check the parameters */
;;;972      assert_param(IS_RCC_GET_IT(RCC_IT));
;;;973      /* Check the status of the specified RCC interrupt */
;;;974      if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L15.20|
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
00000a  d001              BEQ      |L15.16|
;;;975      {
;;;976        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L15.18|
                  |L15.16|
;;;977      }
;;;978      else
;;;979      {
;;;980        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L15.18|
;;;981      }
;;;982      /* Return the RCC_IT status */
;;;983      return  bitstatus;
;;;984    }
000012  4770              BX       lr
;;;985    
                          ENDP

                  |L15.20|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;377      */
;;;378    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;379    {
;;;380      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;381    }
000008  4770              BX       lr
;;;382    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;398      */
;;;399    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  2100              MOVS     r1,#0
;;;400    {
;;;401      uint32_t tmpreg = 0;
;;;402      /* Check the parameters */
;;;403      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;404      tmpreg = RCC->CFGR;
000002  4a03              LDR      r2,|L17.16|
000004  6851              LDR      r1,[r2,#4]
;;;405      /* Clear HPRE[3:0] bits */
;;;406      tmpreg &= CFGR_HPRE_Reset_Mask;
000006  f02101f0          BIC      r1,r1,#0xf0
;;;407      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;408      tmpreg |= RCC_SYSCLK;
00000a  4301              ORRS     r1,r1,r0
;;;409      /* Store the new value */
;;;410      RCC->CFGR = tmpreg;
00000c  6051              STR      r1,[r2,#4]
;;;411    }
00000e  4770              BX       lr
;;;412    
                          ENDP

                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;208      */
;;;209    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  4911              LDR      r1,|L18.72|
;;;210    {
;;;211      /* Check the parameters */
;;;212      assert_param(IS_RCC_HSE(RCC_HSE));
;;;213      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;214      /* Reset HSEON bit */
;;;215      RCC->CR &= CR_HSEON_Reset;
000002  6809              LDR      r1,[r1,#0]
000004  f4213180          BIC      r1,r1,#0x10000
000008  4a0f              LDR      r2,|L18.72|
00000a  6011              STR      r1,[r2,#0]
;;;216      /* Reset HSEBYP bit */
;;;217      RCC->CR &= CR_HSEBYP_Reset;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  f4212180          BIC      r1,r1,#0x40000
000014  6011              STR      r1,[r2,#0]
;;;218      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;219      switch(RCC_HSE)
000016  f5b03f80          CMP      r0,#0x10000
00001a  d003              BEQ      |L18.36|
00001c  f5b02f80          CMP      r0,#0x40000
000020  d10e              BNE      |L18.64|
000022  e006              B        |L18.50|
                  |L18.36|
;;;220      {
;;;221        case RCC_HSE_ON:
;;;222          /* Set HSEON bit */
;;;223          RCC->CR |= CR_HSEON_Set;
000024  4908              LDR      r1,|L18.72|
000026  6809              LDR      r1,[r1,#0]
000028  f4413180          ORR      r1,r1,#0x10000
00002c  4a06              LDR      r2,|L18.72|
00002e  6011              STR      r1,[r2,#0]
;;;224          break;
000030  e007              B        |L18.66|
                  |L18.50|
;;;225          
;;;226        case RCC_HSE_Bypass:
;;;227          /* Set HSEBYP and HSEON bits */
;;;228          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000032  4905              LDR      r1,|L18.72|
000034  6809              LDR      r1,[r1,#0]
000036  f44121a0          ORR      r1,r1,#0x50000
00003a  4a03              LDR      r2,|L18.72|
00003c  6011              STR      r1,[r2,#0]
;;;229          break;
00003e  e000              B        |L18.66|
                  |L18.64|
;;;230          
;;;231        default:
;;;232          break;
000040  bf00              NOP      
                  |L18.66|
000042  bf00              NOP                            ;224
;;;233      }
;;;234    }
000044  4770              BX       lr
;;;235    
                          ENDP

000046  0000              DCW      0x0000
                  |L18.72|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;294      */
;;;295    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;296    {
;;;297      /* Check the parameters */
;;;298      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;299      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;300    }
000004  4770              BX       lr
;;;301    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;477      */
;;;478    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L20.14|
;;;479    {
;;;480      /* Check the parameters */
;;;481      assert_param(IS_RCC_IT(RCC_IT));
;;;482      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;486        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000002  4a07              LDR      r2,|L20.32|
000004  7a52              LDRB     r2,[r2,#9]
000006  4302              ORRS     r2,r2,r0
000008  4b05              LDR      r3,|L20.32|
00000a  725a              STRB     r2,[r3,#9]
00000c  e006              B        |L20.28|
                  |L20.14|
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;491        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
00000e  4a04              LDR      r2,|L20.32|
000010  7a52              LDRB     r2,[r2,#9]
000012  43c3              MVNS     r3,r0
000014  b2db              UXTB     r3,r3
000016  401a              ANDS     r2,r2,r3
000018  4b01              LDR      r3,|L20.32|
00001a  725a              STRB     r2,[r3,#9]
                  |L20.28|
;;;492      }
;;;493    }
00001c  4770              BX       lr
;;;494    
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;546      */
;;;547    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  2100              MOVS     r1,#0
;;;548    {
;;;549      /* Check the parameters */
;;;550      assert_param(IS_RCC_LSE(RCC_LSE));
;;;551      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;552      /* Reset LSEON bit */
;;;553      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  4a0b              LDR      r2,|L21.48|
000004  7011              STRB     r1,[r2,#0]
;;;554      /* Reset LSEBYP bit */
;;;555      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  4a0a              LDR      r2,|L21.48|
000008  3a20              SUBS     r2,r2,#0x20
00000a  f8821020          STRB     r1,[r2,#0x20]
;;;556      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;557      switch(RCC_LSE)
00000e  2801              CMP      r0,#1
000010  d002              BEQ      |L21.24|
000012  2804              CMP      r0,#4
000014  d108              BNE      |L21.40|
000016  e003              B        |L21.32|
                  |L21.24|
;;;558      {
;;;559        case RCC_LSE_ON:
;;;560          /* Set LSEON bit */
;;;561          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
000018  2101              MOVS     r1,#1
00001a  4a05              LDR      r2,|L21.48|
00001c  7011              STRB     r1,[r2,#0]
;;;562          break;
00001e  e004              B        |L21.42|
                  |L21.32|
;;;563          
;;;564        case RCC_LSE_Bypass:
;;;565          /* Set LSEBYP and LSEON bits */
;;;566          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000020  2105              MOVS     r1,#5
000022  4a03              LDR      r2,|L21.48|
000024  7011              STRB     r1,[r2,#0]
;;;567          break;            
000026  e000              B        |L21.42|
                  |L21.40|
;;;568          
;;;569        default:
;;;570          break;      
000028  bf00              NOP      
                  |L21.42|
00002a  bf00              NOP                            ;562
;;;571      }
;;;572    }
00002c  4770              BX       lr
;;;573    
                          ENDP

00002e  0000              DCW      0x0000
                  |L21.48|
                          DCD      0x40021020

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;580      */
;;;581    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;582    {
;;;583      /* Check the parameters */
;;;584      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;585      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;586    }
000004  4770              BX       lr
;;;587    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;881      */
;;;882    void RCC_MCOConfig(uint8_t RCC_MCO)
000000  4901              LDR      r1,|L23.8|
;;;883    {
;;;884      /* Check the parameters */
;;;885      assert_param(IS_RCC_MCO(RCC_MCO));
;;;886      /* Perform Byte access to MCO[2:0] bits to select the MCO source */
;;;887      *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000002  71c8              STRB     r0,[r1,#7]
;;;888    }
000004  4770              BX       lr
;;;889    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;424      */
;;;425    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  2100              MOVS     r1,#0
;;;426    {
;;;427      uint32_t tmpreg = 0;
;;;428      /* Check the parameters */
;;;429      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;430      tmpreg = RCC->CFGR;
000002  4a03              LDR      r2,|L24.16|
000004  6851              LDR      r1,[r2,#4]
;;;431      /* Clear PPRE1[2:0] bits */
;;;432      tmpreg &= CFGR_PPRE1_Reset_Mask;
000006  f42161e0          BIC      r1,r1,#0x700
;;;433      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;434      tmpreg |= RCC_HCLK;
00000a  4301              ORRS     r1,r1,r0
;;;435      /* Store the new value */
;;;436      RCC->CFGR = tmpreg;
00000c  6051              STR      r1,[r2,#4]
;;;437    }
00000e  4770              BX       lr
;;;438    
                          ENDP

                  |L24.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;450      */
;;;451    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  2100              MOVS     r1,#0
;;;452    {
;;;453      uint32_t tmpreg = 0;
;;;454      /* Check the parameters */
;;;455      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;456      tmpreg = RCC->CFGR;
000002  4a04              LDR      r2,|L25.20|
000004  6851              LDR      r1,[r2,#4]
;;;457      /* Clear PPRE2[2:0] bits */
;;;458      tmpreg &= CFGR_PPRE2_Reset_Mask;
000006  f4215160          BIC      r1,r1,#0x3800
;;;459      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;460      tmpreg |= RCC_HCLK << 3;
00000a  ea4101c0          ORR      r1,r1,r0,LSL #3
;;;461      /* Store the new value */
;;;462      RCC->CFGR = tmpreg;
00000e  6051              STR      r1,[r2,#4]
;;;463    }
000010  4770              BX       lr
;;;464    
                          ENDP

000012  0000              DCW      0x0000
                  |L25.20|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;338      */
;;;339    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;340    {
;;;341      /* Check the parameters */
;;;342      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;343      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;344    }
000004  4770              BX       lr
;;;345    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;316      */
;;;317    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  2200              MOVS     r2,#0
;;;318    {
;;;319      uint32_t tmpreg = 0;
;;;320      /* Check the parameters */
;;;321      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;322      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;323      tmpreg = RCC->CFGR;
000002  4b05              LDR      r3,|L27.24|
000004  685a              LDR      r2,[r3,#4]
;;;324      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;325      tmpreg &= CFGR_PLL_Mask;
000006  f422127c          BIC      r2,r2,#0x3f0000
;;;326      /* Set the PLL configuration bits */
;;;327      tmpreg |= RCC_PLLSource | RCC_PLLMul;
00000a  ea400301          ORR      r3,r0,r1
00000e  431a              ORRS     r2,r2,r3
;;;328      /* Store the new value */
;;;329      RCC->CFGR = tmpreg;
000010  4b01              LDR      r3,|L27.24|
000012  605a              STR      r2,[r3,#4]
;;;330    }
000014  4770              BX       lr
;;;331    
                          ENDP

000016  0000              DCW      0x0000
                  |L27.24|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;615      */
;;;616    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;617    {
;;;618      /* Check the parameters */
;;;619      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;620      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;621    }
000004  4770              BX       lr
;;;622    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;599      */
;;;600    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L29.12|
;;;601    {
;;;602      /* Check the parameters */
;;;603      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;604      /* Select the RTC clock source */
;;;605      RCC->BDCR |= RCC_RTCCLKSource;
000002  6a09              LDR      r1,[r1,#0x20]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L29.12|
000008  6211              STR      r1,[r2,#0x20]
;;;606    }
00000a  4770              BX       lr
;;;607    
                          ENDP

                  |L29.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;354      */
;;;355    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  2100              MOVS     r1,#0
;;;356    {
;;;357      uint32_t tmpreg = 0;
;;;358      /* Check the parameters */
;;;359      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;360      tmpreg = RCC->CFGR;
000002  4a03              LDR      r2,|L30.16|
000004  6851              LDR      r1,[r2,#4]
;;;361      /* Clear SW[1:0] bits */
;;;362      tmpreg &= CFGR_SW_Mask;
000006  f0210103          BIC      r1,r1,#3
;;;363      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;364      tmpreg |= RCC_SYSCLKSource;
00000a  4301              ORRS     r1,r1,r0
;;;365      /* Store the new value */
;;;366      RCC->CFGR = tmpreg;
00000c  6051              STR      r1,[r2,#4]
;;;367    }
00000e  4770              BX       lr
;;;368    
                          ENDP

                  |L30.16|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;504      */
;;;505    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4901              LDR      r1,|L31.8|
;;;506    {
;;;507      /* Check the parameters */
;;;508      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;509      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  6008              STR      r0,[r1,#0]
;;;510    }
000004  4770              BX       lr
;;;511    
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      0x424200d8

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;242      */
;;;243    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b570              PUSH     {r4-r6,lr}
;;;244    {
;;;245      __IO uint32_t StartUpCounter = 0;
000002  2400              MOVS     r4,#0
;;;246      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;247      FlagStatus HSEStatus = RESET;
000006  2600              MOVS     r6,#0
;;;248      
;;;249      /* Wait till HSE is ready and if Time out is reached exit */
;;;250      do
000008  bf00              NOP      
                  |L32.10|
;;;251      {
;;;252        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00000a  2031              MOVS     r0,#0x31
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  4606              MOV      r6,r0
;;;253        StartUpCounter++;  
000012  1c64              ADDS     r4,r4,#1
;;;254      } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
000014  b916              CBNZ     r6,|L32.28|
000016  f5b46fa0          CMP      r4,#0x500
00001a  d1f6              BNE      |L32.10|
                  |L32.28|
;;;255      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001c  2031              MOVS     r0,#0x31
00001e  f7fffffe          BL       RCC_GetFlagStatus
000022  b108              CBZ      r0,|L32.40|
;;;256      {
;;;257        status = SUCCESS;
000024  2501              MOVS     r5,#1
000026  e000              B        |L32.42|
                  |L32.40|
;;;258      }
;;;259      else
;;;260      {
;;;261        status = ERROR;
000028  2500              MOVS     r5,#0
                  |L32.42|
;;;262      }  
;;;263      return (status);
00002a  4628              MOV      r0,r5
;;;264    }
00002c  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  02040608          DCB      0x02,0x04,0x06,0x08

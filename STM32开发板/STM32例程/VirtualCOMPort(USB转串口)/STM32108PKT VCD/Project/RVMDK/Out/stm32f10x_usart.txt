; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Out\stm32f10x_usart.o --depend=.\Out\stm32f10x_usart.d --device=DARMSTM --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Core\CM3 -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I"D:\Program Files\KeilARM350\ARM\INC\ST\STM32F10x" ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;832      */
;;;833    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  43ca              MVNS     r2,r1
;;;834    {
;;;835      /* Check the parameters */
;;;836      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;837      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;838      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;839       
;;;840      USARTx->SR = (uint16_t)~USART_FLAG;
000002  8002              STRH     r2,[r0,#0]
;;;841    }
000004  4770              BX       lr
;;;842    
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;931      */
;;;932    void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b510              PUSH     {r4,lr}
;;;933    {
;;;934      uint16_t bitpos = 0x00, itmask = 0x00;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;935      /* Check the parameters */
;;;936      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;937      assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;938      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;939      
;;;940      bitpos = USART_IT >> 0x08;
000006  120a              ASRS     r2,r1,#8
;;;941      itmask = (uint16_t)((uint16_t)0x01 << bitpos);
000008  2401              MOVS     r4,#1
00000a  4094              LSLS     r4,r4,r2
00000c  b2a3              UXTH     r3,r4
;;;942      USARTx->SR = (uint16_t)~itmask;
00000e  43dc              MVNS     r4,r3
000010  8004              STRH     r4,[r0,#0]
;;;943    }
000012  bd10              POP      {r4,pc}
;;;944    /**
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;274      */
;;;275    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;276    {
;;;277      uint32_t tmpreg = 0x00;
000002  2200              MOVS     r2,#0
;;;278      /* Check the parameters */
;;;279      assert_param(IS_USART_123_PERIPH(USARTx));
;;;280      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;281      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;282      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;283      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;284      
;;;285    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;286      tmpreg = USARTx->CR2;
000004  8a02              LDRH     r2,[r0,#0x10]
;;;287      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;288      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000006  f24f03ff          MOV      r3,#0xf0ff
00000a  401a              ANDS     r2,r2,r3
;;;289      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;290      /* Set CLKEN bit according to USART_Clock value */
;;;291      /* Set CPOL bit according to USART_CPOL value */
;;;292      /* Set CPHA bit according to USART_CPHA value */
;;;293      /* Set LBCL bit according to USART_LastBit value */
;;;294      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00000c  880b              LDRH     r3,[r1,#0]
00000e  884c              LDRH     r4,[r1,#2]
000010  4323              ORRS     r3,r3,r4
000012  888c              LDRH     r4,[r1,#4]
000014  4323              ORRS     r3,r3,r4
000016  88cc              LDRH     r4,[r1,#6]
000018  4323              ORRS     r3,r3,r4
00001a  431a              ORRS     r2,r2,r3
;;;295                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;296      /* Write to USART CR2 */
;;;297      USARTx->CR2 = (uint16_t)tmpreg;
00001c  8202              STRH     r2,[r0,#0x10]
;;;298    }
00001e  bd10              POP      {r4,pc}
;;;299    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;305      */
;;;306    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;307    {
;;;308      /* USART_ClockInitStruct members default value */
;;;309      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;310      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;311      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;312      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;313    }
00000a  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;323      */
;;;324    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;325    {
;;;326      /* Check the parameters */
;;;327      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;328      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;329      
;;;330      if (NewState != DISABLE)
;;;331      {
;;;332        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;333        USARTx->CR1 |= CR1_UE_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f4425200          ORR      r2,r2,#0x2000
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;334      }
;;;335      else
;;;336      {
;;;337        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;338        USARTx->CR1 &= CR1_UE_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64d73ff          MOV      r3,#0xdfff
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L5.22|
;;;339      }
;;;340    }
000016  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;416      */
;;;417    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_USART_1234_PERIPH(USARTx));
;;;421      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;422      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;423      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L6.12|
;;;424      {
;;;425        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;426           DMAR bits in the USART CR3 register */
;;;427        USARTx->CR3 |= USART_DMAReq;
000004  8a83              LDRH     r3,[r0,#0x14]
000006  430b              ORRS     r3,r3,r1
000008  8283              STRH     r3,[r0,#0x14]
00000a  e004              B        |L6.22|
                  |L6.12|
;;;428      }
;;;429      else
;;;430      {
;;;431        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;432           DMAR bits in the USART CR3 register */
;;;433        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
00000c  8a83              LDRH     r3,[r0,#0x14]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  8283              STRH     r3,[r0,#0x14]
                  |L6.22|
;;;434      }
;;;435    }
000016  bd10              POP      {r4,pc}
;;;436    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;132      */
;;;133    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;134    {
000002  4604              MOV      r4,r0
;;;135      /* Check the parameters */
;;;136      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;137      switch (*(uint32_t*)&USARTx)
000004  4923              LDR      r1,|L7.148|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d02b              BEQ      |L7.100|
00000c  dc06              BGT      |L7.28|
00000e  4822              LDR      r0,|L7.152|
000010  1820              ADDS     r0,r4,r0
000012  d013              BEQ      |L7.60|
000014  f5b06f80          CMP      r0,#0x400
000018  d138              BNE      |L7.140|
00001a  e019              B        |L7.80|
                  |L7.28|
00001c  f5b06f80          CMP      r0,#0x400
000020  d02a              BEQ      |L7.120|
000022  f5b04f6c          CMP      r0,#0xec00
000026  d131              BNE      |L7.140|
;;;138      {
;;;139        case USART1_BASE:
;;;140          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000028  2101              MOVS     r1,#1
00002a  0388              LSLS     r0,r1,#14
00002c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;141          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000030  2100              MOVS     r1,#0
000032  f44f4080          MOV      r0,#0x4000
000036  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;142          break;
00003a  e028              B        |L7.142|
                  |L7.60|
;;;143        case USART2_BASE:
;;;144          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  0448              LSLS     r0,r1,#17
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;145          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000044  2100              MOVS     r1,#0
000046  f44f3000          MOV      r0,#0x20000
00004a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;146          break;
00004e  e01e              B        |L7.142|
                  |L7.80|
;;;147        case USART3_BASE:
;;;148          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000050  2101              MOVS     r1,#1
000052  0488              LSLS     r0,r1,#18
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;149          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000058  2100              MOVS     r1,#0
00005a  f44f2080          MOV      r0,#0x40000
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;150          break;
000062  e014              B        |L7.142|
                  |L7.100|
;;;151        
;;;152        case UART4_BASE:
;;;153          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000064  2101              MOVS     r1,#1
000066  04c8              LSLS     r0,r1,#19
000068  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;154          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
00006c  2100              MOVS     r1,#0
00006e  f44f2000          MOV      r0,#0x80000
000072  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;155          break;
000076  e00a              B        |L7.142|
                  |L7.120|
;;;156        
;;;157        case UART5_BASE:
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000078  2101              MOVS     r1,#1
00007a  0508              LSLS     r0,r1,#20
00007c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000080  2100              MOVS     r1,#0
000082  f44f1080          MOV      r0,#0x100000
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;160          break;            
00008a  e000              B        |L7.142|
                  |L7.140|
;;;161        default:
;;;162          break;
00008c  bf00              NOP      
                  |L7.142|
00008e  bf00              NOP                            ;142
;;;163      }
;;;164    }
000090  bd10              POP      {r4,pc}
;;;165    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      0x40004c00
                  |L7.152|
                          DCD      0xbfffbc00

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;788      */
;;;789    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;790    {
;;;791      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;792      /* Check the parameters */
;;;793      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;794      assert_param(IS_USART_FLAG(USART_FLAG));
;;;795      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;796      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000004  8813              LDRH     r3,[r2,#0]
000006  420b              TST      r3,r1
000008  d001              BEQ      |L8.14|
;;;797      {
;;;798        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L8.16|
                  |L8.14|
;;;799      }
;;;800      else
;;;801      {
;;;802        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L8.16|
;;;803      }
;;;804      return bitstatus;
;;;805    }
000010  4770              BX       lr
;;;806    
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;861      */
;;;862    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;863    {
000002  4602              MOV      r2,r0
;;;864      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
000008  2500              MOVS     r5,#0
;;;865      ITStatus bitstatus = RESET;
00000a  2000              MOVS     r0,#0
;;;866      /* Check the parameters */
;;;867      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;868      assert_param(IS_USART_GET_IT(USART_IT));
;;;869      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
;;;870      
;;;871      /* Get the USART register index */
;;;872      usartreg = (((uint8_t)USART_IT) >> 0x05);
00000c  f3c11542          UBFX     r5,r1,#5,#3
;;;873      /* Get the interrupt position */
;;;874      itmask = USART_IT & IT_Mask;
000010  f001041f          AND      r4,r1,#0x1f
;;;875      itmask = (uint32_t)0x01 << itmask;
000014  2601              MOVS     r6,#1
000016  fa06f404          LSL      r4,r6,r4
;;;876      
;;;877      if (usartreg == 0x01) /* The IT  is in CR1 register */
00001a  2d01              CMP      r5,#1
00001c  d102              BNE      |L9.36|
;;;878      {
;;;879        itmask &= USARTx->CR1;
00001e  8996              LDRH     r6,[r2,#0xc]
000020  4034              ANDS     r4,r4,r6
000022  e006              B        |L9.50|
                  |L9.36|
;;;880      }
;;;881      else if (usartreg == 0x02) /* The IT  is in CR2 register */
000024  2d02              CMP      r5,#2
000026  d102              BNE      |L9.46|
;;;882      {
;;;883        itmask &= USARTx->CR2;
000028  8a16              LDRH     r6,[r2,#0x10]
00002a  4034              ANDS     r4,r4,r6
00002c  e001              B        |L9.50|
                  |L9.46|
;;;884      }
;;;885      else /* The IT  is in CR3 register */
;;;886      {
;;;887        itmask &= USARTx->CR3;
00002e  8a96              LDRH     r6,[r2,#0x14]
000030  4034              ANDS     r4,r4,r6
                  |L9.50|
;;;888      }
;;;889      
;;;890      bitpos = USART_IT >> 0x08;
000032  120b              ASRS     r3,r1,#8
;;;891      bitpos = (uint32_t)0x01 << bitpos;
000034  2601              MOVS     r6,#1
000036  fa06f303          LSL      r3,r6,r3
;;;892      bitpos &= USARTx->SR;
00003a  8816              LDRH     r6,[r2,#0]
00003c  4033              ANDS     r3,r3,r6
;;;893      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00003e  b114              CBZ      r4,|L9.70|
000040  b10b              CBZ      r3,|L9.70|
;;;894      {
;;;895        bitstatus = SET;
000042  2001              MOVS     r0,#1
000044  e000              B        |L9.72|
                  |L9.70|
;;;896      }
;;;897      else
;;;898      {
;;;899        bitstatus = RESET;
000046  2000              MOVS     r0,#0
                  |L9.72|
;;;900      }
;;;901      
;;;902      return bitstatus;  
;;;903    }
000048  bd70              POP      {r4-r6,pc}
;;;904    
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;703      */
;;;704    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L10.12|
;;;705    {
;;;706      /* Check the parameters */
;;;707      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;708      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;709      
;;;710      if (NewState != DISABLE)
;;;711      {
;;;712        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;713        USARTx->CR3 |= CR3_HDSEL_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420208          ORR      r2,r2,#8
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L10.22|
                  |L10.12|
;;;714      }
;;;715      else
;;;716      {
;;;717        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;718        USARTx->CR3 &= CR3_HDSEL_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L10.22|
;;;719      }
;;;720    }
000016  4770              BX       lr
;;;721    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;364      */
;;;365    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  b5f0              PUSH     {r4-r7,lr}
;;;366    {
;;;367      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;368      uint32_t usartxbase = 0x00;
000008  2300              MOVS     r3,#0
;;;369      /* Check the parameters */
;;;370      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;371      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;372      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;373      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;374      usartxbase = (*(uint32_t*)&(USARTx));
00000a  4603              MOV      r3,r0
;;;375      /* Get the USART register index */
;;;376      usartreg = (((uint8_t)USART_IT) >> 0x05);
00000c  f3c11442          UBFX     r4,r1,#5,#3
;;;377      /* Get the interrupt position */
;;;378      itpos = USART_IT & IT_Mask;
000010  f001051f          AND      r5,r1,#0x1f
;;;379      itmask = (((uint32_t)0x01) << itpos);
000014  2701              MOVS     r7,#1
000016  fa07f605          LSL      r6,r7,r5
;;;380        
;;;381      if (usartreg == 0x01) /* The IT is in CR1 register */
00001a  2c01              CMP      r4,#1
00001c  d101              BNE      |L11.34|
;;;382      {
;;;383        usartxbase += 0x0C;
00001e  330c              ADDS     r3,r3,#0xc
000020  e004              B        |L11.44|
                  |L11.34|
;;;384      }
;;;385      else if (usartreg == 0x02) /* The IT is in CR2 register */
000022  2c02              CMP      r4,#2
000024  d101              BNE      |L11.42|
;;;386      {
;;;387        usartxbase += 0x10;
000026  3310              ADDS     r3,r3,#0x10
000028  e000              B        |L11.44|
                  |L11.42|
;;;388      }
;;;389      else /* The IT is in CR3 register */
;;;390      {
;;;391        usartxbase += 0x14; 
00002a  3314              ADDS     r3,r3,#0x14
                  |L11.44|
;;;392      }
;;;393      if (NewState != DISABLE)
00002c  b11a              CBZ      r2,|L11.54|
;;;394      {
;;;395        *(__IO uint32_t*)usartxbase  |= itmask;
00002e  681f              LDR      r7,[r3,#0]
000030  4337              ORRS     r7,r7,r6
000032  601f              STR      r7,[r3,#0]
000034  e002              B        |L11.60|
                  |L11.54|
;;;396      }
;;;397      else
;;;398      {
;;;399        *(__IO uint32_t*)usartxbase &= ~itmask;
000036  681f              LDR      r7,[r3,#0]
000038  43b7              BICS     r7,r7,r6
00003a  601f              STR      r7,[r3,#0]
                  |L11.60|
;;;400      }
;;;401    }
00003c  bdf0              POP      {r4-r7,pc}
;;;402    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;176      */
;;;177    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;178    {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;179      uint32_t tmpreg = 0x00, apbclock = 0x00;
00000a  2600              MOVS     r6,#0
00000c  2700              MOVS     r7,#0
;;;180      uint32_t integerdivider = 0x00;
00000e  bf00              NOP      
;;;181      uint32_t fractionaldivider = 0x00;
000010  bf00              NOP      
;;;182      uint32_t usartxbase = 0;
000012  46b2              MOV      r10,r6
;;;183      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;184      /* Check the parameters */
;;;185      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;186      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;187      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;188      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;189      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;190      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;191      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;192      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;193      assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
;;;194    
;;;195      usartxbase = (*(uint32_t*)&USARTx);
000014  46a2              MOV      r10,r4
;;;196    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;197      tmpreg = USARTx->CR2;
000016  8a26              LDRH     r6,[r4,#0x10]
;;;198      /* Clear STOP[13:12] bits */
;;;199      tmpreg &= CR2_STOP_CLEAR_Mask;
000018  f64c70ff          MOV      r0,#0xcfff
00001c  4006              ANDS     r6,r6,r0
;;;200      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;201      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;202      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
00001e  88e8              LDRH     r0,[r5,#6]
000020  4306              ORRS     r6,r6,r0
;;;203      
;;;204      /* Write to USART CR2 */
;;;205      USARTx->CR2 = (uint16_t)tmpreg;
000022  8226              STRH     r6,[r4,#0x10]
;;;206    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;207      tmpreg = USARTx->CR1;
000024  89a6              LDRH     r6,[r4,#0xc]
;;;208      /* Clear M, PCE, PS, TE and RE bits */
;;;209      tmpreg &= CR1_CLEAR_Mask;
000026  f64e10f3          MOV      r0,#0xe9f3
00002a  4006              ANDS     r6,r6,r0
;;;210      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;211      /* Set the M bits according to USART_WordLength value */
;;;212      /* Set PCE and PS bits according to USART_Parity value */
;;;213      /* Set TE and RE bits according to USART_Mode value */
;;;214      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00002c  88a8              LDRH     r0,[r5,#4]
00002e  8929              LDRH     r1,[r5,#8]
000030  4308              ORRS     r0,r0,r1
000032  8969              LDRH     r1,[r5,#0xa]
000034  4308              ORRS     r0,r0,r1
000036  4306              ORRS     r6,r6,r0
;;;215                USART_InitStruct->USART_Mode;
;;;216      /* Write to USART CR1 */
;;;217      USARTx->CR1 = (uint16_t)tmpreg;
000038  81a6              STRH     r6,[r4,#0xc]
;;;218    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;219      tmpreg = USARTx->CR3;
00003a  8aa6              LDRH     r6,[r4,#0x14]
;;;220      /* Clear CTSE and RTSE bits */
;;;221      tmpreg &= CR3_CLEAR_Mask;
00003c  f64f40ff          MOV      r0,#0xfcff
000040  4006              ANDS     r6,r6,r0
;;;222      /* Configure the USART HFC -------------------------------------------------*/
;;;223      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;224      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000042  89a8              LDRH     r0,[r5,#0xc]
000044  4306              ORRS     r6,r6,r0
;;;225      /* Write to USART CR3 */
;;;226      USARTx->CR3 = (uint16_t)tmpreg;
000046  82a6              STRH     r6,[r4,#0x14]
;;;227    /*---------------------------- USART BRR Configuration -----------------------*/
;;;228      /* Configure the USART Baud Rate -------------------------------------------*/
;;;229      RCC_GetClocksFreq(&RCC_ClocksStatus);
000048  a801              ADD      r0,sp,#4
00004a  f7fffffe          BL       RCC_GetClocksFreq
;;;230      if (usartxbase == USART1_BASE)
00004e  4654              MOV      r4,r10
000050  4811              LDR      r0,|L12.152|
000052  4582              CMP      r10,r0
000054  d101              BNE      |L12.90|
;;;231      {
;;;232        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000056  9f04              LDR      r7,[sp,#0x10]
000058  e000              B        |L12.92|
                  |L12.90|
;;;233      }
;;;234      else
;;;235      {
;;;236        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
00005a  9f03              LDR      r7,[sp,#0xc]
                  |L12.92|
;;;237      }
;;;238      /* Determine the integer part */
;;;239      integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
00005c  eb0700c7          ADD      r0,r7,r7,LSL #3
000060  eb001007          ADD      r0,r0,r7,LSL #4
000064  6829              LDR      r1,[r5,#0]
000066  0089              LSLS     r1,r1,#2
000068  fbb0f8f1          UDIV     r8,r0,r1
;;;240      tmpreg = (integerdivider / 0x64) << 0x04;
00006c  2064              MOVS     r0,#0x64
00006e  fbb8f0f0          UDIV     r0,r8,r0
000072  0106              LSLS     r6,r0,#4
;;;241      /* Determine the fractional part */
;;;242      fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
000074  0930              LSRS     r0,r6,#4
000076  2164              MOVS     r1,#0x64
000078  fb018910          MLS      r9,r1,r0,r8
;;;243      tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((uint8_t)0x0F);
00007c  2132              MOVS     r1,#0x32
00007e  eb011009          ADD      r0,r1,r9,LSL #4
000082  2164              MOVS     r1,#0x64
000084  fbb0f0f1          UDIV     r0,r0,r1
000088  f000000f          AND      r0,r0,#0xf
00008c  4306              ORRS     r6,r6,r0
;;;244      /* Write to USART BRR */
;;;245      USARTx->BRR = (uint16_t)tmpreg;
00008e  8126              STRH     r6,[r4,#8]
;;;246    }
000090  b006              ADD      sp,sp,#0x18
000092  e8bd87f0          POP      {r4-r10,pc}
;;;247    
                          ENDP

000096  0000              DCW      0x0000
                  |L12.152|
                          DCD      0x40013800

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;751      */
;;;752    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;753    {
;;;754      /* Check the parameters */
;;;755      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;756      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;757        
;;;758      if (NewState != DISABLE)
;;;759      {
;;;760        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;761        USARTx->CR3 |= CR3_IREN_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420202          ORR      r2,r2,#2
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;762      }
;;;763      else
;;;764      {
;;;765        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;766        USARTx->CR3 &= CR3_IREN_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L13.22|
;;;767      }
;;;768    }
000016  4770              BX       lr
;;;769    
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;732      */
;;;733    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;734    {
;;;735      /* Check the parameters */
;;;736      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;737      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;738        
;;;739      USARTx->CR3 &= CR3_IRLP_Mask;
000002  f64f73fb          MOV      r3,#0xfffb
000006  401a              ANDS     r2,r2,r3
000008  8282              STRH     r2,[r0,#0x14]
;;;740      USARTx->CR3 |= USART_IrDAMode;
00000a  8a82              LDRH     r2,[r0,#0x14]
00000c  430a              ORRS     r2,r2,r1
00000e  8282              STRH     r2,[r0,#0x14]
;;;741    }
000010  4770              BX       lr
;;;742    
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;516      */
;;;517    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;518    {
;;;519      /* Check the parameters */
;;;520      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;521      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;522      
;;;523      USARTx->CR2 &= CR2_LBDL_Mask;
000002  f64f73df          MOV      r3,#0xffdf
000006  401a              ANDS     r2,r2,r3
000008  8202              STRH     r2,[r0,#0x10]
;;;524      USARTx->CR2 |= USART_LINBreakDetectLength;  
00000a  8a02              LDRH     r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  8202              STRH     r2,[r0,#0x10]
;;;525    }
000010  4770              BX       lr
;;;526    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;535      */
;;;536    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L16.12|
;;;537    {
;;;538      /* Check the parameters */
;;;539      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      
;;;542      if (NewState != DISABLE)
;;;543      {
;;;544        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;545        USARTx->CR2 |= CR2_LINEN_Set;
000002  8a02              LDRH     r2,[r0,#0x10]
000004  f4424280          ORR      r2,r2,#0x4000
000008  8202              STRH     r2,[r0,#0x10]
00000a  e004              B        |L16.22|
                  |L16.12|
;;;546      }
;;;547      else
;;;548      {
;;;549        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;550        USARTx->CR2 &= CR2_LINEN_Reset;
00000c  8a02              LDRH     r2,[r0,#0x10]
00000e  f64b73ff          MOV      r3,#0xbfff
000012  401a              ANDS     r2,r2,r3
000014  8202              STRH     r2,[r0,#0x10]
                  |L16.22|
;;;551      }
;;;552    }
000016  4770              BX       lr
;;;553    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;578      */
;;;579    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  4601              MOV      r1,r0
;;;580    {
;;;581      /* Check the parameters */
;;;582      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;583      
;;;584      /* Receive Data */
;;;585      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  8888              LDRH     r0,[r1,#4]
000004  f3c00008          UBFX     r0,r0,#0,#9
;;;586    }
000008  4770              BX       lr
;;;587    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;486      */
;;;487    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L18.12|
;;;488    {
;;;489      /* Check the parameters */
;;;490      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;491      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;492      
;;;493      if (NewState != DISABLE)
;;;494      {
;;;495        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;496        USARTx->CR1 |= CR1_RWU_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420202          ORR      r2,r2,#2
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L18.22|
                  |L18.12|
;;;497      }
;;;498      else
;;;499      {
;;;500        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;501        USARTx->CR1 &= CR1_RWU_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L18.22|
;;;502      }
;;;503    }
000016  4770              BX       lr
;;;504    
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;594      */
;;;595    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;596    {
;;;597      /* Check the parameters */
;;;598      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;599      
;;;600      /* Send break characters */
;;;601      USARTx->CR1 |= CR1_SBK_Set;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;602    }
000008  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;561      */
;;;562    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10208          UBFX     r2,r1,#0,#9
;;;563    {
;;;564      /* Check the parameters */
;;;565      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;566      assert_param(IS_USART_DATA(Data)); 
;;;567        
;;;568      /* Transmit Data */
;;;569      USARTx->DR = (Data & (uint16_t)0x01FF);
000004  8082              STRH     r2,[r0,#4]
;;;570    }
000006  4770              BX       lr
;;;571    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;444      */
;;;445    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;446    {
;;;447      /* Check the parameters */
;;;448      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;449      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;450        
;;;451      /* Clear the USART address */
;;;452      USARTx->CR2 &= CR2_Address_Mask;
000002  f64f73f0          MOV      r3,#0xfff0
000006  401a              ANDS     r2,r2,r3
000008  8202              STRH     r2,[r0,#0x10]
;;;453      /* Set the USART address node */
;;;454      USARTx->CR2 |= USART_Address;
00000a  8a02              LDRH     r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  8202              STRH     r2,[r0,#0x10]
;;;455    }
000010  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;611      */
;;;612    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;613    {    
;;;614      /* Check the parameters */
;;;615      assert_param(IS_USART_123_PERIPH(USARTx));
;;;616      
;;;617      /* Clear the USART Guard time */
;;;618      USARTx->GTPR &= GTPR_LSB_Mask;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;619      /* Set the USART guard time */
;;;620      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422201          ORR      r2,r2,r1,LSL #8
00000c  8302              STRH     r2,[r0,#0x18]
;;;621    }
00000e  4770              BX       lr
;;;622    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;631      */
;;;632    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;633    { 
;;;634      /* Check the parameters */
;;;635      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;636      
;;;637      /* Clear the USART prescaler */
;;;638      USARTx->GTPR &= GTPR_MSB_Mask;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;639      /* Set the USART prescaler */
;;;640      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;641    }
00000e  4770              BX       lr
;;;642    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;651      */
;;;652    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L24.12|
;;;653    {
;;;654      /* Check the parameters */
;;;655      assert_param(IS_USART_123_PERIPH(USARTx));
;;;656      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;657      if (NewState != DISABLE)
;;;658      {
;;;659        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;660        USARTx->CR3 |= CR3_SCEN_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420220          ORR      r2,r2,#0x20
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L24.22|
                  |L24.12|
;;;661      }
;;;662      else
;;;663      {
;;;664        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;665        USARTx->CR3 &= CR3_SCEN_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L24.22|
;;;666      }
;;;667    }
000016  4770              BX       lr
;;;668    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;677      */
;;;678    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L25.12|
;;;679    {
;;;680      /* Check the parameters */
;;;681      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;682      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;683      if (NewState != DISABLE)
;;;684      {
;;;685        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;686        USARTx->CR3 |= CR3_NACK_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420210          ORR      r2,r2,#0x10
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L25.22|
                  |L25.12|
;;;687      }
;;;688      else
;;;689      {
;;;690        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;691        USARTx->CR3 &= CR3_NACK_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L25.22|
;;;692      }
;;;693    }
000016  4770              BX       lr
;;;694    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;253      */
;;;254    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;255    {
;;;256      /* USART_InitStruct members default value */
;;;257      USART_InitStruct->USART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;258      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;259      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;260      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;261      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  210c              MOVS     r1,#0xc
000010  8141              STRH     r1,[r0,#0xa]
;;;262      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  2100              MOVS     r1,#0
000014  8181              STRH     r1,[r0,#0xc]
;;;263    }
000016  4770              BX       lr
;;;264    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;467      */
;;;468    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;472      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;473      
;;;474      USARTx->CR1 &= CR1_WAKE_Mask;
000002  f24f73ff          MOV      r3,#0xf7ff
000006  401a              ANDS     r2,r2,r3
000008  8182              STRH     r2,[r0,#0xc]
;;;475      USARTx->CR1 |= USART_WakeUp;
00000a  8982              LDRH     r2,[r0,#0xc]
00000c  430a              ORRS     r2,r2,r1
00000e  8182              STRH     r2,[r0,#0xc]
;;;476    }
000010  4770              BX       lr
;;;477    
                          ENDP


C51 COMPILER V7.00  TEST88                                                                 01/28/2014 11:04:02 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE TEST88
OBJECT MODULE PLACED IN TEST88.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE TEST88.c

stmt level    source

   1          ////////////////////////////////////////////////////////////////////////////
   2          //                给力者单片机开发学习系统，开发学习都给力！              //
   3          ////////////////////////////////////////////////////////////////////////////
   4          //                     学习51单片机，其实可以很简单                       //
   5          ////////////////////////////////////////////////////////////////////////////
   6          //                宁波芯动电子有限公司  www.MovingChip.com                //
   7          ////////////////////////////////////////////////////////////////////////////
   8          
   9          #include <AT89X52.h>       //调用51单片机的头文件
  10          #include <Intrins.h>    //因为本例中用到空操作_nop_();所以必须调用这个头文件
  11          unsigned char code TAB[]={
  12          //第1界面 （开机按任意键后进入此界面）
  13          "系  1:背光灯    " //对应索引Index=0
  14          "统  2:存储器管理" //对应索引Index=1
  15          "菜  3:MP3 播放  " //对应索引Index=2
  16          "单  4:文件夹选项" //对应索引Index=3
  17          //第2界面 （Index=0时按确定进入此界面）
  18          "  1:液晶屏背光灯" //对应索引Index=4
  19          "  2:亮    度 0-9" //对应索引Index=5
  20          "  3:延时时间 0-9" //对应索引Index=6
  21          "  4:其他参数设置" //对应索引Index=7
  22          //第3界面 （Index=1时按确定进入此界面）
  23          "  1:外部存储器  " //对应索引Index=8
  24          "  2:已用大小    " //对应索引Index=9
  25          "  3:剩余大小    " //对应索引Index=10
  26          "  4:其他信息    " //对应索引Index=11
  27          //第4界面 （Index=2时按确定进入此界面）
  28          "  1:多媒体播放器" //对应索引Index=12
  29          "  2:选择歌曲    " //对应索引Index=13
  30          "  3:声音大小    " //对应索引Index=14
  31          "  4:歌手信息    " //对应索引Index=15
  32          //第5界面 （Index=3时按确定进入此界面）
  33          "  1:系统文件    " //对应索引Index=16
  34          "  2:使用说明书  " //对应索引Index=17
  35          "  3:单片机基础  " //对应索引Index=18
  36          "  4:翻页  返回  " //对应索引Index=19
  37          //第6界面 （Index=17时按确定进入此界面）
  38          "  使用说明书    " //对应索引Index=20
  39          "本页省略1000字  " //对应索引Index=21
  40          "  。。。。。    " //对应索引Index=22
  41          "  。。。。。    " //对应索引Index=23
  42          };
  43          unsigned char code TAB1[]={
  44          "系统初始化.     "
  45          "系统初始化..    "
  46          "系统初始化....  "
  47          "按任意键开始!   "
  48          };
  49          //---------------------------------------
  50          //12864液晶相关I/O设置
  51          sbit RS=P2^0;                   //并行数据/控制字选择 H:数据  L:控制字
  52          sbit RW=P2^1;                   //并行读/写选择       H:读    L:写
  53          sbit E =P2^2;                   //并行读写使能        H有效,下降沿锁定数据
  54          sbit PSB=P2^3;                  //串口,并口选择       H:并口  L:串口（开发板上引脚标识为CS1）
  55          sbit RST=P2^5;                  //复位引脚            L:液晶复位
C51 COMPILER V7.00  TEST88                                                                 01/28/2014 11:04:02 PAGE 2   

  56          sbit DB0=P0^7;                  //
  57          sbit DB1=P0^6;                  //
  58          sbit DB2=P0^5;                  //
  59          sbit DB3=P0^4;                  //
  60          sbit DB4=P0^3;                  //
  61          sbit DB5=P0^2;                  //
  62          sbit DB6=P0^1;                  //
  63          sbit DB7=P0^0;                  //
  64          //---------------------------------------
  65          unsigned char keycon;   //按键消抖用
  66          bit keybit;                                     //按键消抖用
  67          unsigned char Index;    //索引
  68          bit Select_bit;               //Select_bit=0：显示开机画面  Select_bit=1：显示菜单
  69          bit Menu_bit;           //Menu_bit=1：刷新菜单页面
  70          bit Start_bit;          //只显示一次开机画面
  71          //---------------------------------------
  72          //名称：液晶用延时函数
  73          //适用：给力者GL9单片机开发学习系统
  74          //公司：宁波芯动电子有限公司
  75          //网址：www.MovingChip.com
  76          //日期：20131113
  77          //---------------------------------------
  78          void delay(unsigned int t)
  79          {
  80   1              unsigned int i;
  81   1              for(i=0;i<t;i++);       
  82   1      }
  83          //---------------------------------------
  84          //名称：字节内位数据位置转换函数
  85          //适用：给力者GL9单片机开发学习系统
  86          //公司：宁波芯动电子有限公司
  87          //网址：www.MovingChip.com
  88          //日期：20131113
  89          //---------------------------------------
  90          unsigned char num(unsigned char dat)
  91          {
  92   1         unsigned char val;
  93   1              val = ((dat & 0x01) << 7) | ((dat & 0x02) << 5) | ((dat & 0x04) << 3) | ((dat & 0x08) << 1) |
  94   1         ((dat & 0x10) >> 1) | ((dat & 0x20) >> 3) | ((dat & 0x40) >> 5) | ((dat & 0x80) >> 7);
  95   1         return  val;
  96   1      } 
  97          //---------------------------------------
  98          //名称：写命令函数
  99          //适用：给力者GL9单片机开发学习系统
 100          //公司：宁波芯动电子有限公司
 101          //网址：www.MovingChip.com
 102          //日期：20131113
 103          //---------------------------------------
 104          void write_com(unsigned char cmdcode)
 105          {               
 106   1              RS=0;                   //设置该字节数据为命令代码
 107   1              RW=1;                   //设置此次操作为读
 108   1              E=1;                    //使能
 109   1              _nop_();                        //空操作，做短暂的延时
 110   1              _nop_();                        //空操作，做短暂的延时
 111   1              E=0;                    //失能
 112   1              RS=0;                   //设置该字节数据为命令代码
 113   1              RW=0;                   //设置此次操作为读写
 114   1              P0=num(cmdcode);                //将命令写入总线
 115   1              _nop_();                        //空操作，做短暂的延时
 116   1              E=1;                            //E的下降沿，数据写入
 117   1              _nop_();                        //空操作，做短暂的延时
C51 COMPILER V7.00  TEST88                                                                 01/28/2014 11:04:02 PAGE 3   

 118   1              E=0;                            //E的下降沿，数据写入
 119   1      }
 120          //---------------------------------------
 121          //名称：写数据函数
 122          //适用：给力者GL9单片机开发学习系统
 123          //公司：宁波芯动电子有限公司
 124          //网址：www.MovingChip.com
 125          //日期：20131113
 126          //---------------------------------------
 127          void write_data(unsigned char Rsspdata)
 128          {
 129   1              RS=0;                   //设置该字节数据为命令代码
 130   1              RW=1;                   //设置此次操作为读
 131   1              E=1;                    //使能
 132   1              _nop_();                        //空操作，做短暂的延时
 133   1              _nop_();                        //空操作，做短暂的延时
 134   1              E=0;                    //失能
 135   1              RS=1;                   //设置该字节数据为数据代码
 136   1              RW=0;                   //设置此次操作为读写
 137   1              P0=num(Rsspdata);               //将数据写入总线
 138   1              _nop_();                        //空操作，做短暂的延时
 139   1              E=1;                            //E的下降沿，数据写入
 140   1              _nop_();                        //空操作，做短暂的延时
 141   1              E=0;                            //E的下降沿，数据写入
 142   1      } 
 143          //---------------------------------------
 144          //名称：地址写入函数
 145          //适用：给力者GL9单片机开发学习系统
 146          //公司：宁波芯动电子有限公司
 147          //网址：www.MovingChip.com
 148          //日期：20131113
 149          //---------------------------------------
 150          void write_xy(unsigned char x,unsigned char y)
 151          {
 152   1              unsigned char address;
 153   1              switch(y)
 154   1              {
 155   2                      case 0:address=0x80+x;break;  //第一行的首地址是0x80
 156   2                      case 1:address=0x90+x;break;  //第二行的首地址是0x90
 157   2                      case 2:address=0x88+x;break;  //第三行的首地址是0x88
 158   2                      case 3:address=0x98+x;break;  //第四行的首地址是0x98
 159   2                      default:address=0x80+x;
 160   2         }
 161   1              write_com(address);     
 162   1      } 
 163          //---------------------------------------
 164          //名称：菜单及反白处理函数
 165          //适用：给力者GL9单片机开发学习系统
 166          //公司：宁波芯动电子有限公司
 167          //网址：www.MovingChip.com
 168          //日期：20131113
 169          //---------------------------------------
 170          void Disp_Menu(unsigned char Index)
 171          {
 172   1              unsigned char k,m,x,y;
 173   1              //以上为显示反白部分
 174   1              for(k=0;k<32;k++)          //绘图RAM全部清零
 175   1              {
 176   2                      write_com(0x34);                //扩展指令集
 177   2              write_com(0x80+k);      //先设定垂直地址(0-32)
 178   2              write_com(0x80);        //再设定水平地址(0)  
 179   2            write_com(0x30);                  //基本指令集 
C51 COMPILER V7.00  TEST88                                                                 01/28/2014 11:04:02 PAGE 4   

 180   2              for(m=0;m<16;m++)       //将绘图RAM全部清零
 181   2                      {                                       
 182   3                      write_data(0);  
 183   3                    write_data(0);
 184   3                      }
 185   2              }               
 186   1              //因为1、3行，2、4行是连在一起的，所以根据
 187   1              //显示反白所在不同的行，需要置不同的X,Y值
 188   1              switch(Index%4)
 189   1              {
 190   2                      case 0:x=0x80;y=0x80; break;  //反白在第1行,X地址为0,Y地址为0
 191   2                      case 1:x=0x80;y=0x90;break;     //反白在第2行,X地址为0,Y地址为16
 192   2                      case 2:x=0x88;y=0x80;break;     //反白在第3行,X地址为8,Y地址为0
 193   2                      case 3:x=0x88;y=0x90;break;     //反白在第4行,X地址为8,Y地址为16
 194   2                      default:x=0x80;y=0x80;
 195   2         }    
 196   1         for(k=0;k<16;k++)
 197   1              {               
 198   2                      write_com(0x34);                //扩展指令集
 199   2              write_com(y+k);         //先设定垂直地址
 200   2              write_com(x+1);         //再设定水平地址，加1是为了第1个汉字列不反白   
 201   2                 write_com(0x30);             //基本指令集 
 202   2              for(m=0;m<7;m++)        //因第一个汉字列不反白，所以只反白7个汉字位就可以
 203   2                      {                                       
 204   3                      write_data(0xff);    //写1，将导致反白
 205   3                    write_data(0xff);    //反白原理为，文字和绘图RAM异或后送显示
 206   3                      }
 207   2              }
 208   1              write_com(0x36);                        //写完数据，开图形显示
 209   1              write_com(0x30);                        //基本指令集  
 210   1              //以上为显示反白部分
 211   1              //以下为显示菜单部分
 212   1              for(m=0;m<4;m++)
 213   1              {
 214   2                      write_xy(0,m);                          //先写入地址参数
 215   2                      for(k=0;k<16;k++)       //每行8个汉字，共16个字节内码
 216   2                      {
 217   3                              write_data(TAB[(Index/4)*64+m*16+k]); //写入一个字符串数据      
 218   3                              delay(10);
 219   3                      }
 220   2              }
 221   1              //以上为显示菜单部分
 222   1      }
 223          //---------------------------------------
 224          //名称：开机画面函数
 225          //适用：给力者GL9单片机开发学习系统
 226          //公司：宁波芯动电子有限公司
 227          //网址：www.MovingChip.com
 228          //日期：20131113
 229          //---------------------------------------
 230          void Disp_Start(void)
 231          {
 232   1              unsigned char k,m;
 233   1              for(m=0;m<4;m++)                                                //开机画面有4行
 234   1              {
 235   2                      write_xy(0,m);                                          //先写入地址参数
 236   2                      for(k=0;k<16;k++)             //8个汉字，共16个字节
 237   2                      {
 238   3                              write_data(TAB1[m*16+k]);  //查表取开机画面汉字的内码   
 239   3                              delay(10);
 240   3                      }
 241   2              }
C51 COMPILER V7.00  TEST88                                                                 01/28/2014 11:04:02 PAGE 5   

 242   1      }
 243          //---------------------------------------
 244          //名称：12864初始化函数
 245          //适用：给力者GL9单片机开发学习系统
 246          //公司：宁波芯动电子有限公司
 247          //网址：www.MovingChip.com
 248          //日期：20131113
 249          //--------------------------------------- 
 250          void init_lcd(void)
 251          {          
 252   1              RST=0;                                          //复位液晶
 253   1              delay(250);                                     //加些延时
 254   1              RST=1;                                          //复位结束
 255   1              delay(250);                                     //加些延时
 256   1              PSB=1;                                          //选择8bit并口
 257   1      
 258   1              write_com(0x30);                        //基本指令集  
 259   1              write_com(0x0c);                        //显示开
 260   1              write_com(0x06);                        //光标右移，整体显示不移动
 261   1              write_com(0x01);                        //清除显示(清零DDRAM)
 262   1              delay(250);
 263   1      }  
 264          //---------------------------------------
 265          //名称: 按键扫描函数
 266          //适用：给力者GL9单片机开发学习系统
 267          //公司：宁波芯动电子有限公司
 268          //网址：www.MovingChip.com
 269          //日期：20131113
 270          //---------------------------------------
 271          unsigned char ScanKey(void)
 272          {
 273   1              //***8独立按键扫描部分***
 274   1         //按P1-P8键，返回参数1-8     
 275   1         if(P1_0==0) return 1;                //如果P1键按下，返回1
 276   1         else if(P1_1==0) return 2;   //如果P2键按下，返回2
 277   1         else if(P1_2==0) return 3;   //如果P3键按下，返回3
 278   1         else if(P1_3==0) return 4;   //如果P4键按下，返回4    
 279   1         else if(P1_4==0) return 5;   //如果P5键按下，返回5
 280   1         else if(P1_5==0) return 6;   //如果P6键按下，返回6
 281   1         else if(P1_6==0) return 7;   //如果P7键按下，返回7
 282   1         else if(P1_7==0) return 8;   //如果P8键按下，返回8
 283   1      
 284   1              return 0;                       //如果无按键按下，返回0
 285   1      }
 286          //---------------------------------------
 287          //名称: 按键处理函数
 288          //适用：给力者GL9单片机开发学习系统
 289          //公司：宁波芯动电子有限公司
 290          //网址：www.MovingChip.com
 291          //日期：20131113
 292          //---------------------------------------
 293          void KeyPro(void)
 294          {
 295   1              unsigned char k;
 296   1              k=ScanKey();
 297   1              if(k==0)                                        //如果无键按下
 298   1              {               
 299   2                      if(keybit==0)
 300   2                      {
 301   3                              if(++keycon>50)                         //消除抖动参数，越大消抖效果越好，但是按键越不灵敏
 302   3                              {
 303   4                                      keycon=0;
C51 COMPILER V7.00  TEST88                                                                 01/28/2014 11:04:02 PAGE 6   

 304   4                                      keybit=1;                       //微分用标志位
 305   4                              }
 306   3                      }
 307   2                      else
 308   2                              keycon=0;                       
 309   2              }          
 310   1              else if(k==1)                                   //如果P1键按下,移动选择
 311   1              {
 312   2                      if(keybit==1)                           //如果标志位有效，说明这个是有效按键
 313   2                      {
 314   3                              keybit=0;                                       //清除标志位，以保证每次按键只处理一次                  
 315   3                              if(Index<4)                                     //如果索引为0-3，为第1个界面
 316   3                              {
 317   4                                      if(++Index>3) Index=0;//移动选择需要控制在0-3以内
 318   4                              }       
 319   3                              else if(Index<8)                        //如果索引为4-7，为第2个界面
 320   3                              {
 321   4                                      if(++Index>7) Index=4;//移动选择需要控制在4-7以内
 322   4                              }
 323   3                              else if(Index<12)                       //如果索引为8-11，为第3个界面
 324   3                              {
 325   4                                      if(++Index>11) Index=8;//移动选择需要控制在8-11以内
 326   4                              }
 327   3                              else if(Index<16)                       //如果索引为12-15，为第4个界面
 328   3                              {
 329   4                                      if(++Index>15) Index=12;//移动选择需要控制在12-15以内
 330   4                              }
 331   3                              else if(Index<20)                       //如果索引为16-19，为第5个界面
 332   3                              {
 333   4                                      if(++Index>19) Index=16;//移动选择需要控制在16-19以内                           
 334   4                              }
 335   3                              else if(Index<24)                       //如果索引为20-23，为第6个界面
 336   3                              {
 337   4                                      if(++Index>23) Index=20;//移动选择需要控制在20-23以内                           
 338   4                              }
 339   3                              Menu_bit=1;                                     //每移动一次，都要置刷新标志位
 340   3                      }
 341   2              }                       
 342   1              else if(k==2)                                   //如果P2键按下,确定
 343   1              {
 344   2                      if(keybit==1)                           //如果标志位有效，说明这个是有效按键
 345   2                      {
 346   3                              keybit=0;                                       //清除标志位，以保证每次按键只处理一次  
 347   3                              Menu_bit=1;                                     //每确定一次，都要置刷新标志位
 348   3                              switch(Index)
 349   3                              {
 350   4                                      case 0:Index=4; break;          //如果选择第1页的第1行，索引转向第2页第1行
 351   4                                      case 1:Index=8;break;           //如果选择第1页的第2行，索引转向第3页第1行
 352   4                                      case 2:Index=12;break;          //如果选择第1页的第3行，索引转向第4页第1行
 353   4                                      case 3:Index=16;break;          //如果选择第1页的第4行，索引转向第5页第1行
 354   4                                      case 17:Index=20;break;         //如果选择第5页的第2行，索引转向第6页第1行 
 355   4                                      default:Menu_bit=1;                     //非定义部分，清零刷新标志位
 356   4                      }                       
 357   3                      }
 358   2         }
 359   1              else if(k==5)                                   //如果P5键按下,返回
 360   1              {
 361   2                      if(keybit==1)                           //如果标志位有效，说明这个是有效按键
 362   2                      {                               
 363   3                              keybit=0;                       
 364   3                              if((Index>3)&&(Index<20))//如果索引在第2-5页以内
 365   3                              {
C51 COMPILER V7.00  TEST88                                                                 01/28/2014 11:04:02 PAGE 7   

 366   4                                      Index=0;                                //将索引转到第1页第1行
 367   4                                      Menu_bit=1;          //刷新页面
 368   4                              }
 369   3                              else if((Index>19)&&(Index<24))//如果索引在第6页
 370   3                              {
 371   4                                      Index=17;                               //将索引转到第5页第2行 
 372   4                  Menu_bit=1;          //刷新页面
 373   4                              }
 374   3                 }
 375   2              }
 376   1      }
 377          //---------------------------------------
 378          //名称: 主函数
 379          //适用：给力者GL9单片机开发学习系统
 380          //公司：宁波芯动电子有限公司
 381          //网址：www.MovingChip.com
 382          //日期：20131113
 383          //---------------------------------------               
 384          void main(void)
 385          {  
 386   1              Select_bit=0;
 387   1              Start_bit=0;
 388   1              init_lcd();             
 389   1              while(1)
 390   1              {                               
 391   2                      if(Select_bit==0)               //显示开机画面
 392   2                      {
 393   3                              if(Start_bit==0)        //为避免刷新带来的屏幕闪动
 394   3                              {
 395   4                                      Start_bit=1;                    //开机画面只允许显示一次        
 396   4                                      Disp_Start();                   //显示开机画面内容
 397   4                              }
 398   3                              P1=0xff;                //P1口做好读取得准备，先写1
 399   3                              if(P1!=0xff)            //有任意键按下
 400   3                              {
 401   4                                      Select_bit=1;        //标志位置1，准备显示菜单画面      
 402   4                                      Menu_bit=1;          //置1显示1次菜单画面
 403   4                                      Index=0;                //索引初始值为0，反白为第一页第一行
 404   4                              }
 405   3                      }
 406   2                      else                                            //显示菜单画面
 407   2                      {
 408   3                              KeyPro();               //按键处理函数
 409   3                              if(Menu_bit==1)                 //标志位为1，刷新一次菜单画面
 410   3                              {
 411   4                                      Menu_bit=0;                             //清除标志位，目的只刷新一次
 412   4                                      Disp_Menu(Index);       //调用菜单及反白画面处理函数
 413   4                              }
 414   3                      }
 415   2              }
 416   1      }
 417          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    858    ----
   CONSTANT SIZE    =    450    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
C51 COMPILER V7.00  TEST88                                                                 01/28/2014 11:04:02 PAGE 8   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V7.00  TEST94                                                                 05/20/2014 10:50:55 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE TEST94
OBJECT MODULE PLACED IN TEST94.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE TEST94.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          ////////////////////////////////////////////////////////////////////////////
   2          //                给力者单片机开发学习系统，开发学习都给力！              //
   3          ////////////////////////////////////////////////////////////////////////////
   4          //                     学习51单片机，其实可以很简单                       //
   5          ////////////////////////////////////////////////////////////////////////////
   6          //                宁波芯动电子有限公司  www.MovingChip.com                //
   7          ////////////////////////////////////////////////////////////////////////////
   8          
   9          #include <AT89X52.h>       //调用51单片机的头文件
  10          #include <Intrins.h>       //因本例需要使用空操作，必须调用这个头文件
  11          
  12          //---------------------------------------
  13          //1602液晶相关I/O设置
  14          sbit E=P2^3;               //1602液晶的E脚接在P2.3口上
  15          sbit RW=P2^4;              //1602液晶的RW脚接在P2.4口上
  16          sbit RS=P2^5;              //1602液晶的RS脚接在P2.5口上
  17          //---------------------------------------
  18          
  19          //---------------------------------------
  20          //软件模拟IIC相关I/O设置
  21          sbit SCL=P1^7;             //PCF8591T的 SCL 引脚接于单片机的P1^7引脚上
  22          sbit SDA=P1^6;             //PCF8591T的 SDA 引脚接于单片机的P1^6引脚上
  23          //---------------------------------------
  24          
  25          //---------------------------------------
  26          //A/D转换用寄存器设置
  27          unsigned char ADbuf1;       //设置8位的寄存器用来暂存A/D转换结果
  28          unsigned char ADbuf2;       //设置8位的寄存器用来暂存A/D转换结果
  29          unsigned char ADbuf3;       //设置8位的寄存器用来暂存A/D转换结果
  30          unsigned char ADbuf4;       //设置8位的寄存器用来暂存A/D转换结果
  31          //---------------------------------------
  32          
  33          //---------------------------------------
  34          //名称：生IIC启动信号函数
  35          //适用：给力者GL9单片机开发学习系统
  36          //公司：宁波芯动电子有限公司
  37          //网址：www.MovingChip.com
  38          //日期：20120914
  39          //---------------------------------------
  40          void IICstart(void)
  41          { 
  42   1           SDA=1;                //先将SDA=1，以准备在SCL=1时，将SDA=0
  43   1           SCL=1;                //时钟总线拉高 
  44   1           _nop_();                   //略做延时
  45   1           _nop_();                   //略做延时
  46   1           SDA=0;                //SCL=1时，将SDA拉低即产生启动信号 
  47   1           _nop_();                   //略做延时
  48   1           _nop_();                   //略做延时
  49   1           SCL=0;                //将SCL=0，完成启动信号操作      
  50   1      } 
  51          
  52          //---------------------------------------
  53          //名称：IIC停止信号函数
  54          //适用：给力者GL9单片机开发学习系统
  55          //公司：宁波芯动电子有限公司
C51 COMPILER V7.00  TEST94                                                                 05/20/2014 10:50:55 PAGE 2   

  56          //网址：www.MovingChip.com
  57          //日期：20120914
  58          //---------------------------------------
  59          void IICstop(void)
  60          { 
  61   1           SDA=0;                //先将SDA=0，以准备在SCL=1时，将SDA=1
  62   1           SCL=1;                //时钟总线拉高 
  63   1           _nop_();                   //略做延时
  64   1           _nop_();                   //略做延时
  65   1           SDA=1;                //SCL=1时，将SDA拉高即产生停止信号 
  66   1           _nop_();                   //略做延时
  67   1           _nop_();                   //略做延时
  68   1           SCL=0;                //将SCL=0，完成启动信号操作      
  69   1      } 
  70          
  71          //---------------------------------------
  72          //名称：向IIC总线写入1个字节函数
  73          //适用：给力者GL9单片机开发学习系统
  74          //公司：宁波芯动电子有限公司
  75          //网址：www.MovingChip.com
  76          //日期：20120914
  77          //---------------------------------------
  78          void Write1Byte(unsigned char Buf1)
  79          { 
  80   1           unsigned char k;      //1个字节要分8次写入，需要定义一个寄存器用来计数
  81   1           for(k=0;k<8;k++)      //做一个8次的循环，每次写入1位，需要写8次
  82   1           {
  83   2               if(Buf1&0x80)     //从最高位开始写 
  84   2               {
  85   3                   SDA=1;        //如果欲写入数据为1，就将数据线置1
  86   3               }
  87   2               else
  88   2               {
  89   3                   SDA=0;        //如果欲写入数据为0，就将数据线写0 
  90   3               }
  91   2               _nop_();          //略做延时
  92   2               _nop_();          //略做延时
  93   2               SCL=1;            //时钟线做一个上升沿，将一位数据写入
  94   2               Buf1=Buf1<<1;     //数据左移一位，将下次要写入的位数据移到最高位
  95   2               _nop_();          //略做延时
  96   2               SCL=0;            //将SCL=0，以准备通过上升沿将数据写入
  97   2               _nop_();          //略做延时
  98   2           }
  99   1           SDA=1;                //将SDA=1，准备读应答信号
 100   1           _nop_();              //略做延时
 101   1           SCL=1;                //将SCL=1，做个上升沿准备读应答信号
 102   1           _nop_();              //略做延时
 103   1                while(SDA==1);
 104   1           _nop_();              //略做延时
 105   1           SCL=0;                //将SCL=0，结束应答信号读操作
 106   1      } 
 107          
 108          //---------------------------------------
 109          //名称：从IIC总线读入1个字节函数
 110          //适用：给力者GL9单片机开发学习系统
 111          //公司：宁波芯动电子有限公司
 112          //网址：www.MovingChip.com
 113          //日期：20120914
 114          //---------------------------------------
 115          unsigned char Read1Byte(void)
 116          { 
 117   1           unsigned char k;      //1个字节要分8次读出，需要定义一个寄存器用来计数
C51 COMPILER V7.00  TEST94                                                                 05/20/2014 10:50:55 PAGE 3   

 118   1           unsigned char t=0;    //定义一个寄存器用保存读出数据
 119   1           for(k=0;k<8;k++)      //做一个8次的循环，每次读入1位，需要读8次
 120   1           {
 121   2               t=t<<1;           //数据左移一位，空出最低位以准备保存读入的一位数据
 122   2               SDA=1;            //将SDA写1准备读
 123   2               SCL=1;            //将SCL=1，做个上升沿准备读一位数据
 124   2               _nop_();          //略做延时
 125   2               _nop_();          //略做延时
 126   2               if(SDA==1)        //读一位数据，并判断 
 127   2               {
 128   3                   t=t|0x01;     //如果读入数据为1，就将接收缓冲区最低一位置1
 129   3               }
 130   2               else
 131   2               {
 132   3                   t=t&0xfe;     //如果读入数据为0，就将接收缓冲区最低一位写0
 133   3               }
 134   2               SCL=0;            //SCL恢复为0，结束一位数据读操作
 135   2               _nop_();          //略做延时
 136   2               _nop_();          //略做延时
 137   2           }
 138   1           return t;             //将读入的一个字节返回
 139   1      } 
 140          
 141          //---------------------------------------
 142          //名称：软件模拟IIC向PCF8591指定地址写一个字节函数
 143          //适用：给力者GL9单片机开发学习系统
 144          //公司：宁波芯动电子有限公司
 145          //网址：www.MovingChip.com
 146          //日期：20120914
 147          //---------------------------------------
 148          void WritePCF8591(unsigned char Databuf)
 149          {                          //直接调用本函数即可启动PCF8591的D/A转换
 150   1          IICstart();            //IIC启动信号
 151   1      
 152   1          Write1Byte(0x90);      //发送PCF8591的器件地址和写信号
 153   1      
 154   1          Write1Byte(0x40);      //发送器件子地址
 155   1      
 156   1          Write1Byte(Databuf);   //发送数据
 157   1      
 158   1          IICstop();             //产生IIC停止信号
 159   1      }
 160          
 161          //---------------------------------------
 162          //名称：软件模拟IIC从PCF8563指定地址读一个字节函数
 163          //适用：给力者GL9单片机开发学习系统
 164          //公司：宁波芯动电子有限公司
 165          //网址：www.MovingChip.com
 166          //日期：20120914
 167          //---------------------------------------
 168          unsigned ReadPCF8591(unsigned char Ch)
 169          {                          //直接调用本函数即可从PCF8591的Ch通道读出数据返回
 170   1          unsigned char buf;     //定义一个寄存器用来暂存读出的数据
 171   1          IICstart();            //IIC启动信号
 172   1      
 173   1          Write1Byte(0x90);      //发送PCF8591的器件地址和写信号
 174   1      
 175   1          Write1Byte(0x40|Ch);   //发送器件通道参数Ch=0-3
 176   1      
 177   1          IICstart();            //IIC启动信号
 178   1      
 179   1          Write1Byte(0x91);      //发送PCF8591的器件地址和读信号
C51 COMPILER V7.00  TEST94                                                                 05/20/2014 10:50:55 PAGE 4   

 180   1      
 181   1          buf=Read1Byte();//读一个字节数据
 182   1      
 183   1          IICstop();             //产生IIC停止信号
 184   1      
 185   1          return(buf);           //将读出数据返回
 186   1      }
 187          
 188          //---------------------------------------
 189          //名称：1602液晶用延时函数
 190          //适用：给力者GL9单片机开发学习系统
 191          //公司：宁波芯动电子有限公司
 192          //网址：www.MovingChip.com
 193          //日期：20120914
 194          //---------------------------------------
 195          void Delay1602(unsigned int t)
 196          { 
 197   1           unsigned int k;      //定义一个16位寄存器用来做延时用 
 198   1           for(k=0;k<t;k++);    //延时 
 199   1      } 
 200          
 201          //---------------------------------------
 202          //名称：1602液晶忙检测函数
 203          //适用：给力者GL9单片机开发学习系统
 204          //公司：宁波芯动电子有限公司
 205          //网址：www.MovingChip.com
 206          //日期：20120914
 207          //---------------------------------------
 208          void LCD1602_busy(void)
 209          { 
 210   1           P0_7=1;              //将P0.7置1，为读状态做准备 
 211   1           RS=0;                //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
 212   1           RW=1;                //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
 213   1           E=1;                 //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
 214   1           while(P0_7==1);      //由P0.7读入1，表示1602液晶忙，需要等待
 215   1           E=0;                 //读完以后，恢复E的电平
 216   1      } 
 217          
 218          //---------------------------------------
 219          //名称：1600写命令函数
 220          //适用：给力者GL9单片机开发学习系统
 221          //公司：宁波芯动电子有限公司
 222          //网址：www.MovingChip.com
 223          //日期：20120914
 224          //---------------------------------------
 225          void LCD1602_Write_com(unsigned char combuf)
 226          { 
 227   1           RS=0;                //选择指令寄存器
 228   1           RW=0;                //选择写状态
 229   1           P0=combuf;           //将命令字通过P0口送至DB
 230   1           E=1;                 //E高电平将命令字写入1602液晶
 231   1           E=0;                 //写完以后，恢复E的电平
 232   1      } 
 233          
 234          //---------------------------------------
 235          //名称：1602写命令函数(带忙检测)
 236          //适用：给力者GL9单片机开发学习系统
 237          //公司：宁波芯动电子有限公司
 238          //网址：www.MovingChip.com
 239          //日期：20120914
 240          //---------------------------------------
 241          void LCD1602_Write_com_busy(unsigned char combuf)
C51 COMPILER V7.00  TEST94                                                                 05/20/2014 10:50:55 PAGE 5   

 242          { 
 243   1           LCD1602_busy();            //调用忙检测函数
 244   1           LCD1602_Write_com(combuf); //调用忙检测函数
 245   1      } 
 246          
 247          //---------------------------------------
 248          //名称：1602写数据函数(带忙检测)
 249          //适用：给力者GL9单片机开发学习系统
 250          //公司：宁波芯动电子有限公司
 251          //网址：www.MovingChip.com
 252          //日期：20120914
 253          //---------------------------------------
 254          void LCD1602_Write_data_busy(unsigned char databuf)
 255          { 
 256   1           LCD1602_busy();      //调用忙检测函数
 257   1           RS=1;                //选择数据寄存器
 258   1           RW=0;                //选择写状态
 259   1           P0=databuf;          //将命令字通过P0口送至DB
 260   1           E=1;                 //E高电平将命令字写入1602液晶
 261   1           E=0;                 //写完以后，恢复E的电平
 262   1      } 
 263          
 264          //---------------------------------------
 265          //名称：1602液晶显示地址写函数
 266          //适用：给力者GL9单片机开发学习系统
 267          //公司：宁波芯动电子有限公司
 268          //网址：www.MovingChip.com
 269          //日期：20120914
 270          //---------------------------------------
 271          void LCD1602_Write_address(unsigned char x,unsigned char y)
 272          { 
 273   1           x&=0x0f;             //列地址限制在0-15间
 274   1           y&=0x01;             //行地址限制在0-1间
 275   1           if(y==0)             //如果是第一行
 276   1               LCD1602_Write_com_busy(x|0x80);        //将列地址写入
 277   1           else                 //如果是第二行
 278   1               LCD1602_Write_com_busy((x+0x40)|0x80); //将列地址写入
 279   1      } 
 280          
 281          //---------------------------------------
 282          //名称：1602液晶初始化函数
 283          //适用：给力者GL9单片机开发学习系统
 284          //公司：宁波芯动电子有限公司
 285          //网址：www.MovingChip.com
 286          //日期：20120914
 287          //---------------------------------------
 288          void LCD1602_init(void)
 289          { 
 290   1           Delay1602(1500);               //调用延时函数
 291   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
 292   1           Delay1602(500);                //调用延时函数
 293   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
 294   1           Delay1602(500);                //调用延时函数
 295   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
 296   1           LCD1602_Write_com_busy(0x38);  //8位数据总线，两行显示模式，5*7点阵显示
 297   1           LCD1602_Write_com_busy(0x08);  //显示功能关，无光标
 298   1           LCD1602_Write_com_busy(0x01);  //清屏
 299   1           LCD1602_Write_com_busy(0x06);  //写入新的数据后，光标右移，显示屏不移动
 300   1           LCD1602_Write_com_busy(0x0C);  //显示功能开，无光标
 301   1      } 
 302          
 303          //---------------------------------------
C51 COMPILER V7.00  TEST94                                                                 05/20/2014 10:50:55 PAGE 6   

 304          //名称：1602液晶指定地址显示函数
 305          //适用：给力者GL9单片机开发学习系统
 306          //公司：宁波芯动电子有限公司
 307          //网址：www.MovingChip.com
 308          //日期：20120914
 309          //---------------------------------------
 310          void LCD1602_Disp(unsigned char x,unsigned char y,unsigned char buf)
 311          { 
 312   1           LCD1602_Write_address(x,y);    //先将地址信息写入
 313   1           LCD1602_Write_data_busy(buf);  //再写入要显示的数据
 314   1      } 
 315          //---------------------------------------
 316          //名称：指定位置显示数据函数
 317          //适用：给力者GL9单片机开发学习系统
 318          //公司：宁波芯动电子有限公司
 319          //网址：www.MovingChip.com
 320          //日期：20140318
 321          //---------------------------------------
 322          void Disp1Byte(unsigned char x,unsigned char y,unsigned char DispBuf) 
 323          {
 324   1              unsigned char m;
 325   1              LCD1602_Disp(x,y,'0');      //在第1行的第1列显示0
 326   1              LCD1602_Disp(x+1,y,'x');      //在第1行的第2列显示x
 327   1              m=DispBuf>>4;              //把要显示内容的高4位移到低4位上
 328   1              if(m<10)                    //0-F在ASCII码中并不连续，所以要分开处理
 329   1              {
 330   2            m+='0';                   //0-9的数据以0为基点进行偏移即可
 331   2              }
 332   1              else
 333   1              {
 334   2            m=m-10+'A';               //A-F的数据以A为基点进行偏移即可
 335   2              }
 336   1              LCD1602_Disp(x+2,y,m);        //在第1行的第3列显示高4位的十六进制数字
 337   1              m=DispBuf&0x0F;            //把要显示内容的高4位屏蔽掉，保留低4位
 338   1              if(m<10)                    //0-F在ASCII码中并不连续，所以要分开处理
 339   1              {
 340   2            m+='0';                   //0-9的数据以0为基点进行偏移即可
 341   2              }
 342   1         else
 343   1         {
 344   2            m=m-10+'A';               //A-F的数据以A为基点进行偏移即可
 345   2         }
 346   1         LCD1602_Disp(x+3,y,m);        //在第1行的第4列显示低4位的十六进制数字
 347   1      }
 348          //---------------------------------------
 349          //名称: 主函数
 350          //适用：给力者GL9单片机开发学习系统
 351          //公司：宁波芯动电子有限公司
 352          //网址：www.MovingChip.com
 353          //日期：20120914
 354          //---------------------------------------
 355          void main(void)            //主函数,单片机开机后就是从这个函数开始运行
 356          {
 357   1      
 358   1          LCD1602_init();        //调用1602液晶初始化函数
 359   1      
 360   1          while(1)               //死循环,单片机初始化后,将一直运行这个死循环
 361   1          {
 362   2            ADbuf1=ReadPCF8591(1);     //将AIN0通道A/D转换结果暂存在ADbuf
 363   2                      Disp1Byte(0,0,ADbuf1);  
 364   2                      ADbuf2=ReadPCF8591(2);     //将AIN1通道A/D转换结果暂存在ADbuf
 365   2                      Disp1Byte(8,0,ADbuf2);          
C51 COMPILER V7.00  TEST94                                                                 05/20/2014 10:50:55 PAGE 7   

 366   2                      ADbuf3=ReadPCF8591(3);     //将AIN2通道A/D转换结果暂存在ADbuf
 367   2                      Disp1Byte(0,1,ADbuf3);          
 368   2                      ADbuf4=ReadPCF8591(4);     //将AIN3通道A/D转换结果暂存在ADbuf
 369   2                      Disp1Byte(8,1,ADbuf4);   
 370   2          }
 371   1      }
 372          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    442    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

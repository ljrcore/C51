////////////////////////////////////////////////////////////////////////////
//                给力者单片机开发学习系统，开发学习都给力！              //
////////////////////////////////////////////////////////////////////////////
//                     学习51单片机，其实可以很简单                       //
////////////////////////////////////////////////////////////////////////////
//                宁波芯动电子有限公司  www.MovingChip.com                //
////////////////////////////////////////////////////////////////////////////
#include <AT89X52.h>       //调用51单片机的头文件
#include <Intrins.h>       //因本例需要使用空操作，必须调用这个头文件

//---------------------------------------
//软件模拟IIC相关I/O设置
sbit SCL=P1^5;             //AT24C02的 SCL 引脚接于单片机的P1.5引脚上
sbit SDA=P1^4;             //AT24C02的 SDA 引脚接于单片机的P1.4引脚上
//---------------------------------------

unsigned char ComBuf[18];//串口通讯数据缓存，发送和接收都使用
unsigned int  nTimeOut;//超时计数
unsigned char Address;
unsigned char Buf[16];
unsigned char n;	
//---------------------------------------
//名称：生IIC启动信号函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
void IICstart(void)
{ 
     SDA=1;                //先将SDA=1，以准备在SCL=1时，将SDA=0
     SCL=1;                //时钟总线拉高 
     _nop_();          		//略做延时
     _nop_();          		//略做延时
     SDA=0;                //SCL=1时，将SDA拉低即产生启动信号 
     _nop_();          		//略做延时
     _nop_();          		//略做延时
     SCL=0;                //将SCL=0，完成启动信号操作     
} 

//---------------------------------------
//名称：IIC停止信号函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
void IICstop(void)
{ 
     SDA=0;                //先将SDA=0，以准备在SCL=1时，将SDA=1
     SCL=1;                //时钟总线拉高 
     _nop_();          		//略做延时
     _nop_();          		//略做延时
     SDA=1;                //SCL=1时，将SDA拉高即产生停止信号 
     _nop_();          		//略做延时
     _nop_();          		//略做延时
     SCL=0;                //将SCL=0，完成启动信号操作      
} 

//---------------------------------------
//名称：向IIC总线写入1个字节函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
void Write1Byte(unsigned char Buf1)
{ 
     unsigned char k;      //1个字节要分8次写入，需要定义一个寄存器用来计数
     for(k=0;k<8;k++)      //做一个8次的循环，每次写入1位，需要写8次
     {
         if(Buf1&0x80)     //从最高位开始写 
         {
             SDA=1;        //如果欲写入数据为1，就将数据线置1
         }
         else
         {
             SDA=0;        //如果欲写入数据为0，就将数据线写0 
         }
         _nop_();          //略做延时
         _nop_();          //略做延时
         SCL=1;            //时钟线做一个上升沿，将一位数据写入
         Buf1=Buf1<<1;     //数据左移一位，将下次要写入的位数据移到最高位
         _nop_();          //略做延时
 			_nop_();          //略做延时
     		_nop_();          //略做延时
	  		_nop_();          //略做延时
     		_nop_();          //略做延时
     		_nop_();          //略做延时
     		_nop_();          //略做延时	  		
         SCL=0;            //将SCL=0，以准备通过上升沿将数据写入      
     }
     SDA=1;                //将SDA=1，准备读应答信号
     _nop_();              //略做延时
     SCL=1;                //将SCL=1，做个上升沿准备读应答信号
     _nop_();              //略做延时
     _nop_();              //略做延时
	  _nop_();              //略做延时
     _nop_();              //略做延时
     _nop_();              //略做延时
     _nop_();              //略做延时
	  _nop_();              //略做延时
     _nop_();              //略做延时
	  _nop_();              //略做延时
     _nop_();              //略做延时
     SCL=0;                //将SCL=0，结束应答信号读操作
	  _nop_();              //略做延时
     _nop_();              //略做延时
} 

//---------------------------------------
//名称：从IIC总线读入1个字节函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
unsigned char Read1Byte(void)
{ 
     unsigned char k;      //1个字节要分8次读出，需要定义一个寄存器用来计数
     unsigned char t=0;    //定义一个寄存器用保存读出数据
     for(k=0;k<8;k++)      //做一个8次的循环，每次读入1位，需要读8次
     {
         t=t<<1;           //数据左移一位，空出最低位以准备保存读入的一位数据
         SDA=1;            //将SDA写1准备读
         SCL=1;            //将SCL=1，做个上升沿准备读一位数据
         _nop_();          //略做延时
         _nop_();          //略做延时
         if(SDA==1)        //读一位数据，并判断 
         {
             t=t|0x01;     //如果读入数据为1，就将接收缓冲区最低一位置1
         }
         else
         {
             t=t&0xfe;     //如果读入数据为0，就将接收缓冲区最低一位写0
         }
         SCL=0;            //SCL恢复为0，结束一位数据读操作
         _nop_();          //略做延时
         _nop_();          //略做延时
			_nop_();          //略做延时
         _nop_();          //略做延时
     }	  
	  _nop_();              //略做延时
     _nop_();              //略做延时
     return t;             //将读入的一个字节返回
} 
//---------------------------------------
//名称: 向AT24C02指定地址上写入N字节数据函数	
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
void AT24C02_WriteByte(unsigned char Address,unsigned char *AT24C02_Byte,unsigned char nByte)
{
	unsigned char i;  
  	IICstart();            //IIC启动信号
  	Write1Byte(0xA0);      //发送AT24C02的器件地址和写信号
  	Write1Byte(Address);   //发送地址                   

	for(i=0;i<nByte;i++)
	{
  		Write1Byte(*AT24C02_Byte);
		AT24C02_Byte++;
		_nop_();              //略做延时
      _nop_();              //略做延时
	   _nop_();              //略做延时
      _nop_();              //略做延时
	}
  	IICstop();             //产生IIC停止信号
}
//---------------------------------------
//名称: 从AT24C02指定地址上读出N字节数据函数	
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
void AT24C02_ReadByte(unsigned char Address,unsigned char *AT24C02_Byte,unsigned char nByte)
{    
  	unsigned char i;

  	IICstart();            //IIC启动信号
  	Write1Byte(0xA0);      //发送AT24C02的器件地址和写信号
  	Write1Byte(Address);   //发送地址
  	_nop_();              //略做延时
   _nop_();              //略做延时
  	IICstart();            //IIC启动信号
  	Write1Byte(0xA1);      //发送AT24C02的器件地址和读信号

   for(i=0;i<nByte-1;i++) //除去最后一个数据以外，其他的读取后发应答标志
	{
  		*AT24C02_Byte=Read1Byte();//读一个字节数据		
		AT24C02_Byte++;		
		SDA=0;               //将SDA=0，准备发应答信号
      _nop_();              //略做延时
      SCL=1;                //将SCL=1，做个上升沿准备发应答信号
      _nop_();              //略做延时
      _nop_();              //略做延时
	   _nop_();              //略做延时
      _nop_();              //略做延时    
      SCL=0;                //将SCL=0，结束应答信号发操作
	   _nop_();              //略做延时
      _nop_();              //略做延时
	}
	*AT24C02_Byte=Read1Byte();//读最后一个字节数据		
	SDA=1;                //将SDA=1，准备发非应答信号
   _nop_();              //略做延时
   SCL=1;                //将SCL=1，做个上升沿准备发应答信号
   _nop_();              //略做延时
   _nop_();              //略做延时
	_nop_();              //略做延时
   _nop_();              //略做延时 
   SCL=0;                //将SCL=0，结束应答信号发操作
	_nop_();              //略做延时
   _nop_();              //略做延时
  	IICstop();             //产生IIC停止信号  	
}
//---------------------------------------
//名称: 等待上位机18字节函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
bit WaitData()
{
	unsigned char n;
	RI=0;
	for(n=0;n<18;n++)
	{
		nTimeOut=0;
		while(!RI)
		{
			nTimeOut++;
			if(nTimeOut>10000)
			{
				return 0;
			}
		}
		RI=0;
		ComBuf[n]=SBUF;
	}
	return 1;
}
//---------------------------------------
//名称: 向上位机发送18字节函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
void SendData()
{
	unsigned char n=0;
	for(n;n<18;n++)
	{
		TI=0;
		SBUF=ComBuf[n];
		while(!TI){}
		TI=0;
	}
}
//---------------------------------------
//名称: 主函数
//适用：给力者GL9单片机开发学习系统
//公司：宁波芯动电子有限公司
//网址：www.MovingChip.com
//日期：20120914
//---------------------------------------
void main(void)            //主函数,单片机开机后就是从这个函数开始运行
{
    //*****USART串口初始化*****
	TMOD&=0x0F;            //把TMOD高4位清0
   TMOD|=0x20;            //将TMOD的M1位置1，设置成自动装入的8位定时器
   TH1=0xFF;              //设置波特率为57600
   TL1=0xFF;              //设置波特率为57600
   TR1=1;                 //启动定时器T1，作为串口波特率发生器
   SCON=0x50;             //10位异步收发，波特率由定时器控制，允许串口接收
   ES=0;                  //禁止串口中断
   //**************************
   while(1)               //死循环,单片机初始化后,将一直运行这个死循环
   {    
   	if(WaitData()==1)   //如果接收成功
		{		
			if(ComBuf[0]==1) //如果上位机发1，为读识别码
			{
				ComBuf[2]=6;
    			ComBuf[3]=2;
    			ComBuf[4]=4;  
  				SendData();  //将识别码624发给上位机
			}
			else if(ComBuf[0]==2) //如果上位机发2，为写AT24C02
			{
				SendData();//回应上位机表示进入写器件状态，可以发来数据
				Address=0;
				while(1)
				{
					if(WaitData()==1&&ComBuf[1]==0x01)//如果接收数据成功并且ComBuf[0]==1表示继续写
					{			
						for(n=0;n<8;n++)
						{
							Buf[n]=ComBuf[n+2];  		//把接收到的COMBUF[2]-[9]内的数据移到
														//BUF[0]-[7]内，以便套用连续写函数格式
						}
						AT24C02_WriteByte(Address,Buf,8);//ComBuf[2~9]为待写入数据块						
						Address+=8;						//地址加8，准备写下一轮	
						for(nTimeOut=0;nTimeOut<512;nTimeOut++);
						for(n=0;n<8;n++)
						{
							Buf[n]=ComBuf[n+10];  		//把接收到的COMBUF[10]-[17]内的数据移到
														//BUF[0]-[7]内，以便套用连续写函数格式
						}
						AT24C02_WriteByte(Address,Buf,8);//ComBuf[10~17]为待写入数据块						
						Address+=8;						//地址加8，准备写下一轮	
						SendData();						//通知上位机继续发			
					}	
					else
					{
						break;  //退出while(1)
					}
				}		
			}
			else if(ComBuf[0]==3) //如果上位机发3，为读AT24C02
			{
				SendData();//回应上位机表示进入读状态
				Address=0;
				while(1)
				{
					if(WaitData()==1&&ComBuf[1]==1)//如果接收数据成功并且ComBuf[0]==1表示继续读
					{
						AT24C02_ReadByte(Address,Buf,16);//从Address开始，连续读16个字节，放入BUF[]里
						Address+=16;
						for(n=0;n<16;n++)
						{
							ComBuf[n+2]=Buf[n];	
							_nop_();              //略做延时
   							_nop_();              //略做延时
   							_nop_();              //略做延时
							_nop_();              //略做延时
						}			
						SendData();				
					}
					else
					{
						break;  //退出while(1)
					}
				}		
			}
		}     
   }
}


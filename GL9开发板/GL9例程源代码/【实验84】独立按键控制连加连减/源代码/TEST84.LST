C51 COMPILER V7.00  TEST84                                                                 09/25/2013 09:42:47 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE TEST84
OBJECT MODULE PLACED IN TEST84.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE TEST84.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          ////////////////////////////////////////////////////////////////////////////
   2          //                给力者单片机开发学习系统，开发学习都给力！              //
   3          ////////////////////////////////////////////////////////////////////////////
   4          //                     学习51单片机，其实可以很简单                       //
   5          ////////////////////////////////////////////////////////////////////////////
   6          //                宁波芯动电子有限公司  www.MovingChip.com                //
   7          ////////////////////////////////////////////////////////////////////////////
   8          
   9          #include <AT89X52.h>       //调用51单片机的头文件
  10          //---------------------------------------
  11          //数码管字形表，供显示时查询
  12          unsigned char code LED[10]=
  13          {                          //定义表格一定要使用code，这样会做到程序存储区中
  14              0x3F,                  //"0"的字形表，0B00111111
  15              0x06,                  //"1"的字形表，0B00000110
  16              0x5B,                  //"2"的字形表，0B01011011
  17              0x4F,                  //"3"的字形表，0B01001111
  18              0x66,                  //"4"的字形表，0B01100110
  19              0x6D,                  //"5"的字形表，0B01101101
  20              0x7D,                  //"6"的字形表，0B01111101
  21              0x07,                  //"7"的字形表，0B00000111
  22              0x7F,                  //"8"的字形表，0B01111111
  23              0x6F,                  //"9"的字形表，0B01101111
  24          };
  25          //---------------------------------------
  26          //名称: 按键扫描函数
  27          //适用：给力者GL9单片机开发学习系统
  28          //公司：宁波芯动电子有限公司
  29          //网址：www.MovingChip.com
  30          //日期：20130924
  31          //---------------------------------------
  32          unsigned char ScanKey(void)
  33          {
  34   1               //***8独立按键扫描部分***
  35   1          //按P1-P8键，返回参数1-8    
  36   1          if(P1_0==0) return 1;       //如果P1键按下，返回1
  37   1          else if(P1_1==0) return 2;  //如果P2键按下，返回2
  38   1          else if(P1_2==0) return 3;  //如果P3键按下，返回3
  39   1          else if(P1_3==0) return 4;  //如果P4键按下，返回4    
  40   1          else if(P1_4==0) return 5;  //如果P5键按下，返回5
  41   1          else if(P1_5==0) return 6;  //如果P6键按下，返回6
  42   1          else if(P1_6==0) return 7;  //如果P7键按下，返回7
  43   1          else if(P1_7==0) return 8;  //如果P8键按下，返回8
  44   1      
  45   1              return 0;                    //如果无按键按下，返回0
  46   1      }
  47          //---------------------------------------
  48          //名称: 主函数
  49          //适用：给力者GL9单片机开发学习系统
  50          //公司：宁波芯动电子有限公司
  51          //网址：www.MovingChip.com
  52          //日期：20130924
  53          //---------------------------------------
  54          void main(void)            //主函数,单片机开机后就是从这个函数开始运行
  55          {    
C51 COMPILER V7.00  TEST84                                                                 09/25/2013 09:42:47 PAGE 2   

  56   1              unsigned char k; 
  57   1              unsigned char d;
  58   1              unsigned char c;
  59   1              unsigned char k5con;
  60   1              unsigned int f=0;
  61   1              unsigned int keycon;
  62   1              bit keybit;
  63   1      
  64   1              f=0;
  65   1         while(1)               //死循环,单片机初始化后,将一直运行这个死循环
  66   1         {
  67   2                      k=ScanKey();
  68   2                      if(k==0)                //如果无键按下
  69   2                      {
  70   3                              k5con=0;
  71   3                              if(keybit==0)
  72   3                              {
  73   4                                      if(++keycon>50) //消除抖动参数，越大消抖效果越好，但是按键越不灵敏
  74   4                                      {
  75   5                                              keycon=0;
  76   5                                              keybit=1;
  77   5                                      }
  78   4                              }
  79   3                              else
  80   3                                      keycon=0;                       
  81   3                      }          
  82   2                      else if(k==1)           //如果K1键按下,每次加1
  83   2                      {
  84   3                              if(keybit==1)   //如果标志位有效，说明这个是有效按键
  85   3                              {
  86   4                                      keybit=0;               //清除标志位，以保证每次按键只处理一次
  87   4                                      if(f<9999) f++;
  88   4                              }
  89   3                 }                    
  90   2                      else if(k==2)           //如果K2键按下,每次减1
  91   2                      {
  92   3                              if(keybit==1)   //如果标志位有效，说明这个是有效按键
  93   3                              {
  94   4                                      keybit=0;               //清除标志位，以保证每次按键只处理一次
  95   4                                      if(f>0) f--;
  96   4                              }
  97   3                 }
  98   2                      else if(k==5)           //如果K5键按下,连续加
  99   2                      {
 100   3                              if(keybit==1)   //如果标志位有效，说明这个是有效按键
 101   3                              {                               
 102   4                                      if(++k5con>250)
 103   4                                      {
 104   5                                              k5con=0;
 105   5                                              if(f<9999) f++;
 106   5                                      }
 107   4                              }
 108   3                 }
 109   2                      else if(k==6)           //如果K6键按下,连续减
 110   2                      {
 111   3                              if(keybit==1)   //如果标志位有效，说明这个是有效按键
 112   3                              {                               
 113   4                                      if(++k5con>250)
 114   4                                      {
 115   5                                              k5con=0;
 116   5                                              if(f>0) f--;
 117   5                                      }
C51 COMPILER V7.00  TEST84                                                                 09/25/2013 09:42:47 PAGE 3   

 118   4                              }
 119   3                 }
 120   2                      for(c=0;c<250;c++);//做一个0-250的循环，不执行其他操作，只为延时
 121   2            
 122   2            P2=0;              //关一次显示，以免显示出鬼影
 123   2            if(++d>3) d=0;     //先将d加1，然后判断是否大于3，大于3归零
 124   2            if(d==0)           //如果d=0,显示千位
 125   2            {
 126   3                P0=0x03;       //U16A0=1,U16A1=1,U16A2=0选通数码管的千位进行显示
 127   3                P2=LED[f/1000];//将要显示的f的千位提取出来查表后送显示 
 128   3            }
 129   2            else if(d==1)      //如果d=1,显示百位
 130   2            {
 131   3                P0=0x02;       //U16A0=0,U16A1=1,U16A2=0选通数码管的百位进行显示
 132   3                P2=LED[(f%1000)/100];    //将要显示的f的百位提取出来查表后送显示
 133   3            }
 134   2            else if(d==2)      //如果d=2,显示十位
 135   2            {
 136   3                P0=0x01;       //U16A0=1,U16A1=0,U16A2=0选通数码管的十位进行显示
 137   3                P2=LED[(f%100)/10];      //将要显示的f的十位提取出来查表后送显示
 138   3            }
 139   2            else               //如果d=3,显示个位
 140   2            {
 141   3                P0=0x00;       //U16A0=0,U16A1=0,U16A2=0选通数码管的个位进行显示
 142   3                P2=LED[f%10];            //将要显示的f的个位提取出来查表后送显示
 143   3            }
 144   2         }
 145   1      }
 146          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    362    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

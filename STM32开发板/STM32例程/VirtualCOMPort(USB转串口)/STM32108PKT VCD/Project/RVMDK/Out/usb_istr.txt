; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Out\usb_istr.o --depend=.\Out\usb_istr.d --device=DARMSTM --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Core\CM3 -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I"D:\Program Files\KeilARM350\ARM\INC\ST\STM32F10x" ..\src\usb_istr.c]
                          THUMB

                          AREA ||i.USB_Istr||, CODE, READONLY, ALIGN=2

                  USB_Istr PROC
;;;62     *******************************************************************************/
;;;63     void USB_Istr(void)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65     
;;;66       wIstr = _GetISTR();
000002  4817              LDR      r0,|L1.96|
000004  6800              LDR      r0,[r0,#0]
000006  4917              LDR      r1,|L1.100|
000008  8008              STRH     r0,[r1,#0]
;;;67     
;;;68     #if (IMR_MSK & ISTR_RESET)
;;;69       if (wIstr & ISTR_RESET & wInterrupt_Mask)
00000a  4608              MOV      r0,r1
00000c  8800              LDRH     r0,[r0,#0]  ; wIstr
00000e  f4006080          AND      r0,r0,#0x400
000012  4915              LDR      r1,|L1.104|
000014  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000016  4208              TST      r0,r1
000018  d006              BEQ      |L1.40|
;;;70       {
;;;71         _SetISTR((uint16_t)CLR_RESET);
00001a  f64f30ff          MOV      r0,#0xfbff
00001e  4910              LDR      r1,|L1.96|
000020  6008              STR      r0,[r1,#0]
;;;72         Device_Property.Reset();
000022  4912              LDR      r1,|L1.108|
000024  6848              LDR      r0,[r1,#4]  ; Device_Property
000026  4780              BLX      r0
                  |L1.40|
;;;73     #ifdef RESET_CALLBACK
;;;74         RESET_Callback();
;;;75     #endif
;;;76       }
;;;77     #endif
;;;78       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;79     #if (IMR_MSK & ISTR_DOVR)
;;;80       if (wIstr & ISTR_DOVR & wInterrupt_Mask)
;;;81       {
;;;82         _SetISTR((uint16_t)CLR_DOVR);
;;;83     #ifdef DOVR_CALLBACK
;;;84         DOVR_Callback();
;;;85     #endif
;;;86       }
;;;87     #endif
;;;88       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;89     #if (IMR_MSK & ISTR_ERR)
;;;90       if (wIstr & ISTR_ERR & wInterrupt_Mask)
;;;91       {
;;;92         _SetISTR((uint16_t)CLR_ERR);
;;;93     #ifdef ERR_CALLBACK
;;;94         ERR_Callback();
;;;95     #endif
;;;96       }
;;;97     #endif
;;;98       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;99     #if (IMR_MSK & ISTR_WKUP)
;;;100      if (wIstr & ISTR_WKUP & wInterrupt_Mask)
;;;101      {
;;;102        _SetISTR((uint16_t)CLR_WKUP);
;;;103        Resume(RESUME_EXTERNAL);
;;;104    #ifdef WKUP_CALLBACK
;;;105        WKUP_Callback();
;;;106    #endif
;;;107      }
;;;108    #endif
;;;109      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;110    #if (IMR_MSK & ISTR_SUSP)
;;;111      if (wIstr & ISTR_SUSP & wInterrupt_Mask)
;;;112      {
;;;113    
;;;114        /* check if SUSPEND is possible */
;;;115        if (fSuspendEnabled)
;;;116        {
;;;117          Suspend();
;;;118        }
;;;119        else
;;;120        {
;;;121          /* if not possible then resume after xx ms */
;;;122          Resume(RESUME_LATER);
;;;123        }
;;;124        /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;125        _SetISTR((uint16_t)CLR_SUSP);
;;;126    #ifdef SUSP_CALLBACK
;;;127        SUSP_Callback();
;;;128    #endif
;;;129      }
;;;130    #endif
;;;131      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;132    #if (IMR_MSK & ISTR_SOF)
;;;133      if (wIstr & ISTR_SOF & wInterrupt_Mask)
000028  480e              LDR      r0,|L1.100|
00002a  8800              LDRH     r0,[r0,#0]  ; wIstr
00002c  f4007000          AND      r0,r0,#0x200
000030  490d              LDR      r1,|L1.104|
000032  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000034  4208              TST      r0,r1
000036  d008              BEQ      |L1.74|
;;;134      {
;;;135        _SetISTR((uint16_t)CLR_SOF);
000038  f64f50ff          MOV      r0,#0xfdff
00003c  4908              LDR      r1,|L1.96|
00003e  6008              STR      r0,[r1,#0]
;;;136        bIntPackSOF++;
000040  480b              LDR      r0,|L1.112|
000042  7800              LDRB     r0,[r0,#0]  ; bIntPackSOF
000044  1c40              ADDS     r0,r0,#1
000046  490a              LDR      r1,|L1.112|
000048  7008              STRB     r0,[r1,#0]
                  |L1.74|
;;;137    
;;;138    #ifdef SOF_CALLBACK
;;;139        SOF_Callback();
;;;140    #endif
;;;141      }
;;;142    #endif
;;;143      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;144    #if (IMR_MSK & ISTR_ESOF)
;;;145      if (wIstr & ISTR_ESOF & wInterrupt_Mask)
;;;146      {
;;;147        _SetISTR((uint16_t)CLR_ESOF);
;;;148        /* resume handling timing is made with ESOFs */
;;;149        Resume(RESUME_ESOF); /* request without change of the machine state */
;;;150    
;;;151    #ifdef ESOF_CALLBACK
;;;152        ESOF_Callback();
;;;153    #endif
;;;154      }
;;;155    #endif
;;;156      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;157    #if (IMR_MSK & ISTR_CTR)
;;;158      if (wIstr & ISTR_CTR & wInterrupt_Mask)
00004a  4806              LDR      r0,|L1.100|
00004c  8800              LDRH     r0,[r0,#0]  ; wIstr
00004e  f4004000          AND      r0,r0,#0x8000
000052  4905              LDR      r1,|L1.104|
000054  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000056  4208              TST      r0,r1
000058  d001              BEQ      |L1.94|
;;;159      {
;;;160        /* servicing of the endpoint correct transfer interrupt */
;;;161        /* clear of the CTR flag into the sub */
;;;162        CTR_LP();
00005a  f7fffffe          BL       CTR_LP
                  |L1.94|
;;;163    #ifdef CTR_CALLBACK
;;;164        CTR_Callback();
;;;165    #endif
;;;166      }
;;;167    #endif
;;;168    } /* USB_Istr */
00005e  bd10              POP      {r4,pc}
;;;169    
                          ENDP

                  |L1.96|
                          DCD      0x40005c44
                  |L1.100|
                          DCD      wIstr
                  |L1.104|
                          DCD      wInterrupt_Mask
                  |L1.108|
                          DCD      Device_Property
                  |L1.112|
                          DCD      bIntPackSOF

                          AREA ||.data||, DATA, ALIGN=2

                  bIntPackSOF
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  pEpInt_IN
                          DCD      EP1_IN_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      EP3_OUT_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                  wIstr
00003c  0000              DCB      0x00,0x00

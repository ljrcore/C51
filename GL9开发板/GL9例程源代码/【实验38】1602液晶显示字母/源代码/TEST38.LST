C51 COMPILER V8.05a   TEST38                                                               02/11/2016 17:20:07 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE TEST38
OBJECT MODULE PLACED IN TEST38.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\kell\C51\BIN\C51.EXE TEST38.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          
   3          #include <AT89X52.h>       //调用51单片机的头文件
   4          
   5          //---------------------------------------
   6          //1602液晶相关I/O设置
   7          sbit E=P2^3;               //1602液晶的E脚接在P2.3口上
   8          sbit RW=P2^4;              //1602液晶的RW脚接在P2.4口上
   9          sbit RS=P2^5;              //1602液晶的RS脚接在P2.5口上
  10          //---------------------------------------
  11          //---------------------------------------
  12          void Delay1602(unsigned int t)
  13          { 
  14   1           unsigned int k;      //定义一个16位寄存器用来做延时用 
  15   1           for(k=0;k<t;k++);    //延时 
  16   1      } 
  17          
  18          //---------------------------------------
  19          //名称：1602液晶忙检测函数
  20          //---------------------------------------
  21          void LCD1602_busy(void)
  22          { 
  23   1           P0_7=1;              //将P0.7置1，为读状态做准备 
  24   1           RS=0;                //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
  25   1           RW=1;                //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
  26   1           E=1;                 //RS=0、RW=1、E=1时，忙信号输出到DB7，由P0.7读入
  27   1           while(P0_7==1);      //由P0.7读入1，表示1602液晶忙，需要等待
  28   1           E=0;                 //读完以后，恢复E的电平
  29   1      } 
  30          
  31          //---------------------------------------
  32          //名称：1600写命令函数
  33          //---------------------------------------
  34          void LCD1602_Write_com(unsigned char combuf)
  35          { 
  36   1           RS=0;                //选择指令寄存器
  37   1           RW=0;                //选择写状态
  38   1           P0=combuf;           //将命令字通过P0口送至DB
  39   1           E=1;                 //E高电平将命令字写入1602液晶
  40   1           E=0;                 //写完以后，恢复E的电平
  41   1      } 
  42          
  43          //---------------------------------------
  44          //名称：1602写命令函数(带忙检测)
  45          //---------------------------------------
  46          void LCD1602_Write_com_busy(unsigned char combuf)
  47          { 
  48   1           LCD1602_busy();            //调用忙检测函数
  49   1           LCD1602_Write_com(combuf); //调用忙检测函数
  50   1      } 
  51          
  52          //---------------------------------------
  53          //名称：1602写数据函数(带忙检测)
  54          //---------------------------------------
  55          void LCD1602_Write_data_busy(unsigned char databuf)
C51 COMPILER V8.05a   TEST38                                                               02/11/2016 17:20:07 PAGE 2   

  56          { 
  57   1           LCD1602_busy();      //调用忙检测函数
  58   1           RS=1;                //选择数据寄存器
  59   1           RW=0;                //选择写状态
  60   1           P0=databuf;          //将命令字通过P0口送至DB
  61   1           E=1;                 //E高电平将命令字写入1602液晶
  62   1           E=0;                 //写完以后，恢复E的电平
  63   1      } 
  64          
  65          //---------------------------------------
  66          //名称：1602液晶显示地址写函数
  67          //---------------------------------------
  68          void LCD1602_Write_address(unsigned char x,unsigned char y)
  69          { 
  70   1           x&=0x0f;             //列地址限制在0-15间
  71   1           y&=0x01;             //行地址限制在0-1间
  72   1           if(y==0)             //如果是第一行
  73   1               LCD1602_Write_com_busy(x|0x80);        //将列地址写入
  74   1           else                 //如果是第二行
  75   1               LCD1602_Write_com_busy((x+0x40)|0x80); //将列地址写入
  76   1      } 
  77          
  78          //---------------------------------------
  79          //名称：1602液晶初始化函数
  80          //---------------------------------------
  81          void LCD1602_init(void)
  82          { 
  83   1           Delay1602(1500);               //调用延时函数
  84   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
  85   1           Delay1602(500);                //调用延时函数
  86   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
  87   1           Delay1602(500);                //调用延时函数
  88   1           LCD1602_Write_com(0x38);       //8位数据总线，两行显示模式，5*7点阵显示
  89   1           LCD1602_Write_com_busy(0x38);  //8位数据总线，两行显示模式，5*7点阵显示
  90   1           LCD1602_Write_com_busy(0x08);  //显示功能关，无光标
  91   1           LCD1602_Write_com_busy(0x01);  //清屏
  92   1           LCD1602_Write_com_busy(0x06);  //写入新的数据后，光标右移，显示屏不移动
  93   1           LCD1602_Write_com_busy(0x0C);  //显示功能开，无光标
  94   1      } 
  95          
  96          //---------------------------------------
  97          //名称：1602液晶指定地址显示函数
  98          //---------------------------------------
  99          void LCD1602_Disp(unsigned char x,unsigned char y,unsigned char buf)
 100          { 
 101   1           LCD1602_Write_address(x,y);    //先将地址信息写入
 102   1           LCD1602_Write_data_busy(buf);  //再写入要显示的数据
 103   1      } 
 104          
 105          //---------------------------------------
 106          //名称: 主函数
 107          //---------------------------------------
 108          void main(void)            //主函数,单片机开机后就是从这个函数开始运行
 109          {
 110   1      
 111   1          LCD1602_init();        //调用1602液晶初始化函数
 112   1      
 113   1          //****1602液晶第1行显示"ABCDEFGHIJKLMNOP"****
 114   1          //****1602液晶第2行显示"abcdefghijklmnop"****
 115   1          LCD1602_Disp(0,0,'A');     //在第1行的第1列显示A
 116   1          LCD1602_Disp(1,0,'B');     //在第1行的第2列显示B
 117   1          LCD1602_Disp(2,0,'C');     //在第1行的第3列显示C
C51 COMPILER V8.05a   TEST38                                                               02/11/2016 17:20:07 PAGE 3   

 118   1          LCD1602_Disp(3,0,'D');     //在第1行的第4列显示D
 119   1          LCD1602_Disp(4,0,'E');     //在第1行的第5列显示E
 120   1          LCD1602_Disp(5,0,'F');     //在第1行的第6列显示F
 121   1          LCD1602_Disp(6,0,'G');     //在第1行的第7列显示G
 122   1          LCD1602_Disp(7,0,'H');     //在第1行的第8列显示H
 123   1          LCD1602_Disp(8,0,'I');     //在第1行的第9列显示I
 124   1          LCD1602_Disp(9,0,'J');     //在第1行的第10列显示J
 125   1          LCD1602_Disp(10,0,'K');    //在第1行的第11列显示K
 126   1          LCD1602_Disp(11,0,'L');    //在第1行的第12列显示L
 127   1          LCD1602_Disp(12,0,'M');    //在第1行的第13列显示M
 128   1          LCD1602_Disp(13,0,'N');    //在第1行的第14列显示N
 129   1          LCD1602_Disp(14,0,'O');    //在第1行的第15列显示O
 130   1          LCD1602_Disp(15,0,'P');    //在第1行的第16列显示P
 131   1          LCD1602_Disp(0,1,'a');     //在第2行的第1列显示a
 132   1          LCD1602_Disp(1,1,'b');     //在第2行的第2列显示b
 133   1          LCD1602_Disp(2,1,'c');     //在第2行的第3列显示c
 134   1          LCD1602_Disp(3,1,'d');     //在第2行的第4列显示d
 135   1          LCD1602_Disp(4,1,'e');     //在第2行的第5列显示e
 136   1          LCD1602_Disp(5,1,'f');     //在第2行的第6列显示f
 137   1          LCD1602_Disp(6,1,'g');     //在第2行的第7列显示g
 138   1          LCD1602_Disp(7,1,'h');     //在第2行的第8列显示h
 139   1          LCD1602_Disp(8,1,'i');     //在第2行的第9列显示i
 140   1          LCD1602_Disp(9,1,'j');     //在第2行的第10列显示j
 141   1          LCD1602_Disp(10,1,'k');    //在第2行的第11列显示k
 142   1          LCD1602_Disp(11,1,'l');    //在第2行的第12列显示l
 143   1          LCD1602_Disp(12,1,'m');    //在第2行的第13列显示m
 144   1          LCD1602_Disp(13,1,'n');    //在第2行的第14列显示n
 145   1          LCD1602_Disp(14,1,'o');    //在第2行的第15列显示o
 146   1          LCD1602_Disp(15,1,'p');    //在第2行的第16列显示p
 147   1          //************************
 148   1      
 149   1          while(1)               //死循环,单片机初始化后,将一直运行这个死循环
 150   1          {
 151   2      
 152   2          }
 153   1      }
 154          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    403    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

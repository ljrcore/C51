; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\i2c_ee.o --depend=.\Obj\i2c_ee.d --device=DARMSTM --apcs=interwork -O3 -I..\ -I..\..\..\Libraries\CMSIS\Core\CM3 -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\Obj\i2c_ee.crf ..\i2c_ee.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;53       */
;;;54     void GPIO_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;55     {
;;;56       GPIO_InitTypeDef  GPIO_InitStructure; 
;;;57     
;;;58     
;;;59     
;;;60       GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_All;
000002  f64f70ff          MOV      r0,#0xffff
000006  f8ad0000          STRH     r0,[sp,#0]
;;;61       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2403              MOVS     r4,#3
00000c  f88d4002          STRB     r4,[sp,#2]
;;;62       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;63       GPIO_Init(GPIOA, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4810              LDR      r0,|L1.92|
00001a  f7fffffe          BL       GPIO_Init
;;;64       GPIO_Init(GPIOB, &GPIO_InitStructure);
00001e  4d10              LDR      r5,|L1.96|
000020  4669              MOV      r1,sp
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       GPIO_Init
;;;65     
;;;66     
;;;67        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |GPIO_Pin_10 |GPIO_Pin_11;
000028  f44f6070          MOV      r0,#0xf00
00002c  f8ad0000          STRH     r0,[sp,#0]
;;;68        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  //浮空输入	 
000030  2004              MOVS     r0,#4
000032  f88d0003          STRB     r0,[sp,#3]
;;;69        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	 //输出的最大频率为50HZ
000036  f88d4002          STRB     r4,[sp,#2]
;;;70        GPIO_Init(GPIOB, &GPIO_InitStructure);   //初始化GPIOA端口
00003a  4669              MOV      r1,sp
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       GPIO_Init
;;;71     
;;;72     
;;;73       /* Configure I2C1 pins: SCL and SDA */
;;;74       GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_6 | GPIO_Pin_7;
000042  20c0              MOVS     r0,#0xc0
000044  f8ad0000          STRH     r0,[sp,#0]
;;;75       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000048  f88d4002          STRB     r4,[sp,#2]
;;;76       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
00004c  201c              MOVS     r0,#0x1c
00004e  f88d0003          STRB     r0,[sp,#3]
;;;77       GPIO_Init(GPIOB, &GPIO_InitStructure);
000052  4669              MOV      r1,sp
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       GPIO_Init
;;;78     }
00005a  bd38              POP      {r3-r5,pc}
;;;79     
                          ENDP

                  |L1.92|
                          DCD      0x40010800
                  |L1.96|
                          DCD      0x40010c00

                          AREA ||i.I2C_Configuration||, CODE, READONLY, ALIGN=2

                  I2C_Configuration PROC
;;;84       */
;;;85     void I2C_Configuration(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;86     {
;;;87       I2C_InitTypeDef  I2C_InitStructure; 
;;;88     
;;;89       /* I2C configuration */
;;;90       I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
000002  2000              MOVS     r0,#0
000004  f8ad0000          STRH     r0,[sp,#0]
;;;91       I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
000008  f64b70ff          MOV      r0,#0xbfff
00000c  f8ad0002          STRH     r0,[sp,#2]
;;;92       I2C_InitStructure.I2C_OwnAddress1 = I2C1_SLAVE_ADDRESS7;
000010  20a0              MOVS     r0,#0xa0
000012  f8ad0004          STRH     r0,[sp,#4]
;;;93       I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
000016  f44f6080          MOV      r0,#0x400
00001a  f8ad0006          STRH     r0,[sp,#6]
;;;94       I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00001e  0100              LSLS     r0,r0,#4
000020  f8ad0008          STRH     r0,[sp,#8]
;;;95       I2C_InitStructure.I2C_ClockSpeed = I2C_Speed;
000024  4805              LDR      r0,|L2.60|
;;;96       
;;;97       /* I2C Peripheral Enable */
;;;98       I2C_Cmd(I2C1, ENABLE);
000026  4c06              LDR      r4,|L2.64|
000028  9003              STR      r0,[sp,#0xc]
00002a  2101              MOVS     r1,#1
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       I2C_Cmd
;;;99       /* Apply I2C configuration after enabling it */
;;;100      I2C_Init(I2C1, &I2C_InitStructure);
000032  4669              MOV      r1,sp
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_Init
;;;101    }
00003a  bd1f              POP      {r0-r4,pc}
;;;102    
                          ENDP

                  |L2.60|
                          DCD      0x00061a80
                  |L2.64|
                          DCD      0x40005400

                          AREA ||i.I2C_EE_BufferRead||, CODE, READONLY, ALIGN=2

                  I2C_EE_BufferRead PROC
;;;298      */
;;;299    void I2C_EE_BufferRead(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;300    {  
;;;301        /* While the bus is busy */
;;;302      while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));
000004  4e39              LDR      r6,|L3.236|
000006  4605              MOV      r5,r0                 ;300
000008  468a              MOV      r10,r1                ;300
00000a  4614              MOV      r4,r2                 ;300
00000c  f44f3700          MOV      r7,#0x20000
                  |L3.16|
000010  4639              MOV      r1,r7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       I2C_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d1f9              BNE      |L3.16|
;;;303      
;;;304      /* Send START condition */
;;;305      I2C_GenerateSTART(I2C1, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       I2C_GenerateSTART
;;;306      
;;;307      /* Test on EV5 and clear it */
;;;308      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
000024  4f32              LDR      r7,|L3.240|
                  |L3.38|
000026  4630              MOV      r0,r6
000028  4639              MOV      r1,r7
00002a  f7fffffe          BL       I2C_CheckEvent
00002e  2800              CMP      r0,#0
000030  d0f9              BEQ      |L3.38|
;;;309       
;;;310      /* Send EEPROM address for write */
;;;311      I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
000032  f8df80c0          LDR      r8,|L3.244|
000036  2200              MOVS     r2,#0
000038  f8b80000          LDRH     r0,[r8,#0]  ; EEPROM_ADDRESS
00003c  b2c1              UXTB     r1,r0
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       I2C_Send7bitAddress
;;;312    
;;;313      /* Test on EV6 and clear it */
;;;314      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
000044  f8df90b0          LDR      r9,|L3.248|
                  |L3.72|
000048  4630              MOV      r0,r6
00004a  4649              MOV      r1,r9
00004c  f7fffffe          BL       I2C_CheckEvent
000050  2800              CMP      r0,#0
000052  d0f9              BEQ      |L3.72|
;;;315      
;;;316      /* Clear EV6 by setting again the PE bit */
;;;317      I2C_Cmd(I2C1, ENABLE);
000054  2101              MOVS     r1,#1
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       I2C_Cmd
;;;318    
;;;319      /* Send the EEPROM's internal address to write to */
;;;320      I2C_SendData(I2C1, ReadAddr);  
00005c  4651              MOV      r1,r10
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       I2C_SendData
;;;321    
;;;322      /* Test on EV8 and clear it */
;;;323      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
000064  f8df9090          LDR      r9,|L3.248|
000068  f1090902          ADD      r9,r9,#2
                  |L3.108|
00006c  4649              MOV      r1,r9
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       I2C_CheckEvent
000074  2800              CMP      r0,#0
000076  d0f9              BEQ      |L3.108|
;;;324      
;;;325      /* Send STRAT condition a second time */  
;;;326      I2C_GenerateSTART(I2C1, ENABLE);
000078  2101              MOVS     r1,#1
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       I2C_GenerateSTART
                  |L3.128|
;;;327      
;;;328      /* Test on EV5 and clear it */
;;;329      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
000080  4639              MOV      r1,r7
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       I2C_CheckEvent
000088  2800              CMP      r0,#0
00008a  d0f9              BEQ      |L3.128|
;;;330      
;;;331      /* Send EEPROM address for read */
;;;332      I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Receiver);
00008c  f8b80000          LDRH     r0,[r8,#0]  ; EEPROM_ADDRESS
000090  2201              MOVS     r2,#1
000092  b2c1              UXTB     r1,r0
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       I2C_Send7bitAddress
;;;333      
;;;334      /* Test on EV6 and clear it */
;;;335      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
00009a  4f15              LDR      r7,|L3.240|
00009c  1c7f              ADDS     r7,r7,#1
                  |L3.158|
00009e  4639              MOV      r1,r7
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       I2C_CheckEvent
0000a6  2800              CMP      r0,#0
0000a8  d0f9              BEQ      |L3.158|
;;;336      
;;;337      /* While there is data to be read */
;;;338      while(NumByteToRead)  
;;;339      {
;;;340        if(NumByteToRead == 1)
;;;341        {
;;;342          /* Disable Acknowledgement */
;;;343          I2C_AcknowledgeConfig(I2C1, DISABLE);
;;;344          
;;;345          /* Send STOP Condition */
;;;346          I2C_GenerateSTOP(I2C1, ENABLE);
;;;347        }
;;;348    
;;;349        /* Test on EV7 and clear it */
;;;350        if(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))  
0000aa  4f11              LDR      r7,|L3.240|
0000ac  373f              ADDS     r7,r7,#0x3f
;;;351        {      
;;;352          /* Read a byte from the EEPROM */
;;;353          *pBuffer = I2C_ReceiveData(I2C1);
;;;354    
;;;355          /* Point to the next location where the byte read will be saved */
;;;356          pBuffer++; 
;;;357          
;;;358          /* Decrement the read bytes counter */
;;;359          NumByteToRead--;        
0000ae  e015              B        |L3.220|
                  |L3.176|
0000b0  2c01              CMP      r4,#1                 ;340
0000b2  d107              BNE      |L3.196|
0000b4  2100              MOVS     r1,#0                 ;343
0000b6  4630              MOV      r0,r6                 ;343
0000b8  f7fffffe          BL       I2C_AcknowledgeConfig
0000bc  2101              MOVS     r1,#1                 ;346
0000be  4630              MOV      r0,r6                 ;346
0000c0  f7fffffe          BL       I2C_GenerateSTOP
                  |L3.196|
0000c4  4639              MOV      r1,r7                 ;350
0000c6  4630              MOV      r0,r6                 ;350
0000c8  f7fffffe          BL       I2C_CheckEvent
0000cc  b130              CBZ      r0,|L3.220|
0000ce  4630              MOV      r0,r6                 ;353
0000d0  f7fffffe          BL       I2C_ReceiveData
0000d4  1e64              SUBS     r4,r4,#1
0000d6  f8050b01          STRB     r0,[r5],#1            ;353
0000da  b2a4              UXTH     r4,r4
                  |L3.220|
0000dc  2c00              CMP      r4,#0                 ;338
0000de  d1e7              BNE      |L3.176|
;;;360        }   
;;;361      }
;;;362    
;;;363      /* Enable Acknowledgement to be ready for another reception */
;;;364      I2C_AcknowledgeConfig(I2C1, ENABLE);
0000e0  4630              MOV      r0,r6
0000e2  e8bd47f0          POP      {r4-r10,lr}
0000e6  2101              MOVS     r1,#1
0000e8  f7ffbffe          B.W      I2C_AcknowledgeConfig
;;;365    }
;;;366    
                          ENDP

                  |L3.236|
                          DCD      0x40005400
                  |L3.240|
                          DCD      0x00030001
                  |L3.244|
                          DCD      ||.data||
                  |L3.248|
                          DCD      0x00070082

                          AREA ||i.I2C_EE_BufferWrite||, CODE, READONLY, ALIGN=1

                  I2C_EE_BufferWrite PROC
;;;128      */
;;;129    void I2C_EE_BufferWrite(uint8_t* pBuffer, uint8_t WriteAddr, uint16_t NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;130    {
000004  4605              MOV      r5,r0
;;;131      uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0;
;;;132    
;;;133      Addr = WriteAddr % I2C_PageSize;
000006  f0110007          ANDS     r0,r1,#7
00000a  460c              MOV      r4,r1                 ;130
;;;134      count = I2C_PageSize - Addr;
00000c  f1c00708          RSB      r7,r0,#8
;;;135      NumOfPage =  NumByteToWrite / I2C_PageSize;
000010  f3c206c7          UBFX     r6,r2,#3,#8
;;;136      NumOfSingle = NumByteToWrite % I2C_PageSize;
000014  f0020807          AND      r8,r2,#7
;;;137     
;;;138      /* If WriteAddr is I2C_PageSize aligned  */
;;;139      if(Addr == 0) 
000018  d114              BNE      |L4.68|
;;;140      {
;;;141        /* If NumByteToWrite < I2C_PageSize */
;;;142        if(NumOfPage == 0) 
00001a  b3ae              CBZ      r6,|L4.136|
00001c  e009              B        |L4.50|
                  |L4.30|
;;;143        {
;;;144          I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
;;;145          I2C_EE_WaitEepromStandbyState();
;;;146        }
;;;147        /* If NumByteToWrite > I2C_PageSize */
;;;148        else  
;;;149        {
;;;150          while(NumOfPage--)
;;;151          {
;;;152            I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize); 
00001e  2208              MOVS     r2,#8
000020  4621              MOV      r1,r4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       I2C_EE_PageWrite
;;;153        	I2C_EE_WaitEepromStandbyState();
000028  f7fffffe          BL       I2C_EE_WaitEepromStandbyState
;;;154            WriteAddr +=  I2C_PageSize;
00002c  3408              ADDS     r4,r4,#8
00002e  b2e4              UXTB     r4,r4
;;;155            pBuffer += I2C_PageSize;
000030  3508              ADDS     r5,r5,#8
                  |L4.50|
000032  0030              MOVS     r0,r6                 ;150
000034  f1a60601          SUB      r6,r6,#1              ;150
000038  b2f6              UXTB     r6,r6                 ;150
00003a  d1f0              BNE      |L4.30|
                  |L4.60|
;;;156          }
;;;157    
;;;158          if(NumOfSingle!=0)
00003c  f1b80f00          CMP      r8,#0
000040  d02c              BEQ      |L4.156|
000042  e022              B        |L4.138|
                  |L4.68|
;;;159          {
;;;160            I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
;;;161            I2C_EE_WaitEepromStandbyState();
;;;162          }
;;;163        }
;;;164      }
;;;165      /* If WriteAddr is not I2C_PageSize aligned  */
;;;166      else 
;;;167      {
;;;168        /* If NumByteToWrite < I2C_PageSize */
;;;169        if(NumOfPage== 0) 
000044  b306              CBZ      r6,|L4.136|
;;;170        {
;;;171          I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
;;;172          I2C_EE_WaitEepromStandbyState();
;;;173        }
;;;174        /* If NumByteToWrite > I2C_PageSize */
;;;175        else
;;;176        {
;;;177          NumByteToWrite -= count;
000046  1bd0              SUBS     r0,r2,r7
;;;178          NumOfPage =  NumByteToWrite / I2C_PageSize;
000048  f3c006c7          UBFX     r6,r0,#3,#8
;;;179          NumOfSingle = NumByteToWrite % I2C_PageSize;	
00004c  f0000807          AND      r8,r0,#7
;;;180          
;;;181          if(count != 0)
000050  b1a7              CBZ      r7,|L4.124|
;;;182          {  
;;;183            I2C_EE_PageWrite(pBuffer, WriteAddr, count);
000052  463a              MOV      r2,r7
000054  4621              MOV      r1,r4
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       I2C_EE_PageWrite
;;;184            I2C_EE_WaitEepromStandbyState();
00005c  f7fffffe          BL       I2C_EE_WaitEepromStandbyState
;;;185            WriteAddr += count;
000060  19e0              ADDS     r0,r4,r7
000062  b2c4              UXTB     r4,r0
;;;186            pBuffer += count;
000064  443d              ADD      r5,r5,r7
000066  e009              B        |L4.124|
                  |L4.104|
;;;187          } 
;;;188          
;;;189          while(NumOfPage--)
;;;190          {
;;;191            I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);
000068  2208              MOVS     r2,#8
00006a  4621              MOV      r1,r4
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       I2C_EE_PageWrite
;;;192            I2C_EE_WaitEepromStandbyState();
000072  f7fffffe          BL       I2C_EE_WaitEepromStandbyState
;;;193            WriteAddr +=  I2C_PageSize;
000076  3408              ADDS     r4,r4,#8
000078  b2e4              UXTB     r4,r4
;;;194            pBuffer += I2C_PageSize;  
00007a  3508              ADDS     r5,r5,#8
                  |L4.124|
00007c  0030              MOVS     r0,r6                 ;189
00007e  f1a60601          SUB      r6,r6,#1              ;189
000082  b2f6              UXTB     r6,r6                 ;189
000084  d1f0              BNE      |L4.104|
000086  e7d9              B        |L4.60|
                  |L4.136|
000088  e7ff              B        |L4.138|
                  |L4.138|
;;;195          }
;;;196          if(NumOfSingle != 0)
;;;197          {
;;;198            I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); 
00008a  4642              MOV      r2,r8
00008c  4621              MOV      r1,r4
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       I2C_EE_PageWrite
;;;199            I2C_EE_WaitEepromStandbyState();
000094  e8bd41f0          POP      {r4-r8,lr}
000098  f7ffbffe          B.W      I2C_EE_WaitEepromStandbyState
                  |L4.156|
;;;200          }
;;;201        }
;;;202      }  
;;;203    }
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;204    
                          ENDP


                          AREA ||i.I2C_EE_ByteWrite||, CODE, READONLY, ALIGN=2

                  I2C_EE_ByteWrite PROC
;;;211      */
;;;212    void I2C_EE_ByteWrite(uint8_t* pBuffer, uint8_t WriteAddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;213    {
;;;214      /* Send STRAT condition */
;;;215      I2C_GenerateSTART(I2C1, ENABLE);
000004  4c1b              LDR      r4,|L5.116|
000006  4605              MOV      r5,r0                 ;213
000008  460f              MOV      r7,r1                 ;213
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_GenerateSTART
;;;216    
;;;217      /* Test on EV5 and clear it */
;;;218      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));  
000012  4e19              LDR      r6,|L5.120|
                  |L5.20|
000014  4620              MOV      r0,r4
000016  4631              MOV      r1,r6
000018  f7fffffe          BL       I2C_CheckEvent
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L5.20|
;;;219    
;;;220      /* Send EEPROM address for write */
;;;221      I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
000020  4816              LDR      r0,|L5.124|
000022  2200              MOVS     r2,#0
000024  8800              LDRH     r0,[r0,#0]  ; EEPROM_ADDRESS
000026  b2c1              UXTB     r1,r0
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       I2C_Send7bitAddress
;;;222      
;;;223      /* Test on EV6 and clear it */
;;;224      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
00002e  4e14              LDR      r6,|L5.128|
                  |L5.48|
000030  4620              MOV      r0,r4
000032  4631              MOV      r1,r6
000034  f7fffffe          BL       I2C_CheckEvent
000038  2800              CMP      r0,#0
00003a  d0f9              BEQ      |L5.48|
;;;225          
;;;226      /* Send the EEPROM's internal address to write to */
;;;227      I2C_SendData(I2C1, WriteAddr);
00003c  4639              MOV      r1,r7
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       I2C_SendData
;;;228      
;;;229      /* Test on EV8 and clear it */
;;;230      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
000044  4e0e              LDR      r6,|L5.128|
000046  1cb6              ADDS     r6,r6,#2
                  |L5.72|
000048  4631              MOV      r1,r6
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_CheckEvent
000050  2800              CMP      r0,#0
000052  d0f9              BEQ      |L5.72|
;;;231    
;;;232      /* Send the byte to be written */
;;;233      I2C_SendData(I2C1, *pBuffer); 
000054  7829              LDRB     r1,[r5,#0]
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       I2C_SendData
                  |L5.92|
;;;234       
;;;235      /* Test on EV8 and clear it */
;;;236      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
00005c  4631              MOV      r1,r6
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       I2C_CheckEvent
000064  2800              CMP      r0,#0
000066  d0f9              BEQ      |L5.92|
;;;237      
;;;238      /* Send STOP condition */
;;;239      I2C_GenerateSTOP(I2C1, ENABLE);
000068  4620              MOV      r0,r4
00006a  e8bd41f0          POP      {r4-r8,lr}
00006e  2101              MOVS     r1,#1
000070  f7ffbffe          B.W      I2C_GenerateSTOP
;;;240    }
;;;241    
                          ENDP

                  |L5.116|
                          DCD      0x40005400
                  |L5.120|
                          DCD      0x00030001
                  |L5.124|
                          DCD      ||.data||
                  |L5.128|
                          DCD      0x00070082

                          AREA ||i.I2C_EE_Init||, CODE, READONLY, ALIGN=2

                  I2C_EE_Init PROC
;;;107      */
;;;108    void I2C_EE_Init()
000000  b510              PUSH     {r4,lr}
;;;109    {
;;;110      /* GPIO configuration */
;;;111      GPIO_Configuration();
000002  f7fffffe          BL       GPIO_Configuration
;;;112    
;;;113      /* I2C configuration */
;;;114      I2C_Configuration();
000006  f7fffffe          BL       I2C_Configuration
;;;115    
;;;116      /* depending on the EEPROM Address selected in the i2c_ee.h file */
;;;117      /* Select the EEPROM Block0 to write on */
;;;118      EEPROM_ADDRESS = EEPROM_Block_ADDRESS;
00000a  4902              LDR      r1,|L6.20|
00000c  20a0              MOVS     r0,#0xa0
00000e  8008              STRH     r0,[r1,#0]
;;;119    }
000010  bd10              POP      {r4,pc}
;;;120    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      ||.data||

                          AREA ||i.I2C_EE_PageWrite||, CODE, READONLY, ALIGN=2

                  I2C_EE_PageWrite PROC
;;;250      */
;;;251    void I2C_EE_PageWrite(uint8_t* pBuffer, uint8_t WriteAddr, uint8_t NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;252    {
;;;253      /* While the bus is busy */
;;;254      while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));
000004  4e23              LDR      r6,|L7.148|
000006  4604              MOV      r4,r0                 ;252
000008  4688              MOV      r8,r1                 ;252
00000a  4615              MOV      r5,r2                 ;252
00000c  f44f3700          MOV      r7,#0x20000
                  |L7.16|
000010  4639              MOV      r1,r7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       I2C_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d1f9              BNE      |L7.16|
;;;255      
;;;256      /* Send START condition */
;;;257      I2C_GenerateSTART(I2C1, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       I2C_GenerateSTART
;;;258      
;;;259      /* Test on EV5 and clear it */
;;;260      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); 
000024  4f1c              LDR      r7,|L7.152|
                  |L7.38|
000026  4630              MOV      r0,r6
000028  4639              MOV      r1,r7
00002a  f7fffffe          BL       I2C_CheckEvent
00002e  2800              CMP      r0,#0
000030  d0f9              BEQ      |L7.38|
;;;261      
;;;262      /* Send EEPROM address for write */
;;;263      I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
000032  481a              LDR      r0,|L7.156|
000034  2200              MOVS     r2,#0
000036  8800              LDRH     r0,[r0,#0]  ; EEPROM_ADDRESS
000038  b2c1              UXTB     r1,r0
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       I2C_Send7bitAddress
;;;264    
;;;265      /* Test on EV6 and clear it */
;;;266      while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));  
000040  4f17              LDR      r7,|L7.160|
                  |L7.66|
000042  4630              MOV      r0,r6
000044  4639              MOV      r1,r7
000046  f7fffffe          BL       I2C_CheckEvent
00004a  2800              CMP      r0,#0
00004c  d0f9              BEQ      |L7.66|
;;;267    
;;;268      /* Send the EEPROM's internal address to write to */    
;;;269      I2C_SendData(I2C1, WriteAddr);  
00004e  4641              MOV      r1,r8
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       I2C_SendData
;;;270    
;;;271      /* Test on EV8 and clear it */
;;;272      while(! I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
000056  4f12              LDR      r7,|L7.160|
000058  1cbf              ADDS     r7,r7,#2
                  |L7.90|
00005a  4639              MOV      r1,r7
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       I2C_CheckEvent
000062  2800              CMP      r0,#0
000064  d0f9              BEQ      |L7.90|
000066  e00a              B        |L7.126|
                  |L7.104|
;;;273    
;;;274      /* While there is data to be written */
;;;275      while(NumByteToWrite--)  
;;;276      {
;;;277        /* Send the current byte */
;;;278        I2C_SendData(I2C1, *pBuffer); 
000068  7821              LDRB     r1,[r4,#0]
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       I2C_SendData
;;;279    
;;;280        /* Point to the next byte to be written */
;;;281        pBuffer++; 
000070  1c64              ADDS     r4,r4,#1
                  |L7.114|
;;;282      
;;;283        /* Test on EV8 and clear it */
;;;284        while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
000072  4639              MOV      r1,r7
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       I2C_CheckEvent
00007a  2800              CMP      r0,#0
00007c  d0f9              BEQ      |L7.114|
                  |L7.126|
00007e  0028              MOVS     r0,r5                 ;275
000080  f1a50501          SUB      r5,r5,#1              ;275
000084  b2ed              UXTB     r5,r5                 ;275
000086  d1ef              BNE      |L7.104|
;;;285      }
;;;286    
;;;287      /* Send STOP condition */
;;;288      I2C_GenerateSTOP(I2C1, ENABLE);
000088  4630              MOV      r0,r6
00008a  e8bd41f0          POP      {r4-r8,lr}
00008e  2101              MOVS     r1,#1
000090  f7ffbffe          B.W      I2C_GenerateSTOP
;;;289    }
;;;290    
                          ENDP

                  |L7.148|
                          DCD      0x40005400
                  |L7.152|
                          DCD      0x00030001
                  |L7.156|
                          DCD      ||.data||
                  |L7.160|
                          DCD      0x00070082

                          AREA ||i.I2C_EE_WaitEepromStandbyState||, CODE, READONLY, ALIGN=2

                  I2C_EE_WaitEepromStandbyState PROC
;;;371      */
;;;372    void I2C_EE_WaitEepromStandbyState(void)      
000000  b570              PUSH     {r4-r6,lr}
;;;373    {
;;;374      __IO uint16_t SR1_Tmp = 0;
;;;375    
;;;376      do
;;;377      {
;;;378        /* Send START condition */
;;;379        I2C_GenerateSTART(I2C1, ENABLE);
000002  4d10              LDR      r5,|L8.68|
;;;380        /* Read I2C1 SR1 register */
;;;381        SR1_Tmp = I2C_ReadRegister(I2C1, I2C_Register_SR1);
;;;382        /* Send EEPROM address for write */
;;;383        I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
000004  4c10              LDR      r4,|L8.72|
                  |L8.6|
000006  2101              MOVS     r1,#1                 ;379
000008  4628              MOV      r0,r5                 ;379
00000a  f7fffffe          BL       I2C_GenerateSTART
00000e  2114              MOVS     r1,#0x14              ;381
000010  4628              MOV      r0,r5                 ;381
000012  f7fffffe          BL       I2C_ReadRegister
000016  8820              LDRH     r0,[r4,#0]  ; EEPROM_ADDRESS
000018  2200              MOVS     r2,#0
00001a  b2c1              UXTB     r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       I2C_Send7bitAddress
;;;384      }while(!(I2C_ReadRegister(I2C1, I2C_Register_SR1) & 0x0002));
000022  2114              MOVS     r1,#0x14
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       I2C_ReadRegister
00002a  0780              LSLS     r0,r0,#30
00002c  d5eb              BPL      |L8.6|
;;;385      
;;;386      /* Clear AF flag */
;;;387      I2C_ClearFlag(I2C1, I2C_FLAG_AF);
00002e  4907              LDR      r1,|L8.76|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       I2C_ClearFlag
;;;388      
;;;389      /* STOP condition */    
;;;390      I2C_GenerateSTOP(I2C1, ENABLE);  
000036  4628              MOV      r0,r5
000038  e8bd4070          POP      {r4-r6,lr}
00003c  2101              MOVS     r1,#1
00003e  f7ffbffe          B.W      I2C_GenerateSTOP
;;;391    }
;;;392    
                          ENDP

000042  0000              DCW      0x0000
                  |L8.68|
                          DCD      0x40005400
                  |L8.72|
                          DCD      ||.data||
                  |L8.76|
                          DCD      0x10000400

                          AREA ||.data||, DATA, ALIGN=1

                  EEPROM_ADDRESS
000000  0000              DCB      0x00,0x00

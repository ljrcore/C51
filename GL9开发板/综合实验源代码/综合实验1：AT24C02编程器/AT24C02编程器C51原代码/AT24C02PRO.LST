C51 COMPILER V7.00  AT24C02PRO                                                             10/17/2012 09:47:19 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE AT24C02PRO
OBJECT MODULE PLACED IN AT24C02PRO.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE AT24C02PRO.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          ////////////////////////////////////////////////////////////////////////////
   2          //                给力者单片机开发学习系统，开发学习都给力！              //
   3          ////////////////////////////////////////////////////////////////////////////
   4          //                     学习51单片机，其实可以很简单                       //
   5          ////////////////////////////////////////////////////////////////////////////
   6          //                宁波芯动电子有限公司  www.MovingChip.com                //
   7          ////////////////////////////////////////////////////////////////////////////
   8          #include <AT89X52.h>       //调用51单片机的头文件
   9          #include <Intrins.h>       //因本例需要使用空操作，必须调用这个头文件
  10          
  11          //---------------------------------------
  12          //软件模拟IIC相关I/O设置
  13          sbit SCL=P1^5;             //AT24C02的 SCL 引脚接于单片机的P1.5引脚上
  14          sbit SDA=P1^4;             //AT24C02的 SDA 引脚接于单片机的P1.4引脚上
  15          //---------------------------------------
  16          
  17          unsigned char ComBuf[18];//串口通讯数据缓存，发送和接收都使用
  18          unsigned int  nTimeOut;//超时计数
  19          unsigned char Address;
  20          unsigned char Buf[16];
  21          unsigned char n;        
  22          //---------------------------------------
  23          //名称：生IIC启动信号函数
  24          //适用：给力者GL9单片机开发学习系统
  25          //公司：宁波芯动电子有限公司
  26          //网址：www.MovingChip.com
  27          //日期：20120914
  28          //---------------------------------------
  29          void IICstart(void)
  30          { 
  31   1           SDA=1;                //先将SDA=1，以准备在SCL=1时，将SDA=0
  32   1           SCL=1;                //时钟总线拉高 
  33   1           _nop_();                   //略做延时
  34   1           _nop_();                   //略做延时
  35   1           SDA=0;                //SCL=1时，将SDA拉低即产生启动信号 
  36   1           _nop_();                   //略做延时
  37   1           _nop_();                   //略做延时
  38   1           SCL=0;                //将SCL=0，完成启动信号操作     
  39   1      } 
  40          
  41          //---------------------------------------
  42          //名称：IIC停止信号函数
  43          //适用：给力者GL9单片机开发学习系统
  44          //公司：宁波芯动电子有限公司
  45          //网址：www.MovingChip.com
  46          //日期：20120914
  47          //---------------------------------------
  48          void IICstop(void)
  49          { 
  50   1           SDA=0;                //先将SDA=0，以准备在SCL=1时，将SDA=1
  51   1           SCL=1;                //时钟总线拉高 
  52   1           _nop_();                   //略做延时
  53   1           _nop_();                   //略做延时
  54   1           SDA=1;                //SCL=1时，将SDA拉高即产生停止信号 
  55   1           _nop_();                   //略做延时
C51 COMPILER V7.00  AT24C02PRO                                                             10/17/2012 09:47:19 PAGE 2   

  56   1           _nop_();                   //略做延时
  57   1           SCL=0;                //将SCL=0，完成启动信号操作      
  58   1      } 
  59          
  60          //---------------------------------------
  61          //名称：向IIC总线写入1个字节函数
  62          //适用：给力者GL9单片机开发学习系统
  63          //公司：宁波芯动电子有限公司
  64          //网址：www.MovingChip.com
  65          //日期：20120914
  66          //---------------------------------------
  67          void Write1Byte(unsigned char Buf1)
  68          { 
  69   1           unsigned char k;      //1个字节要分8次写入，需要定义一个寄存器用来计数
  70   1           for(k=0;k<8;k++)      //做一个8次的循环，每次写入1位，需要写8次
  71   1           {
  72   2               if(Buf1&0x80)     //从最高位开始写 
  73   2               {
  74   3                   SDA=1;        //如果欲写入数据为1，就将数据线置1
  75   3               }
  76   2               else
  77   2               {
  78   3                   SDA=0;        //如果欲写入数据为0，就将数据线写0 
  79   3               }
  80   2               _nop_();          //略做延时
  81   2               _nop_();          //略做延时
  82   2               SCL=1;            //时钟线做一个上升沿，将一位数据写入
  83   2               Buf1=Buf1<<1;     //数据左移一位，将下次要写入的位数据移到最高位
  84   2               _nop_();          //略做延时
  85   2                              _nop_();          //略做延时
  86   2                      _nop_();          //略做延时
  87   2                              _nop_();          //略做延时
  88   2                      _nop_();          //略做延时
  89   2                      _nop_();          //略做延时
  90   2                      _nop_();          //略做延时                    
  91   2               SCL=0;            //将SCL=0，以准备通过上升沿将数据写入      
  92   2           }
  93   1           SDA=1;                //将SDA=1，准备读应答信号
  94   1           _nop_();              //略做延时
  95   1           SCL=1;                //将SCL=1，做个上升沿准备读应答信号
  96   1           _nop_();              //略做延时
  97   1           _nop_();              //略做延时
  98   1                _nop_();              //略做延时
  99   1           _nop_();              //略做延时
 100   1           _nop_();              //略做延时
 101   1           _nop_();              //略做延时
 102   1                _nop_();              //略做延时
 103   1           _nop_();              //略做延时
 104   1                _nop_();              //略做延时
 105   1           _nop_();              //略做延时
 106   1           SCL=0;                //将SCL=0，结束应答信号读操作
 107   1                _nop_();              //略做延时
 108   1           _nop_();              //略做延时
 109   1      } 
 110          
 111          //---------------------------------------
 112          //名称：从IIC总线读入1个字节函数
 113          //适用：给力者GL9单片机开发学习系统
 114          //公司：宁波芯动电子有限公司
 115          //网址：www.MovingChip.com
 116          //日期：20120914
 117          //---------------------------------------
C51 COMPILER V7.00  AT24C02PRO                                                             10/17/2012 09:47:19 PAGE 3   

 118          unsigned char Read1Byte(void)
 119          { 
 120   1           unsigned char k;      //1个字节要分8次读出，需要定义一个寄存器用来计数
 121   1           unsigned char t=0;    //定义一个寄存器用保存读出数据
 122   1           for(k=0;k<8;k++)      //做一个8次的循环，每次读入1位，需要读8次
 123   1           {
 124   2               t=t<<1;           //数据左移一位，空出最低位以准备保存读入的一位数据
 125   2               SDA=1;            //将SDA写1准备读
 126   2               SCL=1;            //将SCL=1，做个上升沿准备读一位数据
 127   2               _nop_();          //略做延时
 128   2               _nop_();          //略做延时
 129   2               if(SDA==1)        //读一位数据，并判断 
 130   2               {
 131   3                   t=t|0x01;     //如果读入数据为1，就将接收缓冲区最低一位置1
 132   3               }
 133   2               else
 134   2               {
 135   3                   t=t&0xfe;     //如果读入数据为0，就将接收缓冲区最低一位写0
 136   3               }
 137   2               SCL=0;            //SCL恢复为0，结束一位数据读操作
 138   2               _nop_();          //略做延时
 139   2               _nop_();          //略做延时
 140   2                              _nop_();          //略做延时
 141   2               _nop_();          //略做延时
 142   2           }    
 143   1                _nop_();              //略做延时
 144   1           _nop_();              //略做延时
 145   1           return t;             //将读入的一个字节返回
 146   1      } 
 147          //---------------------------------------
 148          //名称: 向AT24C02指定地址上写入N字节数据函数    
 149          //适用：给力者GL9单片机开发学习系统
 150          //公司：宁波芯动电子有限公司
 151          //网址：www.MovingChip.com
 152          //日期：20120914
 153          //---------------------------------------
 154          void AT24C02_WriteByte(unsigned char Address,unsigned char *AT24C02_Byte,unsigned char nByte)
 155          {
 156   1              unsigned char i;  
 157   1              IICstart();            //IIC启动信号
 158   1              Write1Byte(0xA0);      //发送AT24C02的器件地址和写信号
 159   1              Write1Byte(Address);   //发送地址                   
 160   1      
 161   1              for(i=0;i<nByte;i++)
 162   1              {
 163   2                      Write1Byte(*AT24C02_Byte);
 164   2                      AT24C02_Byte++;
 165   2                      _nop_();              //略做延时
 166   2            _nop_();              //略做延时
 167   2                 _nop_();              //略做延时
 168   2            _nop_();              //略做延时
 169   2              }
 170   1              IICstop();             //产生IIC停止信号
 171   1      }
 172          //---------------------------------------
 173          //名称: 从AT24C02指定地址上读出N字节数据函数    
 174          //适用：给力者GL9单片机开发学习系统
 175          //公司：宁波芯动电子有限公司
 176          //网址：www.MovingChip.com
 177          //日期：20120914
 178          //---------------------------------------
 179          void AT24C02_ReadByte(unsigned char Address,unsigned char *AT24C02_Byte,unsigned char nByte)
C51 COMPILER V7.00  AT24C02PRO                                                             10/17/2012 09:47:19 PAGE 4   

 180          {    
 181   1              unsigned char i;
 182   1      
 183   1              IICstart();            //IIC启动信号
 184   1              Write1Byte(0xA0);      //发送AT24C02的器件地址和写信号
 185   1              Write1Byte(Address);   //发送地址
 186   1              _nop_();              //略做延时
 187   1         _nop_();              //略做延时
 188   1              IICstart();            //IIC启动信号
 189   1              Write1Byte(0xA1);      //发送AT24C02的器件地址和读信号
 190   1      
 191   1         for(i=0;i<nByte-1;i++) //除去最后一个数据以外，其他的读取后发应答标志
 192   1              {
 193   2                      *AT24C02_Byte=Read1Byte();//读一个字节数据              
 194   2                      AT24C02_Byte++;         
 195   2                      SDA=0;               //将SDA=0，准备发应答信号
 196   2            _nop_();              //略做延时
 197   2            SCL=1;                //将SCL=1，做个上升沿准备发应答信号
 198   2            _nop_();              //略做延时
 199   2            _nop_();              //略做延时
 200   2                 _nop_();              //略做延时
 201   2            _nop_();              //略做延时    
 202   2            SCL=0;                //将SCL=0，结束应答信号发操作
 203   2                 _nop_();              //略做延时
 204   2            _nop_();              //略做延时
 205   2              }
 206   1              *AT24C02_Byte=Read1Byte();//读最后一个字节数据          
 207   1              SDA=1;                //将SDA=1，准备发非应答信号
 208   1         _nop_();              //略做延时
 209   1         SCL=1;                //将SCL=1，做个上升沿准备发应答信号
 210   1         _nop_();              //略做延时
 211   1         _nop_();              //略做延时
 212   1              _nop_();              //略做延时
 213   1         _nop_();              //略做延时 
 214   1         SCL=0;                //将SCL=0，结束应答信号发操作
 215   1              _nop_();              //略做延时
 216   1         _nop_();              //略做延时
 217   1              IICstop();             //产生IIC停止信号        
 218   1      }
 219          //---------------------------------------
 220          //名称: 等待上位机18字节函数
 221          //适用：给力者GL9单片机开发学习系统
 222          //公司：宁波芯动电子有限公司
 223          //网址：www.MovingChip.com
 224          //日期：20120914
 225          //---------------------------------------
 226          bit WaitData()
 227          {
 228   1              unsigned char n;
 229   1              RI=0;
 230   1              for(n=0;n<18;n++)
 231   1              {
 232   2                      nTimeOut=0;
 233   2                      while(!RI)
 234   2                      {
 235   3                              nTimeOut++;
 236   3                              if(nTimeOut>10000)
 237   3                              {
 238   4                                      return 0;
 239   4                              }
 240   3                      }
 241   2                      RI=0;
C51 COMPILER V7.00  AT24C02PRO                                                             10/17/2012 09:47:19 PAGE 5   

 242   2                      ComBuf[n]=SBUF;
 243   2              }
 244   1              return 1;
 245   1      }
 246          //---------------------------------------
 247          //名称: 向上位机发送18字节函数
 248          //适用：给力者GL9单片机开发学习系统
 249          //公司：宁波芯动电子有限公司
 250          //网址：www.MovingChip.com
 251          //日期：20120914
 252          //---------------------------------------
 253          void SendData()
 254          {
 255   1              unsigned char n=0;
 256   1              for(n;n<18;n++)
 257   1              {
 258   2                      TI=0;
 259   2                      SBUF=ComBuf[n];
 260   2                      while(!TI){}
 261   2                      TI=0;
 262   2              }
 263   1      }
 264          //---------------------------------------
 265          //名称: 主函数
 266          //适用：给力者GL9单片机开发学习系统
 267          //公司：宁波芯动电子有限公司
 268          //网址：www.MovingChip.com
 269          //日期：20120914
 270          //---------------------------------------
 271          void main(void)            //主函数,单片机开机后就是从这个函数开始运行
 272          {
 273   1          //*****USART串口初始化*****
 274   1              TMOD&=0x0F;            //把TMOD高4位清0
 275   1         TMOD|=0x20;            //将TMOD的M1位置1，设置成自动装入的8位定时器
 276   1         TH1=0xFF;              //设置波特率为57600
 277   1         TL1=0xFF;              //设置波特率为57600
 278   1         TR1=1;                 //启动定时器T1，作为串口波特率发生器
 279   1         SCON=0x50;             //10位异步收发，波特率由定时器控制，允许串口接收
 280   1         ES=0;                  //禁止串口中断
 281   1         //**************************
 282   1         while(1)               //死循环,单片机初始化后,将一直运行这个死循环
 283   1         {    
 284   2              if(WaitData()==1)   //如果接收成功
 285   2                      {               
 286   3                              if(ComBuf[0]==1) //如果上位机发1，为读识别码
 287   3                              {
 288   4                                      ComBuf[2]=6;
 289   4                              ComBuf[3]=2;
 290   4                              ComBuf[4]=4;  
 291   4                                      SendData();  //将识别码624发给上位机
 292   4                              }
 293   3                              else if(ComBuf[0]==2) //如果上位机发2，为写AT24C02
 294   3                              {
 295   4                                      SendData();//回应上位机表示进入写器件状态，可以发来数据
 296   4                                      Address=0;
 297   4                                      while(1)
 298   4                                      {
 299   5                                              if(WaitData()==1&&ComBuf[1]==0x01)//如果接收数据成功并且ComBuf[0]==1表示继续写
 300   5                                              {                       
 301   6                                                      for(n=0;n<8;n++)
 302   6                                                      {
 303   7                                                              Buf[n]=ComBuf[n+2];             //把接收到的COMBUF[2]-[9]内的数据移到
C51 COMPILER V7.00  AT24C02PRO                                                             10/17/2012 09:47:19 PAGE 6   

 304   7                                                                                                                      //BUF[0]-[7]内，以便套用连续写函数格式
 305   7                                                      }
 306   6                                                      AT24C02_WriteByte(Address,Buf,8);//ComBuf[2~9]为待写入数据块                                            
 307   6                                                      Address+=8;                                             //地址加8，准备写下一轮 
 308   6                                                      for(nTimeOut=0;nTimeOut<512;nTimeOut++);
 309   6                                                      for(n=0;n<8;n++)
 310   6                                                      {
 311   7                                                              Buf[n]=ComBuf[n+10];            //把接收到的COMBUF[10]-[17]内的数据移到
 312   7                                                                                                                      //BUF[0]-[7]内，以便套用连续写函数格式
 313   7                                                      }
 314   6                                                      AT24C02_WriteByte(Address,Buf,8);//ComBuf[10~17]为待写入数据块                                          
 315   6                                                      Address+=8;                                             //地址加8，准备写下一轮 
 316   6                                                      SendData();                                             //通知上位机继续发                      
 317   6                                              }       
 318   5                                              else
 319   5                                              {
 320   6                                                      break;  //退出while(1)
 321   6                                              }
 322   5                                      }               
 323   4                              }
 324   3                              else if(ComBuf[0]==3) //如果上位机发3，为读AT24C02
 325   3                              {
 326   4                                      SendData();//回应上位机表示进入读状态
 327   4                                      Address=0;
 328   4                                      while(1)
 329   4                                      {
 330   5                                              if(WaitData()==1&&ComBuf[1]==1)//如果接收数据成功并且ComBuf[0]==1表示继续读
 331   5                                              {
 332   6                                                      AT24C02_ReadByte(Address,Buf,16);//从Address开始，连续读16个字节，放入BUF[]里
 333   6                                                      Address+=16;
 334   6                                                      for(n=0;n<16;n++)
 335   6                                                      {
 336   7                                                              ComBuf[n+2]=Buf[n];     
 337   7                                                              _nop_();              //略做延时
 338   7                                                              _nop_();              //略做延时
 339   7                                                              _nop_();              //略做延时
 340   7                                                              _nop_();              //略做延时
 341   7                                                      }                       
 342   6                                                      SendData();                             
 343   6                                              }
 344   5                                              else
 345   5                                              {
 346   6                                                      break;  //退出while(1)
 347   6                                              }
 348   5                                      }               
 349   4                              }
 350   3                      }     
 351   2         }
 352   1      }
 353          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    557    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
